local ffi = require("ffi")
ffi.cdef([[typedef enum VkDynamicState{VK_DYNAMIC_STATE_VIEWPORT=0,VK_DYNAMIC_STATE_SCISSOR=1,VK_DYNAMIC_STATE_LINE_WIDTH=2,VK_DYNAMIC_STATE_DEPTH_BIAS=3,VK_DYNAMIC_STATE_BLEND_CONSTANTS=4,VK_DYNAMIC_STATE_DEPTH_BOUNDS=5,VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK=6,VK_DYNAMIC_STATE_STENCIL_WRITE_MASK=7,VK_DYNAMIC_STATE_STENCIL_REFERENCE=8,VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV=1000087000,VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT=1000099000,VK_DYNAMIC_STATE_BEGIN_RANGE=0,VK_DYNAMIC_STATE_END_RANGE=8,VK_DYNAMIC_STATE_RANGE_SIZE=9,VK_DYNAMIC_STATE_MAX_ENUM=2147483647};
typedef enum VkObjectType{VK_OBJECT_TYPE_UNKNOWN=0,VK_OBJECT_TYPE_INSTANCE=1,VK_OBJECT_TYPE_PHYSICAL_DEVICE=2,VK_OBJECT_TYPE_DEVICE=3,VK_OBJECT_TYPE_QUEUE=4,VK_OBJECT_TYPE_SEMAPHORE=5,VK_OBJECT_TYPE_COMMAND_BUFFER=6,VK_OBJECT_TYPE_FENCE=7,VK_OBJECT_TYPE_DEVICE_MEMORY=8,VK_OBJECT_TYPE_BUFFER=9,VK_OBJECT_TYPE_IMAGE=10,VK_OBJECT_TYPE_EVENT=11,VK_OBJECT_TYPE_QUERY_POOL=12,VK_OBJECT_TYPE_BUFFER_VIEW=13,VK_OBJECT_TYPE_IMAGE_VIEW=14,VK_OBJECT_TYPE_SHADER_MODULE=15,VK_OBJECT_TYPE_PIPELINE_CACHE=16,VK_OBJECT_TYPE_PIPELINE_LAYOUT=17,VK_OBJECT_TYPE_RENDER_PASS=18,VK_OBJECT_TYPE_PIPELINE=19,VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT=20,VK_OBJECT_TYPE_SAMPLER=21,VK_OBJECT_TYPE_DESCRIPTOR_POOL=22,VK_OBJECT_TYPE_DESCRIPTOR_SET=23,VK_OBJECT_TYPE_FRAMEBUFFER=24,VK_OBJECT_TYPE_COMMAND_POOL=25,VK_OBJECT_TYPE_SURFACE_KHR=1000000000,VK_OBJECT_TYPE_SWAPCHAIN_KHR=1000001000,VK_OBJECT_TYPE_DISPLAY_KHR=1000002000,VK_OBJECT_TYPE_DISPLAY_MODE_KHR=1000002001,VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT=1000011000,VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR=1000085000,VK_OBJECT_TYPE_OBJECT_TABLE_NVX=1000086000,VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX=1000086001,VK_OBJECT_TYPE_BEGIN_RANGE=0,VK_OBJECT_TYPE_END_RANGE=25,VK_OBJECT_TYPE_RANGE_SIZE=26,VK_OBJECT_TYPE_MAX_ENUM=2147483647};
typedef enum VkImageLayout{VK_IMAGE_LAYOUT_UNDEFINED=0,VK_IMAGE_LAYOUT_GENERAL=1,VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL=2,VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL=3,VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL=4,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL=5,VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL=6,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL=7,VK_IMAGE_LAYOUT_PREINITIALIZED=8,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR=1000001002,VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR=1000111000,VK_IMAGE_LAYOUT_BEGIN_RANGE=0,VK_IMAGE_LAYOUT_END_RANGE=8,VK_IMAGE_LAYOUT_RANGE_SIZE=9,VK_IMAGE_LAYOUT_MAX_ENUM=2147483647};
typedef enum VkSamplerMipmapMode{VK_SAMPLER_MIPMAP_MODE_NEAREST=0,VK_SAMPLER_MIPMAP_MODE_LINEAR=1,VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE=0,VK_SAMPLER_MIPMAP_MODE_END_RANGE=1,VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE=2,VK_SAMPLER_MIPMAP_MODE_MAX_ENUM=2147483647};
typedef enum VkIndexType{VK_INDEX_TYPE_UINT16=0,VK_INDEX_TYPE_UINT32=1,VK_INDEX_TYPE_BEGIN_RANGE=0,VK_INDEX_TYPE_END_RANGE=1,VK_INDEX_TYPE_RANGE_SIZE=2,VK_INDEX_TYPE_MAX_ENUM=2147483647};
typedef enum VkCullModeFlagBits{VK_CULL_MODE_NONE=0,VK_CULL_MODE_FRONT_BIT=1,VK_CULL_MODE_BACK_BIT=2,VK_CULL_MODE_FRONT_AND_BACK=3,VK_CULL_MODE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkObjectEntryTypeNVX{VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX=0,VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX=1,VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX=2,VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX=3,VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX=4,VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX=0,VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX=4,VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX=5,VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX=2147483647};
typedef enum VkPipelineStageFlagBits{VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT=1,VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT=2,VK_PIPELINE_STAGE_VERTEX_INPUT_BIT=4,VK_PIPELINE_STAGE_VERTEX_SHADER_BIT=8,VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT=16,VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT=32,VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT=64,VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT=128,VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT=256,VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT=512,VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT=1024,VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT=2048,VK_PIPELINE_STAGE_TRANSFER_BIT=4096,VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT=8192,VK_PIPELINE_STAGE_HOST_BIT=16384,VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT=32768,VK_PIPELINE_STAGE_ALL_COMMANDS_BIT=65536,VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX=131072,VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageUsageFlagBits{VK_IMAGE_USAGE_TRANSFER_SRC_BIT=1,VK_IMAGE_USAGE_TRANSFER_DST_BIT=2,VK_IMAGE_USAGE_SAMPLED_BIT=4,VK_IMAGE_USAGE_STORAGE_BIT=8,VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT=16,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT=32,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT=64,VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT=128,VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolCreateFlagBits{VK_COMMAND_POOL_CREATE_TRANSIENT_BIT=1,VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT=2,VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDependencyFlagBits{VK_DEPENDENCY_BY_REGION_BIT=1,VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX=2,VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX=4,VK_DEPENDENCY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSystemAllocationScope{VK_SYSTEM_ALLOCATION_SCOPE_COMMAND=0,VK_SYSTEM_ALLOCATION_SCOPE_OBJECT=1,VK_SYSTEM_ALLOCATION_SCOPE_CACHE=2,VK_SYSTEM_ALLOCATION_SCOPE_DEVICE=3,VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE=4,VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE=0,VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE=4,VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE=5,VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM=2147483647};
typedef enum VkSurfaceCounterFlagBitsEXT{VK_SURFACE_COUNTER_VBLANK_EXT=1,VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkFilter{VK_FILTER_NEAREST=0,VK_FILTER_LINEAR=1,VK_FILTER_CUBIC_IMG=1000015000,VK_FILTER_BEGIN_RANGE=0,VK_FILTER_END_RANGE=1,VK_FILTER_RANGE_SIZE=2,VK_FILTER_MAX_ENUM=2147483647};
typedef enum VkBufferUsageFlagBits{VK_BUFFER_USAGE_TRANSFER_SRC_BIT=1,VK_BUFFER_USAGE_TRANSFER_DST_BIT=2,VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT=4,VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT=8,VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT=16,VK_BUFFER_USAGE_STORAGE_BUFFER_BIT=32,VK_BUFFER_USAGE_INDEX_BUFFER_BIT=64,VK_BUFFER_USAGE_VERTEX_BUFFER_BIT=128,VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT=256,VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkIndirectCommandsTokenTypeNVX{VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX=0,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX=1,VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX=2,VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX=3,VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX=4,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX=5,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX=6,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX=7,VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX=0,VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX=7,VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX=8,VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX=2147483647};
typedef enum VkDisplayPlaneAlphaFlagBitsKHR{VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR=1,VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR=2,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR=4,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR=8,VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkPipelineCreateFlagBits{VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT=1,VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT=2,VK_PIPELINE_CREATE_DERIVATIVE_BIT=4,VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX=8,VK_PIPELINE_CREATE_DISPATCH_BASE_KHX=16,VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCoverageModulationModeNV{VK_COVERAGE_MODULATION_MODE_NONE_NV=0,VK_COVERAGE_MODULATION_MODE_RGB_NV=1,VK_COVERAGE_MODULATION_MODE_ALPHA_NV=2,VK_COVERAGE_MODULATION_MODE_RGBA_NV=3,VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV=0,VK_COVERAGE_MODULATION_MODE_END_RANGE_NV=3,VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV=4,VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV=2147483647};
typedef enum VkDebugReportObjectTypeEXT{VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT=1,VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT=2,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT=3,VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT=4,VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT=5,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT=6,VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT=7,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT=8,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT=9,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT=10,VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT=11,VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT=12,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT=13,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT=14,VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT=15,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT=16,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT=17,VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT=18,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT=19,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT=20,VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT=21,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT=22,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT=23,VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT=24,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT=25,VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT=26,VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT=27,VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT=28,VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT=29,VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT=30,VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT=31,VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT=32,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT=1000085000,VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT=32,VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT=33,VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkImageViewType{VK_IMAGE_VIEW_TYPE_1D=0,VK_IMAGE_VIEW_TYPE_2D=1,VK_IMAGE_VIEW_TYPE_3D=2,VK_IMAGE_VIEW_TYPE_CUBE=3,VK_IMAGE_VIEW_TYPE_1D_ARRAY=4,VK_IMAGE_VIEW_TYPE_2D_ARRAY=5,VK_IMAGE_VIEW_TYPE_CUBE_ARRAY=6,VK_IMAGE_VIEW_TYPE_BEGIN_RANGE=0,VK_IMAGE_VIEW_TYPE_END_RANGE=6,VK_IMAGE_VIEW_TYPE_RANGE_SIZE=7,VK_IMAGE_VIEW_TYPE_MAX_ENUM=2147483647};
typedef enum VkQueryControlFlagBits{VK_QUERY_CONTROL_PRECISE_BIT=1,VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkAttachmentDescriptionFlagBits{VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT=1,VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPipelineCacheHeaderVersion{VK_PIPELINE_CACHE_HEADER_VERSION_ONE=1,VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE=1,VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM=2147483647};
typedef enum VkDebugReportFlagBitsEXT{VK_DEBUG_REPORT_INFORMATION_BIT_EXT=1,VK_DEBUG_REPORT_WARNING_BIT_EXT=2,VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT=4,VK_DEBUG_REPORT_ERROR_BIT_EXT=8,VK_DEBUG_REPORT_DEBUG_BIT_EXT=16,VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkPrimitiveTopology{VK_PRIMITIVE_TOPOLOGY_POINT_LIST=0,VK_PRIMITIVE_TOPOLOGY_LINE_LIST=1,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP=2,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST=3,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP=4,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN=5,VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY=6,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY=7,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY=8,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY=9,VK_PRIMITIVE_TOPOLOGY_PATCH_LIST=10,VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE=0,VK_PRIMITIVE_TOPOLOGY_END_RANGE=10,VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE=11,VK_PRIMITIVE_TOPOLOGY_MAX_ENUM=2147483647};
typedef enum VkDescriptorSetLayoutCreateFlagBits{VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR=1,VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDisplayPowerStateEXT{VK_DISPLAY_POWER_STATE_OFF_EXT=0,VK_DISPLAY_POWER_STATE_SUSPEND_EXT=1,VK_DISPLAY_POWER_STATE_ON_EXT=2,VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT=0,VK_DISPLAY_POWER_STATE_END_RANGE_EXT=2,VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT=3,VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT=2147483647};
typedef enum VkExternalMemoryFeatureFlagBitsKHR{VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR=4,VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkSurfaceTransformFlagBitsKHR{VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR=1,VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR=2,VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR=4,VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR=8,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR=16,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR=32,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR=64,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR=128,VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR=256,VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkFenceImportFlagBitsKHR{VK_FENCE_IMPORT_TEMPORARY_BIT_KHR=1,VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkCompareOp{VK_COMPARE_OP_NEVER=0,VK_COMPARE_OP_LESS=1,VK_COMPARE_OP_EQUAL=2,VK_COMPARE_OP_LESS_OR_EQUAL=3,VK_COMPARE_OP_GREATER=4,VK_COMPARE_OP_NOT_EQUAL=5,VK_COMPARE_OP_GREATER_OR_EQUAL=6,VK_COMPARE_OP_ALWAYS=7,VK_COMPARE_OP_BEGIN_RANGE=0,VK_COMPARE_OP_END_RANGE=7,VK_COMPARE_OP_RANGE_SIZE=8,VK_COMPARE_OP_MAX_ENUM=2147483647};
typedef enum VkShaderStageFlagBits{VK_SHADER_STAGE_VERTEX_BIT=1,VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT=2,VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT=4,VK_SHADER_STAGE_GEOMETRY_BIT=8,VK_SHADER_STAGE_FRAGMENT_BIT=16,VK_SHADER_STAGE_COMPUTE_BIT=32,VK_SHADER_STAGE_ALL_GRAPHICS=31,VK_SHADER_STAGE_ALL=2147483647,VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkResult{VK_SUCCESS=0,VK_NOT_READY=1,VK_TIMEOUT=2,VK_EVENT_SET=3,VK_EVENT_RESET=4,VK_INCOMPLETE=5,VK_ERROR_OUT_OF_HOST_MEMORY=-1,VK_ERROR_OUT_OF_DEVICE_MEMORY=-2,VK_ERROR_INITIALIZATION_FAILED=-3,VK_ERROR_DEVICE_LOST=-4,VK_ERROR_MEMORY_MAP_FAILED=-5,VK_ERROR_LAYER_NOT_PRESENT=-6,VK_ERROR_EXTENSION_NOT_PRESENT=-7,VK_ERROR_FEATURE_NOT_PRESENT=-8,VK_ERROR_INCOMPATIBLE_DRIVER=-9,VK_ERROR_TOO_MANY_OBJECTS=-10,VK_ERROR_FORMAT_NOT_SUPPORTED=-11,VK_ERROR_FRAGMENTED_POOL=-12,VK_ERROR_SURFACE_LOST_KHR=-1000000000,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR=-1000000001,VK_SUBOPTIMAL_KHR=1000001003,VK_ERROR_OUT_OF_DATE_KHR=-1000001004,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR=-1000003001,VK_ERROR_VALIDATION_FAILED_EXT=-1000011001,VK_ERROR_INVALID_SHADER_NV=-1000012000,VK_ERROR_OUT_OF_POOL_MEMORY_KHR=-1000069000,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR=-1000072003,VK_RESULT_BEGIN_RANGE=-12,VK_RESULT_END_RANGE=5,VK_RESULT_RANGE_SIZE=18,VK_RESULT_MAX_ENUM=2147483647};
typedef enum VkSwapchainCreateFlagBitsKHR{VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX=1,VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkFenceCreateFlagBits{VK_FENCE_CREATE_SIGNALED_BIT=1,VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageCreateFlagBits{VK_IMAGE_CREATE_SPARSE_BINDING_BIT=1,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT=2,VK_IMAGE_CREATE_SPARSE_ALIASED_BIT=4,VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT=8,VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT=16,VK_IMAGE_CREATE_BIND_SFR_BIT_KHX=64,VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR=32,VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSampleCountFlagBits{VK_SAMPLE_COUNT_1_BIT=1,VK_SAMPLE_COUNT_2_BIT=2,VK_SAMPLE_COUNT_4_BIT=4,VK_SAMPLE_COUNT_8_BIT=8,VK_SAMPLE_COUNT_16_BIT=16,VK_SAMPLE_COUNT_32_BIT=32,VK_SAMPLE_COUNT_64_BIT=64,VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkQueryResultFlagBits{VK_QUERY_RESULT_64_BIT=1,VK_QUERY_RESULT_WAIT_BIT=2,VK_QUERY_RESULT_WITH_AVAILABILITY_BIT=4,VK_QUERY_RESULT_PARTIAL_BIT=8,VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPresentModeKHR{VK_PRESENT_MODE_IMMEDIATE_KHR=0,VK_PRESENT_MODE_MAILBOX_KHR=1,VK_PRESENT_MODE_FIFO_KHR=2,VK_PRESENT_MODE_FIFO_RELAXED_KHR=3,VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR=1000111000,VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR=1000111001,VK_PRESENT_MODE_BEGIN_RANGE_KHR=0,VK_PRESENT_MODE_END_RANGE_KHR=3,VK_PRESENT_MODE_RANGE_SIZE_KHR=4,VK_PRESENT_MODE_MAX_ENUM_KHR=2147483647};
typedef enum VkExternalMemoryHandleTypeFlagBitsKHR{VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR=16,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR=32,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR=64,VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkAccessFlagBits{VK_ACCESS_INDIRECT_COMMAND_READ_BIT=1,VK_ACCESS_INDEX_READ_BIT=2,VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT=4,VK_ACCESS_UNIFORM_READ_BIT=8,VK_ACCESS_INPUT_ATTACHMENT_READ_BIT=16,VK_ACCESS_SHADER_READ_BIT=32,VK_ACCESS_SHADER_WRITE_BIT=64,VK_ACCESS_COLOR_ATTACHMENT_READ_BIT=128,VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT=256,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT=512,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT=1024,VK_ACCESS_TRANSFER_READ_BIT=2048,VK_ACCESS_TRANSFER_WRITE_BIT=4096,VK_ACCESS_HOST_READ_BIT=8192,VK_ACCESS_HOST_WRITE_BIT=16384,VK_ACCESS_MEMORY_READ_BIT=32768,VK_ACCESS_MEMORY_WRITE_BIT=65536,VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX=131072,VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX=262144,VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT=524288,VK_ACCESS_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryFeatureFlagBitsNV{VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV=4,VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkDescriptorPoolCreateFlagBits{VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT=1,VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkFormatFeatureFlagBits{VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT=1,VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT=2,VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT=4,VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT=8,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT=16,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT=32,VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT=64,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT=128,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT=256,VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT=512,VK_FORMAT_FEATURE_BLIT_SRC_BIT=1024,VK_FORMAT_FEATURE_BLIT_DST_BIT=2048,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT=4096,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG=8192,VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR=16384,VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR=32768,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT=65536,VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSubpassDescriptionFlagBits{VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX=1,VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX=2,VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolResetFlagBits{VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkMemoryHeapFlagBits{VK_MEMORY_HEAP_DEVICE_LOCAL_BIT=1,VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX=2,VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkObjectEntryUsageFlagBitsNVX{VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX=1,VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX=2,VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX=2147483647};
typedef enum VkViewportCoordinateSwizzleNV{VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV=0,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV=1,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV=2,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV=3,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV=4,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV=5,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV=6,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV=7,VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV=0,VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV=7,VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV=8,VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV=2147483647};
typedef enum VkBufferCreateFlagBits{VK_BUFFER_CREATE_SPARSE_BINDING_BIT=1,VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT=2,VK_BUFFER_CREATE_SPARSE_ALIASED_BIT=4,VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDisplayEventTypeEXT{VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT=0,VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT=0,VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT=0,VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT=1,VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkStructureType{VK_STRUCTURE_TYPE_APPLICATION_INFO=0,VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO=1,VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO=2,VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO=3,VK_STRUCTURE_TYPE_SUBMIT_INFO=4,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO=5,VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE=6,VK_STRUCTURE_TYPE_BIND_SPARSE_INFO=7,VK_STRUCTURE_TYPE_FENCE_CREATE_INFO=8,VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO=9,VK_STRUCTURE_TYPE_EVENT_CREATE_INFO=10,VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO=11,VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO=12,VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO=13,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO=14,VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO=15,VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO=16,VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO=17,VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO=18,VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO=19,VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO=20,VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO=21,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO=22,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO=23,VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO=24,VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO=25,VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO=26,VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO=27,VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO=28,VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO=29,VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO=30,VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO=31,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO=32,VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO=33,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO=34,VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET=35,VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET=36,VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO=37,VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO=38,VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO=39,VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO=40,VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO=41,VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO=42,VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO=43,VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER=44,VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER=45,VK_STRUCTURE_TYPE_MEMORY_BARRIER=46,VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO=47,VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO=48,VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR=1000001000,VK_STRUCTURE_TYPE_PRESENT_INFO_KHR=1000001001,VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR=1000002000,VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR=1000002001,VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR=1000003000,VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR=1000004000,VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR=1000005000,VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR=1000006000,VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR=1000007000,VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR=1000008000,VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR=1000009000,VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT=1000011000,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD=1000018000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT=1000022000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT=1000022001,VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT=1000022002,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV=1000026000,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV=1000026001,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV=1000026002,VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD=1000041000,VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX=1000053000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX=1000053001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX=1000053002,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV=1000056000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV=1000056001,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057001,VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV=1000058000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR=1000059000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR=1000059001,VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR=1000059002,VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR=1000059003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR=1000059004,VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR=1000059005,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR=1000059006,VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR=1000059007,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR=1000059008,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX=1000060000,VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX=1000060001,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX=1000060002,VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX=1000060003,VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX=1000060004,VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX=1000060005,VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX=1000060006,VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX=1000060007,VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX=1000060008,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX=1000060009,VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX=1000060010,VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX=1000060011,VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX=1000060012,VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT=1000061000,VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN=1000062000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX=1000070000,VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX=1000070001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR=1000071000,VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR=1000071001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR=1000071002,VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR=1000071003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR=1000071004,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR=1000072000,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR=1000072001,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR=1000072002,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR=1000073000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR=1000073001,VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR=1000073002,VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR=1000073003,VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR=1000074000,VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR=1000074001,VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR=1000074002,VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR=1000075000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR=1000076000,VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR=1000076001,VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR=1000077000,VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR=1000078000,VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR=1000078001,VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR=1000078002,VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR=1000078003,VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR=1000079000,VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR=1000079001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR=1000080000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR=1000083000,VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR=1000084000,VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR=1000085000,VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX=1000086000,VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX=1000086001,VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX=1000086002,VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX=1000086003,VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX=1000086004,VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX=1000086005,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV=1000087000,VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT=1000090000,VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT=1000091000,VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT=1000091001,VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT=1000091002,VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT=1000091003,VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE=1000092000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX=1000097000,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV=1000098000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT=1000099000,VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT=1000099001,VK_STRUCTURE_TYPE_HDR_METADATA_EXT=1000105000,VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR=1000111000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR=1000112000,VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR=1000112001,VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR=1000113000,VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR=1000114000,VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR=1000114001,VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR=1000114002,VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR=1000115000,VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR=1000115001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR=1000119000,VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR=1000119001,VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR=1000119002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR=1000120000,VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK=1000122000,VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK=1000123000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR=1000127000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR=1000127001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT=1000130000,VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT=1000130001,VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146000,VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146001,VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146002,VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR=1000146003,VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR=1000146004,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT=1000148000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT=1000148001,VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT=1000148002,VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV=1000149000,VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV=1000152000,VK_STRUCTURE_TYPE_BEGIN_RANGE=0,VK_STRUCTURE_TYPE_END_RANGE=48,VK_STRUCTURE_TYPE_RANGE_SIZE=49,VK_STRUCTURE_TYPE_MAX_ENUM=2147483647};
typedef enum VkIndirectCommandsLayoutUsageFlagBitsNVX{VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX=1,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX=2,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX=4,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX=8,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX=2147483647};
typedef enum VkVertexInputRate{VK_VERTEX_INPUT_RATE_VERTEX=0,VK_VERTEX_INPUT_RATE_INSTANCE=1,VK_VERTEX_INPUT_RATE_BEGIN_RANGE=0,VK_VERTEX_INPUT_RATE_END_RANGE=1,VK_VERTEX_INPUT_RATE_RANGE_SIZE=2,VK_VERTEX_INPUT_RATE_MAX_ENUM=2147483647};
typedef enum VkCompositeAlphaFlagBitsKHR{VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR=1,VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR=2,VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR=4,VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR=8,VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkColorSpaceKHR{VK_COLOR_SPACE_SRGB_NONLINEAR_KHR=0,VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT=1000104001,VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT=1000104002,VK_COLOR_SPACE_DCI_P3_LINEAR_EXT=1000104003,VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT=1000104004,VK_COLOR_SPACE_BT709_LINEAR_EXT=1000104005,VK_COLOR_SPACE_BT709_NONLINEAR_EXT=1000104006,VK_COLOR_SPACE_BT2020_LINEAR_EXT=1000104007,VK_COLOR_SPACE_HDR10_ST2084_EXT=1000104008,VK_COLOR_SPACE_DOLBYVISION_EXT=1000104009,VK_COLOR_SPACE_HDR10_HLG_EXT=1000104010,VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT=1000104011,VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT=1000104012,VK_COLOR_SPACE_PASS_THROUGH_EXT=1000104013,VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT=1000104014,VK_COLOR_SPACE_BEGIN_RANGE_KHR=0,VK_COLOR_SPACE_END_RANGE_KHR=0,VK_COLOR_SPACE_RANGE_SIZE_KHR=1,VK_COLOR_SPACE_MAX_ENUM_KHR=2147483647};
typedef enum VkMemoryAllocateFlagBitsKHX{VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX=1,VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX=2147483647};
typedef enum VkDeviceGroupPresentModeFlagBitsKHX{VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX=1,VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX=2,VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX=4,VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX=8,VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX=2147483647};
typedef enum VkImageTiling{VK_IMAGE_TILING_OPTIMAL=0,VK_IMAGE_TILING_LINEAR=1,VK_IMAGE_TILING_BEGIN_RANGE=0,VK_IMAGE_TILING_END_RANGE=1,VK_IMAGE_TILING_RANGE_SIZE=2,VK_IMAGE_TILING_MAX_ENUM=2147483647};
typedef enum VkQueryType{VK_QUERY_TYPE_OCCLUSION=0,VK_QUERY_TYPE_PIPELINE_STATISTICS=1,VK_QUERY_TYPE_TIMESTAMP=2,VK_QUERY_TYPE_BEGIN_RANGE=0,VK_QUERY_TYPE_END_RANGE=2,VK_QUERY_TYPE_RANGE_SIZE=3,VK_QUERY_TYPE_MAX_ENUM=2147483647};
typedef enum VkFormat{VK_FORMAT_UNDEFINED=0,VK_FORMAT_R4G4_UNORM_PACK8=1,VK_FORMAT_R4G4B4A4_UNORM_PACK16=2,VK_FORMAT_B4G4R4A4_UNORM_PACK16=3,VK_FORMAT_R5G6B5_UNORM_PACK16=4,VK_FORMAT_B5G6R5_UNORM_PACK16=5,VK_FORMAT_R5G5B5A1_UNORM_PACK16=6,VK_FORMAT_B5G5R5A1_UNORM_PACK16=7,VK_FORMAT_A1R5G5B5_UNORM_PACK16=8,VK_FORMAT_R8_UNORM=9,VK_FORMAT_R8_SNORM=10,VK_FORMAT_R8_USCALED=11,VK_FORMAT_R8_SSCALED=12,VK_FORMAT_R8_UINT=13,VK_FORMAT_R8_SINT=14,VK_FORMAT_R8_SRGB=15,VK_FORMAT_R8G8_UNORM=16,VK_FORMAT_R8G8_SNORM=17,VK_FORMAT_R8G8_USCALED=18,VK_FORMAT_R8G8_SSCALED=19,VK_FORMAT_R8G8_UINT=20,VK_FORMAT_R8G8_SINT=21,VK_FORMAT_R8G8_SRGB=22,VK_FORMAT_R8G8B8_UNORM=23,VK_FORMAT_R8G8B8_SNORM=24,VK_FORMAT_R8G8B8_USCALED=25,VK_FORMAT_R8G8B8_SSCALED=26,VK_FORMAT_R8G8B8_UINT=27,VK_FORMAT_R8G8B8_SINT=28,VK_FORMAT_R8G8B8_SRGB=29,VK_FORMAT_B8G8R8_UNORM=30,VK_FORMAT_B8G8R8_SNORM=31,VK_FORMAT_B8G8R8_USCALED=32,VK_FORMAT_B8G8R8_SSCALED=33,VK_FORMAT_B8G8R8_UINT=34,VK_FORMAT_B8G8R8_SINT=35,VK_FORMAT_B8G8R8_SRGB=36,VK_FORMAT_R8G8B8A8_UNORM=37,VK_FORMAT_R8G8B8A8_SNORM=38,VK_FORMAT_R8G8B8A8_USCALED=39,VK_FORMAT_R8G8B8A8_SSCALED=40,VK_FORMAT_R8G8B8A8_UINT=41,VK_FORMAT_R8G8B8A8_SINT=42,VK_FORMAT_R8G8B8A8_SRGB=43,VK_FORMAT_B8G8R8A8_UNORM=44,VK_FORMAT_B8G8R8A8_SNORM=45,VK_FORMAT_B8G8R8A8_USCALED=46,VK_FORMAT_B8G8R8A8_SSCALED=47,VK_FORMAT_B8G8R8A8_UINT=48,VK_FORMAT_B8G8R8A8_SINT=49,VK_FORMAT_B8G8R8A8_SRGB=50,VK_FORMAT_A8B8G8R8_UNORM_PACK32=51,VK_FORMAT_A8B8G8R8_SNORM_PACK32=52,VK_FORMAT_A8B8G8R8_USCALED_PACK32=53,VK_FORMAT_A8B8G8R8_SSCALED_PACK32=54,VK_FORMAT_A8B8G8R8_UINT_PACK32=55,VK_FORMAT_A8B8G8R8_SINT_PACK32=56,VK_FORMAT_A8B8G8R8_SRGB_PACK32=57,VK_FORMAT_A2R10G10B10_UNORM_PACK32=58,VK_FORMAT_A2R10G10B10_SNORM_PACK32=59,VK_FORMAT_A2R10G10B10_USCALED_PACK32=60,VK_FORMAT_A2R10G10B10_SSCALED_PACK32=61,VK_FORMAT_A2R10G10B10_UINT_PACK32=62,VK_FORMAT_A2R10G10B10_SINT_PACK32=63,VK_FORMAT_A2B10G10R10_UNORM_PACK32=64,VK_FORMAT_A2B10G10R10_SNORM_PACK32=65,VK_FORMAT_A2B10G10R10_USCALED_PACK32=66,VK_FORMAT_A2B10G10R10_SSCALED_PACK32=67,VK_FORMAT_A2B10G10R10_UINT_PACK32=68,VK_FORMAT_A2B10G10R10_SINT_PACK32=69,VK_FORMAT_R16_UNORM=70,VK_FORMAT_R16_SNORM=71,VK_FORMAT_R16_USCALED=72,VK_FORMAT_R16_SSCALED=73,VK_FORMAT_R16_UINT=74,VK_FORMAT_R16_SINT=75,VK_FORMAT_R16_SFLOAT=76,VK_FORMAT_R16G16_UNORM=77,VK_FORMAT_R16G16_SNORM=78,VK_FORMAT_R16G16_USCALED=79,VK_FORMAT_R16G16_SSCALED=80,VK_FORMAT_R16G16_UINT=81,VK_FORMAT_R16G16_SINT=82,VK_FORMAT_R16G16_SFLOAT=83,VK_FORMAT_R16G16B16_UNORM=84,VK_FORMAT_R16G16B16_SNORM=85,VK_FORMAT_R16G16B16_USCALED=86,VK_FORMAT_R16G16B16_SSCALED=87,VK_FORMAT_R16G16B16_UINT=88,VK_FORMAT_R16G16B16_SINT=89,VK_FORMAT_R16G16B16_SFLOAT=90,VK_FORMAT_R16G16B16A16_UNORM=91,VK_FORMAT_R16G16B16A16_SNORM=92,VK_FORMAT_R16G16B16A16_USCALED=93,VK_FORMAT_R16G16B16A16_SSCALED=94,VK_FORMAT_R16G16B16A16_UINT=95,VK_FORMAT_R16G16B16A16_SINT=96,VK_FORMAT_R16G16B16A16_SFLOAT=97,VK_FORMAT_R32_UINT=98,VK_FORMAT_R32_SINT=99,VK_FORMAT_R32_SFLOAT=100,VK_FORMAT_R32G32_UINT=101,VK_FORMAT_R32G32_SINT=102,VK_FORMAT_R32G32_SFLOAT=103,VK_FORMAT_R32G32B32_UINT=104,VK_FORMAT_R32G32B32_SINT=105,VK_FORMAT_R32G32B32_SFLOAT=106,VK_FORMAT_R32G32B32A32_UINT=107,VK_FORMAT_R32G32B32A32_SINT=108,VK_FORMAT_R32G32B32A32_SFLOAT=109,VK_FORMAT_R64_UINT=110,VK_FORMAT_R64_SINT=111,VK_FORMAT_R64_SFLOAT=112,VK_FORMAT_R64G64_UINT=113,VK_FORMAT_R64G64_SINT=114,VK_FORMAT_R64G64_SFLOAT=115,VK_FORMAT_R64G64B64_UINT=116,VK_FORMAT_R64G64B64_SINT=117,VK_FORMAT_R64G64B64_SFLOAT=118,VK_FORMAT_R64G64B64A64_UINT=119,VK_FORMAT_R64G64B64A64_SINT=120,VK_FORMAT_R64G64B64A64_SFLOAT=121,VK_FORMAT_B10G11R11_UFLOAT_PACK32=122,VK_FORMAT_E5B9G9R9_UFLOAT_PACK32=123,VK_FORMAT_D16_UNORM=124,VK_FORMAT_X8_D24_UNORM_PACK32=125,VK_FORMAT_D32_SFLOAT=126,VK_FORMAT_S8_UINT=127,VK_FORMAT_D16_UNORM_S8_UINT=128,VK_FORMAT_D24_UNORM_S8_UINT=129,VK_FORMAT_D32_SFLOAT_S8_UINT=130,VK_FORMAT_BC1_RGB_UNORM_BLOCK=131,VK_FORMAT_BC1_RGB_SRGB_BLOCK=132,VK_FORMAT_BC1_RGBA_UNORM_BLOCK=133,VK_FORMAT_BC1_RGBA_SRGB_BLOCK=134,VK_FORMAT_BC2_UNORM_BLOCK=135,VK_FORMAT_BC2_SRGB_BLOCK=136,VK_FORMAT_BC3_UNORM_BLOCK=137,VK_FORMAT_BC3_SRGB_BLOCK=138,VK_FORMAT_BC4_UNORM_BLOCK=139,VK_FORMAT_BC4_SNORM_BLOCK=140,VK_FORMAT_BC5_UNORM_BLOCK=141,VK_FORMAT_BC5_SNORM_BLOCK=142,VK_FORMAT_BC6H_UFLOAT_BLOCK=143,VK_FORMAT_BC6H_SFLOAT_BLOCK=144,VK_FORMAT_BC7_UNORM_BLOCK=145,VK_FORMAT_BC7_SRGB_BLOCK=146,VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK=147,VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK=148,VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK=149,VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK=150,VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK=151,VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK=152,VK_FORMAT_EAC_R11_UNORM_BLOCK=153,VK_FORMAT_EAC_R11_SNORM_BLOCK=154,VK_FORMAT_EAC_R11G11_UNORM_BLOCK=155,VK_FORMAT_EAC_R11G11_SNORM_BLOCK=156,VK_FORMAT_ASTC_4x4_UNORM_BLOCK=157,VK_FORMAT_ASTC_4x4_SRGB_BLOCK=158,VK_FORMAT_ASTC_5x4_UNORM_BLOCK=159,VK_FORMAT_ASTC_5x4_SRGB_BLOCK=160,VK_FORMAT_ASTC_5x5_UNORM_BLOCK=161,VK_FORMAT_ASTC_5x5_SRGB_BLOCK=162,VK_FORMAT_ASTC_6x5_UNORM_BLOCK=163,VK_FORMAT_ASTC_6x5_SRGB_BLOCK=164,VK_FORMAT_ASTC_6x6_UNORM_BLOCK=165,VK_FORMAT_ASTC_6x6_SRGB_BLOCK=166,VK_FORMAT_ASTC_8x5_UNORM_BLOCK=167,VK_FORMAT_ASTC_8x5_SRGB_BLOCK=168,VK_FORMAT_ASTC_8x6_UNORM_BLOCK=169,VK_FORMAT_ASTC_8x6_SRGB_BLOCK=170,VK_FORMAT_ASTC_8x8_UNORM_BLOCK=171,VK_FORMAT_ASTC_8x8_SRGB_BLOCK=172,VK_FORMAT_ASTC_10x5_UNORM_BLOCK=173,VK_FORMAT_ASTC_10x5_SRGB_BLOCK=174,VK_FORMAT_ASTC_10x6_UNORM_BLOCK=175,VK_FORMAT_ASTC_10x6_SRGB_BLOCK=176,VK_FORMAT_ASTC_10x8_UNORM_BLOCK=177,VK_FORMAT_ASTC_10x8_SRGB_BLOCK=178,VK_FORMAT_ASTC_10x10_UNORM_BLOCK=179,VK_FORMAT_ASTC_10x10_SRGB_BLOCK=180,VK_FORMAT_ASTC_12x10_UNORM_BLOCK=181,VK_FORMAT_ASTC_12x10_SRGB_BLOCK=182,VK_FORMAT_ASTC_12x12_UNORM_BLOCK=183,VK_FORMAT_ASTC_12x12_SRGB_BLOCK=184,VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG=1000054000,VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG=1000054001,VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG=1000054002,VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG=1000054003,VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG=1000054004,VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG=1000054005,VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG=1000054006,VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG=1000054007,VK_FORMAT_BEGIN_RANGE=0,VK_FORMAT_END_RANGE=184,VK_FORMAT_RANGE_SIZE=185,VK_FORMAT_MAX_ENUM=2147483647};
typedef enum VkAttachmentStoreOp{VK_ATTACHMENT_STORE_OP_STORE=0,VK_ATTACHMENT_STORE_OP_DONT_CARE=1,VK_ATTACHMENT_STORE_OP_BEGIN_RANGE=0,VK_ATTACHMENT_STORE_OP_END_RANGE=1,VK_ATTACHMENT_STORE_OP_RANGE_SIZE=2,VK_ATTACHMENT_STORE_OP_MAX_ENUM=2147483647};
typedef enum VkLogicOp{VK_LOGIC_OP_CLEAR=0,VK_LOGIC_OP_AND=1,VK_LOGIC_OP_AND_REVERSE=2,VK_LOGIC_OP_COPY=3,VK_LOGIC_OP_AND_INVERTED=4,VK_LOGIC_OP_NO_OP=5,VK_LOGIC_OP_XOR=6,VK_LOGIC_OP_OR=7,VK_LOGIC_OP_NOR=8,VK_LOGIC_OP_EQUIVALENT=9,VK_LOGIC_OP_INVERT=10,VK_LOGIC_OP_OR_REVERSE=11,VK_LOGIC_OP_COPY_INVERTED=12,VK_LOGIC_OP_OR_INVERTED=13,VK_LOGIC_OP_NAND=14,VK_LOGIC_OP_SET=15,VK_LOGIC_OP_BEGIN_RANGE=0,VK_LOGIC_OP_END_RANGE=15,VK_LOGIC_OP_RANGE_SIZE=16,VK_LOGIC_OP_MAX_ENUM=2147483647};
typedef enum VkAttachmentLoadOp{VK_ATTACHMENT_LOAD_OP_LOAD=0,VK_ATTACHMENT_LOAD_OP_CLEAR=1,VK_ATTACHMENT_LOAD_OP_DONT_CARE=2,VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE=0,VK_ATTACHMENT_LOAD_OP_END_RANGE=2,VK_ATTACHMENT_LOAD_OP_RANGE_SIZE=3,VK_ATTACHMENT_LOAD_OP_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryHandleTypeFlagBitsNV{VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkRasterizationOrderAMD{VK_RASTERIZATION_ORDER_STRICT_AMD=0,VK_RASTERIZATION_ORDER_RELAXED_AMD=1,VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD=0,VK_RASTERIZATION_ORDER_END_RANGE_AMD=1,VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD=2,VK_RASTERIZATION_ORDER_MAX_ENUM_AMD=2147483647};
typedef enum VkImageAspectFlagBits{VK_IMAGE_ASPECT_COLOR_BIT=1,VK_IMAGE_ASPECT_DEPTH_BIT=2,VK_IMAGE_ASPECT_STENCIL_BIT=4,VK_IMAGE_ASPECT_METADATA_BIT=8,VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalFenceFeatureFlagBitsKHR{VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR=1,VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR=2,VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkExternalFenceHandleTypeFlagBitsKHR{VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR=8,VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkPolygonMode{VK_POLYGON_MODE_FILL=0,VK_POLYGON_MODE_LINE=1,VK_POLYGON_MODE_POINT=2,VK_POLYGON_MODE_FILL_RECTANGLE_NV=1000153000,VK_POLYGON_MODE_BEGIN_RANGE=0,VK_POLYGON_MODE_END_RANGE=2,VK_POLYGON_MODE_RANGE_SIZE=3,VK_POLYGON_MODE_MAX_ENUM=2147483647};
typedef enum VkExternalSemaphoreHandleTypeFlagBitsKHR{VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR=8,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR=16,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkImageType{VK_IMAGE_TYPE_1D=0,VK_IMAGE_TYPE_2D=1,VK_IMAGE_TYPE_3D=2,VK_IMAGE_TYPE_BEGIN_RANGE=0,VK_IMAGE_TYPE_END_RANGE=2,VK_IMAGE_TYPE_RANGE_SIZE=3,VK_IMAGE_TYPE_MAX_ENUM=2147483647};
typedef enum VkSparseImageFormatFlagBits{VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT=1,VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT=2,VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT=4,VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkBorderColor{VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK=0,VK_BORDER_COLOR_INT_TRANSPARENT_BLACK=1,VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK=2,VK_BORDER_COLOR_INT_OPAQUE_BLACK=3,VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE=4,VK_BORDER_COLOR_INT_OPAQUE_WHITE=5,VK_BORDER_COLOR_BEGIN_RANGE=0,VK_BORDER_COLOR_END_RANGE=5,VK_BORDER_COLOR_RANGE_SIZE=6,VK_BORDER_COLOR_MAX_ENUM=2147483647};
typedef enum VkDescriptorType{VK_DESCRIPTOR_TYPE_SAMPLER=0,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER=1,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE=2,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE=3,VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER=4,VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER=5,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER=6,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER=7,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC=8,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC=9,VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT=10,VK_DESCRIPTOR_TYPE_BEGIN_RANGE=0,VK_DESCRIPTOR_TYPE_END_RANGE=10,VK_DESCRIPTOR_TYPE_RANGE_SIZE=11,VK_DESCRIPTOR_TYPE_MAX_ENUM=2147483647};
typedef enum VkSemaphoreImportFlagBitsKHR{VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR=1,VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkInternalAllocationType{VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE=0,VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_END_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE=1,VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM=2147483647};
typedef enum VkStencilOp{VK_STENCIL_OP_KEEP=0,VK_STENCIL_OP_ZERO=1,VK_STENCIL_OP_REPLACE=2,VK_STENCIL_OP_INCREMENT_AND_CLAMP=3,VK_STENCIL_OP_DECREMENT_AND_CLAMP=4,VK_STENCIL_OP_INVERT=5,VK_STENCIL_OP_INCREMENT_AND_WRAP=6,VK_STENCIL_OP_DECREMENT_AND_WRAP=7,VK_STENCIL_OP_BEGIN_RANGE=0,VK_STENCIL_OP_END_RANGE=7,VK_STENCIL_OP_RANGE_SIZE=8,VK_STENCIL_OP_MAX_ENUM=2147483647};
typedef enum VkBlendOverlapEXT{VK_BLEND_OVERLAP_UNCORRELATED_EXT=0,VK_BLEND_OVERLAP_DISJOINT_EXT=1,VK_BLEND_OVERLAP_CONJOINT_EXT=2,VK_BLEND_OVERLAP_BEGIN_RANGE_EXT=0,VK_BLEND_OVERLAP_END_RANGE_EXT=2,VK_BLEND_OVERLAP_RANGE_SIZE_EXT=3,VK_BLEND_OVERLAP_MAX_ENUM_EXT=2147483647};
typedef enum VkValidationCheckEXT{VK_VALIDATION_CHECK_ALL_EXT=0,VK_VALIDATION_CHECK_SHADERS_EXT=1,VK_VALIDATION_CHECK_BEGIN_RANGE_EXT=0,VK_VALIDATION_CHECK_END_RANGE_EXT=1,VK_VALIDATION_CHECK_RANGE_SIZE_EXT=2,VK_VALIDATION_CHECK_MAX_ENUM_EXT=2147483647};
typedef enum VkDeviceEventTypeEXT{VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT=0,VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT=0,VK_DEVICE_EVENT_TYPE_END_RANGE_EXT=0,VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT=1,VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkQueryPipelineStatisticFlagBits{VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT=1,VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT=2,VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT=4,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT=8,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT=16,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT=32,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT=64,VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT=128,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT=256,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT=512,VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT=1024,VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandBufferResetFlagBits{VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkFrontFace{VK_FRONT_FACE_COUNTER_CLOCKWISE=0,VK_FRONT_FACE_CLOCKWISE=1,VK_FRONT_FACE_BEGIN_RANGE=0,VK_FRONT_FACE_END_RANGE=1,VK_FRONT_FACE_RANGE_SIZE=2,VK_FRONT_FACE_MAX_ENUM=2147483647};
typedef enum VkDescriptorUpdateTemplateTypeKHR{VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR=1,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR=1,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR=2,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR=2147483647};
typedef enum VkBlendOp{VK_BLEND_OP_ADD=0,VK_BLEND_OP_SUBTRACT=1,VK_BLEND_OP_REVERSE_SUBTRACT=2,VK_BLEND_OP_MIN=3,VK_BLEND_OP_MAX=4,VK_BLEND_OP_ZERO_EXT=1000148000,VK_BLEND_OP_SRC_EXT=1000148001,VK_BLEND_OP_DST_EXT=1000148002,VK_BLEND_OP_SRC_OVER_EXT=1000148003,VK_BLEND_OP_DST_OVER_EXT=1000148004,VK_BLEND_OP_SRC_IN_EXT=1000148005,VK_BLEND_OP_DST_IN_EXT=1000148006,VK_BLEND_OP_SRC_OUT_EXT=1000148007,VK_BLEND_OP_DST_OUT_EXT=1000148008,VK_BLEND_OP_SRC_ATOP_EXT=1000148009,VK_BLEND_OP_DST_ATOP_EXT=1000148010,VK_BLEND_OP_XOR_EXT=1000148011,VK_BLEND_OP_MULTIPLY_EXT=1000148012,VK_BLEND_OP_SCREEN_EXT=1000148013,VK_BLEND_OP_OVERLAY_EXT=1000148014,VK_BLEND_OP_DARKEN_EXT=1000148015,VK_BLEND_OP_LIGHTEN_EXT=1000148016,VK_BLEND_OP_COLORDODGE_EXT=1000148017,VK_BLEND_OP_COLORBURN_EXT=1000148018,VK_BLEND_OP_HARDLIGHT_EXT=1000148019,VK_BLEND_OP_SOFTLIGHT_EXT=1000148020,VK_BLEND_OP_DIFFERENCE_EXT=1000148021,VK_BLEND_OP_EXCLUSION_EXT=1000148022,VK_BLEND_OP_INVERT_EXT=1000148023,VK_BLEND_OP_INVERT_RGB_EXT=1000148024,VK_BLEND_OP_LINEARDODGE_EXT=1000148025,VK_BLEND_OP_LINEARBURN_EXT=1000148026,VK_BLEND_OP_VIVIDLIGHT_EXT=1000148027,VK_BLEND_OP_LINEARLIGHT_EXT=1000148028,VK_BLEND_OP_PINLIGHT_EXT=1000148029,VK_BLEND_OP_HARDMIX_EXT=1000148030,VK_BLEND_OP_HSL_HUE_EXT=1000148031,VK_BLEND_OP_HSL_SATURATION_EXT=1000148032,VK_BLEND_OP_HSL_COLOR_EXT=1000148033,VK_BLEND_OP_HSL_LUMINOSITY_EXT=1000148034,VK_BLEND_OP_PLUS_EXT=1000148035,VK_BLEND_OP_PLUS_CLAMPED_EXT=1000148036,VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT=1000148037,VK_BLEND_OP_PLUS_DARKER_EXT=1000148038,VK_BLEND_OP_MINUS_EXT=1000148039,VK_BLEND_OP_MINUS_CLAMPED_EXT=1000148040,VK_BLEND_OP_CONTRAST_EXT=1000148041,VK_BLEND_OP_INVERT_OVG_EXT=1000148042,VK_BLEND_OP_RED_EXT=1000148043,VK_BLEND_OP_GREEN_EXT=1000148044,VK_BLEND_OP_BLUE_EXT=1000148045,VK_BLEND_OP_BEGIN_RANGE=0,VK_BLEND_OP_END_RANGE=4,VK_BLEND_OP_RANGE_SIZE=5,VK_BLEND_OP_MAX_ENUM=2147483647};
typedef enum VkBlendFactor{VK_BLEND_FACTOR_ZERO=0,VK_BLEND_FACTOR_ONE=1,VK_BLEND_FACTOR_SRC_COLOR=2,VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR=3,VK_BLEND_FACTOR_DST_COLOR=4,VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR=5,VK_BLEND_FACTOR_SRC_ALPHA=6,VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA=7,VK_BLEND_FACTOR_DST_ALPHA=8,VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA=9,VK_BLEND_FACTOR_CONSTANT_COLOR=10,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR=11,VK_BLEND_FACTOR_CONSTANT_ALPHA=12,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA=13,VK_BLEND_FACTOR_SRC_ALPHA_SATURATE=14,VK_BLEND_FACTOR_SRC1_COLOR=15,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR=16,VK_BLEND_FACTOR_SRC1_ALPHA=17,VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA=18,VK_BLEND_FACTOR_BEGIN_RANGE=0,VK_BLEND_FACTOR_END_RANGE=18,VK_BLEND_FACTOR_RANGE_SIZE=19,VK_BLEND_FACTOR_MAX_ENUM=2147483647};
typedef enum VkPipelineBindPoint{VK_PIPELINE_BIND_POINT_GRAPHICS=0,VK_PIPELINE_BIND_POINT_COMPUTE=1,VK_PIPELINE_BIND_POINT_BEGIN_RANGE=0,VK_PIPELINE_BIND_POINT_END_RANGE=1,VK_PIPELINE_BIND_POINT_RANGE_SIZE=2,VK_PIPELINE_BIND_POINT_MAX_ENUM=2147483647};
typedef enum VkSharingMode{VK_SHARING_MODE_EXCLUSIVE=0,VK_SHARING_MODE_CONCURRENT=1,VK_SHARING_MODE_BEGIN_RANGE=0,VK_SHARING_MODE_END_RANGE=1,VK_SHARING_MODE_RANGE_SIZE=2,VK_SHARING_MODE_MAX_ENUM=2147483647};
typedef enum VkSamplerAddressMode{VK_SAMPLER_ADDRESS_MODE_REPEAT=0,VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT=1,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE=2,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER=3,VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE=4,VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE=0,VK_SAMPLER_ADDRESS_MODE_END_RANGE=3,VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE=4,VK_SAMPLER_ADDRESS_MODE_MAX_ENUM=2147483647};
typedef enum VkSparseMemoryBindFlagBits{VK_SPARSE_MEMORY_BIND_METADATA_BIT=1,VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPhysicalDeviceType{VK_PHYSICAL_DEVICE_TYPE_OTHER=0,VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU=1,VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU=2,VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU=3,VK_PHYSICAL_DEVICE_TYPE_CPU=4,VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE=0,VK_PHYSICAL_DEVICE_TYPE_END_RANGE=4,VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE=5,VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM=2147483647};
typedef enum VkPeerMemoryFeatureFlagBitsKHX{VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX=1,VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX=2,VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX=4,VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX=8,VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX=2147483647};
typedef enum VkMemoryPropertyFlagBits{VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT=1,VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT=2,VK_MEMORY_PROPERTY_HOST_COHERENT_BIT=4,VK_MEMORY_PROPERTY_HOST_CACHED_BIT=8,VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT=16,VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSubpassContents{VK_SUBPASS_CONTENTS_INLINE=0,VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS=1,VK_SUBPASS_CONTENTS_BEGIN_RANGE=0,VK_SUBPASS_CONTENTS_END_RANGE=1,VK_SUBPASS_CONTENTS_RANGE_SIZE=2,VK_SUBPASS_CONTENTS_MAX_ENUM=2147483647};
typedef enum VkQueueFlagBits{VK_QUEUE_GRAPHICS_BIT=1,VK_QUEUE_COMPUTE_BIT=2,VK_QUEUE_TRANSFER_BIT=4,VK_QUEUE_SPARSE_BINDING_BIT=8,VK_QUEUE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkColorComponentFlagBits{VK_COLOR_COMPONENT_R_BIT=1,VK_COLOR_COMPONENT_G_BIT=2,VK_COLOR_COMPONENT_B_BIT=4,VK_COLOR_COMPONENT_A_BIT=8,VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkComponentSwizzle{VK_COMPONENT_SWIZZLE_IDENTITY=0,VK_COMPONENT_SWIZZLE_ZERO=1,VK_COMPONENT_SWIZZLE_ONE=2,VK_COMPONENT_SWIZZLE_R=3,VK_COMPONENT_SWIZZLE_G=4,VK_COMPONENT_SWIZZLE_B=5,VK_COMPONENT_SWIZZLE_A=6,VK_COMPONENT_SWIZZLE_BEGIN_RANGE=0,VK_COMPONENT_SWIZZLE_END_RANGE=6,VK_COMPONENT_SWIZZLE_RANGE_SIZE=7,VK_COMPONENT_SWIZZLE_MAX_ENUM=2147483647};
typedef enum VkCommandBufferUsageFlagBits{VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT=1,VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT=2,VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT=4,VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalSemaphoreFeatureFlagBitsKHR{VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR=1,VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR=2,VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkStencilFaceFlagBits{VK_STENCIL_FACE_FRONT_BIT=1,VK_STENCIL_FACE_BACK_BIT=2,VK_STENCIL_FRONT_AND_BACK=3,VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandBufferLevel{VK_COMMAND_BUFFER_LEVEL_PRIMARY=0,VK_COMMAND_BUFFER_LEVEL_SECONDARY=1,VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE=0,VK_COMMAND_BUFFER_LEVEL_END_RANGE=1,VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE=2,VK_COMMAND_BUFFER_LEVEL_MAX_ENUM=2147483647};
typedef enum VkDiscardRectangleModeEXT{VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT=0,VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT=1,VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT=0,VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT=1,VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT=2,VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT=2147483647};
typedef enum VkSamplerReductionModeEXT{VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT=0,VK_SAMPLER_REDUCTION_MODE_MIN_EXT=1,VK_SAMPLER_REDUCTION_MODE_MAX_EXT=2,VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT=0,VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT=2,VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT=3,VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT=2147483647};
struct VkInstance_T {};
struct VkPhysicalDevice_T {};
struct VkDevice_T {};
struct VkQueue_T {};
struct VkSemaphore_T {};
struct VkCommandBuffer_T {};
struct VkFence_T {};
struct VkDeviceMemory_T {};
struct VkBuffer_T {};
struct VkImage_T {};
struct VkEvent_T {};
struct VkQueryPool_T {};
struct VkBufferView_T {};
struct VkImageView_T {};
struct VkShaderModule_T {};
struct VkPipelineCache_T {};
struct VkPipelineLayout_T {};
struct VkRenderPass_T {};
struct VkPipeline_T {};
struct VkDescriptorSetLayout_T {};
struct VkSampler_T {};
struct VkDescriptorPool_T {};
struct VkDescriptorSet_T {};
struct VkFramebuffer_T {};
struct VkCommandPool_T {};
struct VkApplicationInfo {enum VkStructureType sType;const void*pNext;const char*pApplicationName;unsigned int applicationVersion;const char*pEngineName;unsigned int engineVersion;unsigned int apiVersion;};
struct VkInstanceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkApplicationInfo*pApplicationInfo;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;};
struct VkAllocationCallbacks {void*pUserData;void*(*pfnAllocation)(void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void*(*pfnReallocation)(void*,void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void(*pfnFree)(void*,void*);void(*pfnInternalAllocation)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);void(*pfnInternalFree)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);};
struct VkPhysicalDeviceFeatures {unsigned int robustBufferAccess;unsigned int fullDrawIndexUint32;unsigned int imageCubeArray;unsigned int independentBlend;unsigned int geometryShader;unsigned int tessellationShader;unsigned int sampleRateShading;unsigned int dualSrcBlend;unsigned int logicOp;unsigned int multiDrawIndirect;unsigned int drawIndirectFirstInstance;unsigned int depthClamp;unsigned int depthBiasClamp;unsigned int fillModeNonSolid;unsigned int depthBounds;unsigned int wideLines;unsigned int largePoints;unsigned int alphaToOne;unsigned int multiViewport;unsigned int samplerAnisotropy;unsigned int textureCompressionETC2;unsigned int textureCompressionASTC_LDR;unsigned int textureCompressionBC;unsigned int occlusionQueryPrecise;unsigned int pipelineStatisticsQuery;unsigned int vertexPipelineStoresAndAtomics;unsigned int fragmentStoresAndAtomics;unsigned int shaderTessellationAndGeometryPointSize;unsigned int shaderImageGatherExtended;unsigned int shaderStorageImageExtendedFormats;unsigned int shaderStorageImageMultisample;unsigned int shaderStorageImageReadWithoutFormat;unsigned int shaderStorageImageWriteWithoutFormat;unsigned int shaderUniformBufferArrayDynamicIndexing;unsigned int shaderSampledImageArrayDynamicIndexing;unsigned int shaderStorageBufferArrayDynamicIndexing;unsigned int shaderStorageImageArrayDynamicIndexing;unsigned int shaderClipDistance;unsigned int shaderCullDistance;unsigned int shaderFloat64;unsigned int shaderInt64;unsigned int shaderInt16;unsigned int shaderResourceResidency;unsigned int shaderResourceMinLod;unsigned int sparseBinding;unsigned int sparseResidencyBuffer;unsigned int sparseResidencyImage2D;unsigned int sparseResidencyImage3D;unsigned int sparseResidency2Samples;unsigned int sparseResidency4Samples;unsigned int sparseResidency8Samples;unsigned int sparseResidency16Samples;unsigned int sparseResidencyAliased;unsigned int variableMultisampleRate;unsigned int inheritedQueries;};
struct VkFormatProperties {unsigned int linearTilingFeatures;unsigned int optimalTilingFeatures;unsigned int bufferFeatures;};
struct VkExtent3D {unsigned int width;unsigned int height;unsigned int depth;};
struct VkImageFormatProperties {struct VkExtent3D maxExtent;unsigned int maxMipLevels;unsigned int maxArrayLayers;unsigned int sampleCounts;unsigned long maxResourceSize;};
struct VkPhysicalDeviceLimits {unsigned int maxImageDimension1D;unsigned int maxImageDimension2D;unsigned int maxImageDimension3D;unsigned int maxImageDimensionCube;unsigned int maxImageArrayLayers;unsigned int maxTexelBufferElements;unsigned int maxUniformBufferRange;unsigned int maxStorageBufferRange;unsigned int maxPushConstantsSize;unsigned int maxMemoryAllocationCount;unsigned int maxSamplerAllocationCount;unsigned long bufferImageGranularity;unsigned long sparseAddressSpaceSize;unsigned int maxBoundDescriptorSets;unsigned int maxPerStageDescriptorSamplers;unsigned int maxPerStageDescriptorUniformBuffers;unsigned int maxPerStageDescriptorStorageBuffers;unsigned int maxPerStageDescriptorSampledImages;unsigned int maxPerStageDescriptorStorageImages;unsigned int maxPerStageDescriptorInputAttachments;unsigned int maxPerStageResources;unsigned int maxDescriptorSetSamplers;unsigned int maxDescriptorSetUniformBuffers;unsigned int maxDescriptorSetUniformBuffersDynamic;unsigned int maxDescriptorSetStorageBuffers;unsigned int maxDescriptorSetStorageBuffersDynamic;unsigned int maxDescriptorSetSampledImages;unsigned int maxDescriptorSetStorageImages;unsigned int maxDescriptorSetInputAttachments;unsigned int maxVertexInputAttributes;unsigned int maxVertexInputBindings;unsigned int maxVertexInputAttributeOffset;unsigned int maxVertexInputBindingStride;unsigned int maxVertexOutputComponents;unsigned int maxTessellationGenerationLevel;unsigned int maxTessellationPatchSize;unsigned int maxTessellationControlPerVertexInputComponents;unsigned int maxTessellationControlPerVertexOutputComponents;unsigned int maxTessellationControlPerPatchOutputComponents;unsigned int maxTessellationControlTotalOutputComponents;unsigned int maxTessellationEvaluationInputComponents;unsigned int maxTessellationEvaluationOutputComponents;unsigned int maxGeometryShaderInvocations;unsigned int maxGeometryInputComponents;unsigned int maxGeometryOutputComponents;unsigned int maxGeometryOutputVertices;unsigned int maxGeometryTotalOutputComponents;unsigned int maxFragmentInputComponents;unsigned int maxFragmentOutputAttachments;unsigned int maxFragmentDualSrcAttachments;unsigned int maxFragmentCombinedOutputResources;unsigned int maxComputeSharedMemorySize;unsigned int maxComputeWorkGroupCount[3];unsigned int maxComputeWorkGroupInvocations;unsigned int maxComputeWorkGroupSize[3];unsigned int subPixelPrecisionBits;unsigned int subTexelPrecisionBits;unsigned int mipmapPrecisionBits;unsigned int maxDrawIndexedIndexValue;unsigned int maxDrawIndirectCount;float maxSamplerLodBias;float maxSamplerAnisotropy;unsigned int maxViewports;unsigned int maxViewportDimensions[2];float viewportBoundsRange[2];unsigned int viewportSubPixelBits;unsigned long minMemoryMapAlignment;unsigned long minTexelBufferOffsetAlignment;unsigned long minUniformBufferOffsetAlignment;unsigned long minStorageBufferOffsetAlignment;int minTexelOffset;unsigned int maxTexelOffset;int minTexelGatherOffset;unsigned int maxTexelGatherOffset;float minInterpolationOffset;float maxInterpolationOffset;unsigned int subPixelInterpolationOffsetBits;unsigned int maxFramebufferWidth;unsigned int maxFramebufferHeight;unsigned int maxFramebufferLayers;unsigned int framebufferColorSampleCounts;unsigned int framebufferDepthSampleCounts;unsigned int framebufferStencilSampleCounts;unsigned int framebufferNoAttachmentsSampleCounts;unsigned int maxColorAttachments;unsigned int sampledImageColorSampleCounts;unsigned int sampledImageIntegerSampleCounts;unsigned int sampledImageDepthSampleCounts;unsigned int sampledImageStencilSampleCounts;unsigned int storageImageSampleCounts;unsigned int maxSampleMaskWords;unsigned int timestampComputeAndGraphics;float timestampPeriod;unsigned int maxClipDistances;unsigned int maxCullDistances;unsigned int maxCombinedClipAndCullDistances;unsigned int discreteQueuePriorities;float pointSizeRange[2];float lineWidthRange[2];float pointSizeGranularity;float lineWidthGranularity;unsigned int strictLines;unsigned int standardSampleLocations;unsigned long optimalBufferCopyOffsetAlignment;unsigned long optimalBufferCopyRowPitchAlignment;unsigned long nonCoherentAtomSize;};
struct VkPhysicalDeviceSparseProperties {unsigned int residencyStandard2DBlockShape;unsigned int residencyStandard2DMultisampleBlockShape;unsigned int residencyStandard3DBlockShape;unsigned int residencyAlignedMipSize;unsigned int residencyNonResidentStrict;};
struct VkPhysicalDeviceProperties {unsigned int apiVersion;unsigned int driverVersion;unsigned int vendorID;unsigned int deviceID;enum VkPhysicalDeviceType deviceType;char deviceName[256];unsigned char pipelineCacheUUID[16];struct VkPhysicalDeviceLimits limits;struct VkPhysicalDeviceSparseProperties sparseProperties;};
struct VkQueueFamilyProperties {unsigned int queueFlags;unsigned int queueCount;unsigned int timestampValidBits;struct VkExtent3D minImageTransferGranularity;};
struct VkMemoryType {unsigned int propertyFlags;unsigned int heapIndex;};
struct VkMemoryHeap {unsigned long size;unsigned int flags;};
struct VkPhysicalDeviceMemoryProperties {unsigned int memoryTypeCount;struct VkMemoryType memoryTypes[32];unsigned int memoryHeapCount;struct VkMemoryHeap memoryHeaps[16];};
struct VkDeviceQueueCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;unsigned int queueCount;const float*pQueuePriorities;};
struct VkDeviceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueCreateInfoCount;const struct VkDeviceQueueCreateInfo*pQueueCreateInfos;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;const struct VkPhysicalDeviceFeatures*pEnabledFeatures;};
struct VkExtensionProperties {char extensionName[256];unsigned int specVersion;};
struct VkLayerProperties {char layerName[256];unsigned int specVersion;unsigned int implementationVersion;char description[256];};
struct VkSubmitInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;const unsigned int*pWaitDstStageMask;unsigned int commandBufferCount;struct VkCommandBuffer_T*const*pCommandBuffers;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkMemoryAllocateInfo {enum VkStructureType sType;const void*pNext;unsigned long allocationSize;unsigned int memoryTypeIndex;};
struct VkMappedMemoryRange {enum VkStructureType sType;const void*pNext;struct VkDeviceMemory_T*memory;unsigned long offset;unsigned long size;};
struct VkMemoryRequirements {unsigned long size;unsigned long alignment;unsigned int memoryTypeBits;};
struct VkSparseImageFormatProperties {unsigned int aspectMask;struct VkExtent3D imageGranularity;unsigned int flags;};
struct VkSparseImageMemoryRequirements {struct VkSparseImageFormatProperties formatProperties;unsigned int imageMipTailFirstLod;unsigned long imageMipTailSize;unsigned long imageMipTailOffset;unsigned long imageMipTailStride;};
struct VkSparseMemoryBind {unsigned long resourceOffset;unsigned long size;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseBufferMemoryBindInfo {struct VkBuffer_T*buffer;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkSparseImageOpaqueMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkImageSubresource {unsigned int aspectMask;unsigned int mipLevel;unsigned int arrayLayer;};
struct VkOffset3D {int x;int y;int z;};
struct VkSparseImageMemoryBind {struct VkImageSubresource subresource;struct VkOffset3D offset;struct VkExtent3D extent;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseImageMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseImageMemoryBind*pBinds;};
struct VkBindSparseInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int bufferBindCount;const struct VkSparseBufferMemoryBindInfo*pBufferBinds;unsigned int imageOpaqueBindCount;const struct VkSparseImageOpaqueMemoryBindInfo*pImageOpaqueBinds;unsigned int imageBindCount;const struct VkSparseImageMemoryBindInfo*pImageBinds;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkFenceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkSemaphoreCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkEventCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkQueryPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkQueryType queryType;unsigned int queryCount;unsigned int pipelineStatistics;};
struct VkBufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long size;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;};
struct VkBufferViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkBuffer_T*buffer;enum VkFormat format;unsigned long offset;unsigned long range;};
struct VkImageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkImageType imageType;enum VkFormat format;struct VkExtent3D extent;unsigned int mipLevels;unsigned int arrayLayers;enum VkSampleCountFlagBits samples;enum VkImageTiling tiling;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkImageLayout initialLayout;};
struct VkSubresourceLayout {unsigned long offset;unsigned long size;unsigned long rowPitch;unsigned long arrayPitch;unsigned long depthPitch;};
struct VkComponentMapping {enum VkComponentSwizzle r;enum VkComponentSwizzle g;enum VkComponentSwizzle b;enum VkComponentSwizzle a;};
struct VkImageSubresourceRange {unsigned int aspectMask;unsigned int baseMipLevel;unsigned int levelCount;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkImage_T*image;enum VkImageViewType viewType;enum VkFormat format;struct VkComponentMapping components;struct VkImageSubresourceRange subresourceRange;};
struct VkShaderModuleCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long codeSize;const unsigned int*pCode;};
struct VkPipelineCacheCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long initialDataSize;const void*pInitialData;};
struct VkSpecializationMapEntry {unsigned int constantID;unsigned int offset;unsigned long size;};
struct VkSpecializationInfo {unsigned int mapEntryCount;const struct VkSpecializationMapEntry*pMapEntries;unsigned long dataSize;const void*pData;};
struct VkPipelineShaderStageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkShaderStageFlagBits stage;struct VkShaderModule_T*module;const char*pName;const struct VkSpecializationInfo*pSpecializationInfo;};
struct VkVertexInputBindingDescription {unsigned int binding;unsigned int stride;enum VkVertexInputRate inputRate;};
struct VkVertexInputAttributeDescription {unsigned int location;unsigned int binding;enum VkFormat format;unsigned int offset;};
struct VkPipelineVertexInputStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int vertexBindingDescriptionCount;const struct VkVertexInputBindingDescription*pVertexBindingDescriptions;unsigned int vertexAttributeDescriptionCount;const struct VkVertexInputAttributeDescription*pVertexAttributeDescriptions;};
struct VkPipelineInputAssemblyStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkPrimitiveTopology topology;unsigned int primitiveRestartEnable;};
struct VkPipelineTessellationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int patchControlPoints;};
struct VkViewport {float x;float y;float width;float height;float minDepth;float maxDepth;};
struct VkOffset2D {int x;int y;};
struct VkExtent2D {unsigned int width;unsigned int height;};
struct VkRect2D {struct VkOffset2D offset;struct VkExtent2D extent;};
struct VkPipelineViewportStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int viewportCount;const struct VkViewport*pViewports;unsigned int scissorCount;const struct VkRect2D*pScissors;};
struct VkPipelineRasterizationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthClampEnable;unsigned int rasterizerDiscardEnable;enum VkPolygonMode polygonMode;unsigned int cullMode;enum VkFrontFace frontFace;unsigned int depthBiasEnable;float depthBiasConstantFactor;float depthBiasClamp;float depthBiasSlopeFactor;float lineWidth;};
struct VkPipelineMultisampleStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkSampleCountFlagBits rasterizationSamples;unsigned int sampleShadingEnable;float minSampleShading;const unsigned int*pSampleMask;unsigned int alphaToCoverageEnable;unsigned int alphaToOneEnable;};
struct VkStencilOpState {enum VkStencilOp failOp;enum VkStencilOp passOp;enum VkStencilOp depthFailOp;enum VkCompareOp compareOp;unsigned int compareMask;unsigned int writeMask;unsigned int reference;};
struct VkPipelineDepthStencilStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthTestEnable;unsigned int depthWriteEnable;enum VkCompareOp depthCompareOp;unsigned int depthBoundsTestEnable;unsigned int stencilTestEnable;struct VkStencilOpState front;struct VkStencilOpState back;float minDepthBounds;float maxDepthBounds;};
struct VkPipelineColorBlendAttachmentState {unsigned int blendEnable;enum VkBlendFactor srcColorBlendFactor;enum VkBlendFactor dstColorBlendFactor;enum VkBlendOp colorBlendOp;enum VkBlendFactor srcAlphaBlendFactor;enum VkBlendFactor dstAlphaBlendFactor;enum VkBlendOp alphaBlendOp;unsigned int colorWriteMask;};
struct VkPipelineColorBlendStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int logicOpEnable;enum VkLogicOp logicOp;unsigned int attachmentCount;const struct VkPipelineColorBlendAttachmentState*pAttachments;float blendConstants[4];};
struct VkPipelineDynamicStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int dynamicStateCount;const enum VkDynamicState*pDynamicStates;};
struct VkGraphicsPipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int stageCount;const struct VkPipelineShaderStageCreateInfo*pStages;const struct VkPipelineVertexInputStateCreateInfo*pVertexInputState;const struct VkPipelineInputAssemblyStateCreateInfo*pInputAssemblyState;const struct VkPipelineTessellationStateCreateInfo*pTessellationState;const struct VkPipelineViewportStateCreateInfo*pViewportState;const struct VkPipelineRasterizationStateCreateInfo*pRasterizationState;const struct VkPipelineMultisampleStateCreateInfo*pMultisampleState;const struct VkPipelineDepthStencilStateCreateInfo*pDepthStencilState;const struct VkPipelineColorBlendStateCreateInfo*pColorBlendState;const struct VkPipelineDynamicStateCreateInfo*pDynamicState;struct VkPipelineLayout_T*layout;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkComputePipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkPipelineShaderStageCreateInfo stage;struct VkPipelineLayout_T*layout;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkPushConstantRange {unsigned int stageFlags;unsigned int offset;unsigned int size;};
struct VkPipelineLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int setLayoutCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;unsigned int pushConstantRangeCount;const struct VkPushConstantRange*pPushConstantRanges;};
struct VkSamplerCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkFilter magFilter;enum VkFilter minFilter;enum VkSamplerMipmapMode mipmapMode;enum VkSamplerAddressMode addressModeU;enum VkSamplerAddressMode addressModeV;enum VkSamplerAddressMode addressModeW;float mipLodBias;unsigned int anisotropyEnable;float maxAnisotropy;unsigned int compareEnable;enum VkCompareOp compareOp;float minLod;float maxLod;enum VkBorderColor borderColor;unsigned int unnormalizedCoordinates;};
struct VkDescriptorSetLayoutBinding {unsigned int binding;enum VkDescriptorType descriptorType;unsigned int descriptorCount;unsigned int stageFlags;struct VkSampler_T*const*pImmutableSamplers;};
struct VkDescriptorSetLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int bindingCount;const struct VkDescriptorSetLayoutBinding*pBindings;};
struct VkDescriptorPoolSize {enum VkDescriptorType type;unsigned int descriptorCount;};
struct VkDescriptorPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int maxSets;unsigned int poolSizeCount;const struct VkDescriptorPoolSize*pPoolSizes;};
struct VkDescriptorSetAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkDescriptorPool_T*descriptorPool;unsigned int descriptorSetCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;};
struct VkDescriptorImageInfo {struct VkSampler_T*sampler;struct VkImageView_T*imageView;enum VkImageLayout imageLayout;};
struct VkDescriptorBufferInfo {struct VkBuffer_T*buffer;unsigned long offset;unsigned long range;};
struct VkWriteDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;enum VkDescriptorType descriptorType;const struct VkDescriptorImageInfo*pImageInfo;const struct VkDescriptorBufferInfo*pBufferInfo;struct VkBufferView_T*const*pTexelBufferView;};
struct VkCopyDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*srcSet;unsigned int srcBinding;unsigned int srcArrayElement;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;};
struct VkFramebufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkRenderPass_T*renderPass;unsigned int attachmentCount;struct VkImageView_T*const*pAttachments;unsigned int width;unsigned int height;unsigned int layers;};
struct VkAttachmentDescription {unsigned int flags;enum VkFormat format;enum VkSampleCountFlagBits samples;enum VkAttachmentLoadOp loadOp;enum VkAttachmentStoreOp storeOp;enum VkAttachmentLoadOp stencilLoadOp;enum VkAttachmentStoreOp stencilStoreOp;enum VkImageLayout initialLayout;enum VkImageLayout finalLayout;};
struct VkAttachmentReference {unsigned int attachment;enum VkImageLayout layout;};
struct VkSubpassDescription {unsigned int flags;enum VkPipelineBindPoint pipelineBindPoint;unsigned int inputAttachmentCount;const struct VkAttachmentReference*pInputAttachments;unsigned int colorAttachmentCount;const struct VkAttachmentReference*pColorAttachments;const struct VkAttachmentReference*pResolveAttachments;const struct VkAttachmentReference*pDepthStencilAttachment;unsigned int preserveAttachmentCount;const unsigned int*pPreserveAttachments;};
struct VkSubpassDependency {unsigned int srcSubpass;unsigned int dstSubpass;unsigned int srcStageMask;unsigned int dstStageMask;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int dependencyFlags;};
struct VkRenderPassCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int attachmentCount;const struct VkAttachmentDescription*pAttachments;unsigned int subpassCount;const struct VkSubpassDescription*pSubpasses;unsigned int dependencyCount;const struct VkSubpassDependency*pDependencies;};
struct VkCommandPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;};
struct VkCommandBufferAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkCommandPool_T*commandPool;enum VkCommandBufferLevel level;unsigned int commandBufferCount;};
struct VkCommandBufferInheritanceInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkFramebuffer_T*framebuffer;unsigned int occlusionQueryEnable;unsigned int queryFlags;unsigned int pipelineStatistics;};
struct VkCommandBufferBeginInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkCommandBufferInheritanceInfo*pInheritanceInfo;};
struct VkBufferCopy {unsigned long srcOffset;unsigned long dstOffset;unsigned long size;};
struct VkImageSubresourceLayers {unsigned int aspectMask;unsigned int mipLevel;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageCopy {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkImageBlit {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffsets[2];struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffsets[2];};
struct VkBufferImageCopy {unsigned long bufferOffset;unsigned int bufferRowLength;unsigned int bufferImageHeight;struct VkImageSubresourceLayers imageSubresource;struct VkOffset3D imageOffset;struct VkExtent3D imageExtent;};
union VkClearColorValue {float float32[4];int int32[4];unsigned int uint32[4];};
struct VkClearDepthStencilValue {float depth;unsigned int stencil;};
union VkClearValue {union VkClearColorValue color;struct VkClearDepthStencilValue depthStencil;};
struct VkClearAttachment {unsigned int aspectMask;unsigned int colorAttachment;union VkClearValue clearValue;};
struct VkClearRect {struct VkRect2D rect;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageResolve {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;};
struct VkBufferMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkBuffer_T*buffer;unsigned long offset;unsigned long size;};
struct VkImageMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;enum VkImageLayout oldLayout;enum VkImageLayout newLayout;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkImage_T*image;struct VkImageSubresourceRange subresourceRange;};
struct VkRenderPassBeginInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;struct VkFramebuffer_T*framebuffer;struct VkRect2D renderArea;unsigned int clearValueCount;const union VkClearValue*pClearValues;};
struct VkSurfaceKHR_T {};
struct VkSurfaceCapabilitiesKHR {unsigned int minImageCount;unsigned int maxImageCount;struct VkExtent2D currentExtent;struct VkExtent2D minImageExtent;struct VkExtent2D maxImageExtent;unsigned int maxImageArrayLayers;unsigned int supportedTransforms;enum VkSurfaceTransformFlagBitsKHR currentTransform;unsigned int supportedCompositeAlpha;unsigned int supportedUsageFlags;};
struct VkSurfaceFormatKHR {enum VkFormat format;enum VkColorSpaceKHR colorSpace;};
struct VkSwapchainKHR_T {};
struct VkSwapchainCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkSurfaceKHR_T*surface;unsigned int minImageCount;enum VkFormat imageFormat;enum VkColorSpaceKHR imageColorSpace;struct VkExtent2D imageExtent;unsigned int imageArrayLayers;unsigned int imageUsage;enum VkSharingMode imageSharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkSurfaceTransformFlagBitsKHR preTransform;enum VkCompositeAlphaFlagBitsKHR compositeAlpha;enum VkPresentModeKHR presentMode;unsigned int clipped;struct VkSwapchainKHR_T*oldSwapchain;};
struct VkPresentInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int swapchainCount;struct VkSwapchainKHR_T*const*pSwapchains;const unsigned int*pImageIndices;enum VkResult*pResults;};
struct VkDisplayKHR_T {};
struct VkDisplayModeKHR_T {};
struct VkDisplayPropertiesKHR {struct VkDisplayKHR_T*display;const char*displayName;struct VkExtent2D physicalDimensions;struct VkExtent2D physicalResolution;unsigned int supportedTransforms;unsigned int planeReorderPossible;unsigned int persistentContent;};
struct VkDisplayModeParametersKHR {struct VkExtent2D visibleRegion;unsigned int refreshRate;};
struct VkDisplayModePropertiesKHR {struct VkDisplayModeKHR_T*displayMode;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayModeCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayPlaneCapabilitiesKHR {unsigned int supportedAlpha;struct VkOffset2D minSrcPosition;struct VkOffset2D maxSrcPosition;struct VkExtent2D minSrcExtent;struct VkExtent2D maxSrcExtent;struct VkOffset2D minDstPosition;struct VkOffset2D maxDstPosition;struct VkExtent2D minDstExtent;struct VkExtent2D maxDstExtent;};
struct VkDisplayPlanePropertiesKHR {struct VkDisplayKHR_T*currentDisplay;unsigned int currentStackIndex;};
struct VkDisplaySurfaceCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeKHR_T*displayMode;unsigned int planeIndex;unsigned int planeStackIndex;enum VkSurfaceTransformFlagBitsKHR transform;float globalAlpha;enum VkDisplayPlaneAlphaFlagBitsKHR alphaMode;struct VkExtent2D imageExtent;};
struct VkPhysicalDeviceFeatures2KHR {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceFeatures features;};
struct VkPhysicalDeviceProperties2KHR {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceProperties properties;};
struct VkFormatProperties2KHR {enum VkStructureType sType;void*pNext;struct VkFormatProperties formatProperties;};
struct VkImageFormatProperties2KHR {enum VkStructureType sType;void*pNext;struct VkImageFormatProperties imageFormatProperties;};
struct VkPhysicalDeviceImageFormatInfo2KHR {enum VkStructureType sType;const void*pNext;enum VkFormat format;enum VkImageType type;enum VkImageTiling tiling;unsigned int usage;unsigned int flags;};
struct VkQueueFamilyProperties2KHR {enum VkStructureType sType;void*pNext;struct VkQueueFamilyProperties queueFamilyProperties;};
struct VkPhysicalDeviceMemoryProperties2KHR {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceMemoryProperties memoryProperties;};
struct VkSparseImageFormatProperties2KHR {enum VkStructureType sType;void*pNext;struct VkSparseImageFormatProperties properties;};
struct VkPhysicalDeviceSparseImageFormatInfo2KHR {enum VkStructureType sType;const void*pNext;enum VkFormat format;enum VkImageType type;enum VkSampleCountFlagBits samples;unsigned int usage;enum VkImageTiling tiling;};
struct VkExternalMemoryPropertiesKHR {unsigned int externalMemoryFeatures;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;};
struct VkPhysicalDeviceExternalBufferInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int usage;enum VkExternalMemoryHandleTypeFlagBitsKHR handleType;};
struct VkExternalBufferPropertiesKHR {enum VkStructureType sType;void*pNext;struct VkExternalMemoryPropertiesKHR externalMemoryProperties;};
struct VkMemoryFdPropertiesKHR {enum VkStructureType sType;void*pNext;unsigned int memoryTypeBits;};
struct VkMemoryGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkDeviceMemory_T*memory;enum VkExternalMemoryHandleTypeFlagBitsKHR handleType;};
struct VkPhysicalDeviceExternalSemaphoreInfoKHR {enum VkStructureType sType;const void*pNext;enum VkExternalSemaphoreHandleTypeFlagBitsKHR handleType;};
struct VkExternalSemaphorePropertiesKHR {enum VkStructureType sType;void*pNext;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;unsigned int externalSemaphoreFeatures;};
struct VkImportSemaphoreFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkSemaphore_T*semaphore;unsigned int flags;enum VkExternalSemaphoreHandleTypeFlagBitsKHR handleType;int fd;};
struct VkSemaphoreGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkSemaphore_T*semaphore;enum VkExternalSemaphoreHandleTypeFlagBitsKHR handleType;};
struct VkDescriptorUpdateTemplateKHR_T {};
struct VkDescriptorUpdateTemplateEntryKHR {unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;enum VkDescriptorType descriptorType;unsigned long offset;unsigned long stride;};
struct VkDescriptorUpdateTemplateCreateInfoKHR {enum VkStructureType sType;void*pNext;unsigned int flags;unsigned int descriptorUpdateEntryCount;const struct VkDescriptorUpdateTemplateEntryKHR*pDescriptorUpdateEntries;enum VkDescriptorUpdateTemplateTypeKHR templateType;struct VkDescriptorSetLayout_T*descriptorSetLayout;enum VkPipelineBindPoint pipelineBindPoint;struct VkPipelineLayout_T*pipelineLayout;unsigned int set;};
struct VkPhysicalDeviceExternalFenceInfoKHR {enum VkStructureType sType;const void*pNext;enum VkExternalFenceHandleTypeFlagBitsKHR handleType;};
struct VkExternalFencePropertiesKHR {enum VkStructureType sType;void*pNext;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;unsigned int externalFenceFeatures;};
struct VkImportFenceFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkFence_T*fence;unsigned int flags;enum VkExternalFenceHandleTypeFlagBitsKHR handleType;int fd;};
struct VkFenceGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkFence_T*fence;enum VkExternalFenceHandleTypeFlagBitsKHR handleType;};
struct VkPhysicalDeviceSurfaceInfo2KHR {enum VkStructureType sType;const void*pNext;struct VkSurfaceKHR_T*surface;};
struct VkSurfaceCapabilities2KHR {enum VkStructureType sType;void*pNext;struct VkSurfaceCapabilitiesKHR surfaceCapabilities;};
struct VkSurfaceFormat2KHR {enum VkStructureType sType;void*pNext;struct VkSurfaceFormatKHR surfaceFormat;};
struct VkBufferMemoryRequirementsInfo2KHR {enum VkStructureType sType;const void*pNext;struct VkBuffer_T*buffer;};
struct VkImageMemoryRequirementsInfo2KHR {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;};
struct VkImageSparseMemoryRequirementsInfo2KHR {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;};
struct VkMemoryRequirements2KHR {enum VkStructureType sType;void*pNext;struct VkMemoryRequirements memoryRequirements;};
struct VkSparseImageMemoryRequirements2KHR {enum VkStructureType sType;void*pNext;struct VkSparseImageMemoryRequirements memoryRequirements;};
struct VkDebugReportCallbackEXT_T {};
struct VkDebugReportCallbackCreateInfoEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int(*pfnCallback)(unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*,void*);void*pUserData;};
struct VkDebugMarkerObjectNameInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;const char*pObjectName;};
struct VkDebugMarkerObjectTagInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;unsigned long tagName;unsigned long tagSize;const void*pTag;};
struct VkDebugMarkerMarkerInfoEXT {enum VkStructureType sType;const void*pNext;const char*pMarkerName;float color[4];};
struct VkExternalImageFormatPropertiesNV {struct VkImageFormatProperties imageFormatProperties;unsigned int externalMemoryFeatures;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;};
struct VkBindBufferMemoryInfoKHX {enum VkStructureType sType;const void*pNext;struct VkBuffer_T*buffer;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int deviceIndexCount;const unsigned int*pDeviceIndices;};
struct VkBindImageMemoryInfoKHX {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int deviceIndexCount;const unsigned int*pDeviceIndices;unsigned int SFRRectCount;const struct VkRect2D*pSFRRects;};
struct VkDeviceGroupPresentCapabilitiesKHX {enum VkStructureType sType;const void*pNext;unsigned int presentMask[32];unsigned int modes;};
struct VkAcquireNextImageInfoKHX {enum VkStructureType sType;const void*pNext;struct VkSwapchainKHR_T*swapchain;unsigned long timeout;struct VkSemaphore_T*semaphore;struct VkFence_T*fence;unsigned int deviceMask;};
struct VkPhysicalDeviceGroupPropertiesKHX {enum VkStructureType sType;void*pNext;unsigned int physicalDeviceCount;struct VkPhysicalDevice_T*physicalDevices[32];unsigned int subsetAllocation;};
struct VkObjectTableNVX_T {};
struct VkIndirectCommandsLayoutNVX_T {};
struct VkDeviceGeneratedCommandsFeaturesNVX {enum VkStructureType sType;const void*pNext;unsigned int computeBindingPointSupport;};
struct VkDeviceGeneratedCommandsLimitsNVX {enum VkStructureType sType;const void*pNext;unsigned int maxIndirectCommandsLayoutTokenCount;unsigned int maxObjectEntryCounts;unsigned int minSequenceCountBufferOffsetAlignment;unsigned int minSequenceIndexBufferOffsetAlignment;unsigned int minCommandsTokenBufferOffsetAlignment;};
struct VkIndirectCommandsTokenNVX {enum VkIndirectCommandsTokenTypeNVX tokenType;struct VkBuffer_T*buffer;unsigned long offset;};
struct VkIndirectCommandsLayoutTokenNVX {enum VkIndirectCommandsTokenTypeNVX tokenType;unsigned int bindingUnit;unsigned int dynamicCount;unsigned int divisor;};
struct VkIndirectCommandsLayoutCreateInfoNVX {enum VkStructureType sType;const void*pNext;enum VkPipelineBindPoint pipelineBindPoint;unsigned int flags;unsigned int tokenCount;const struct VkIndirectCommandsLayoutTokenNVX*pTokens;};
struct VkCmdProcessCommandsInfoNVX {enum VkStructureType sType;const void*pNext;struct VkObjectTableNVX_T*objectTable;struct VkIndirectCommandsLayoutNVX_T*indirectCommandsLayout;unsigned int indirectCommandsTokenCount;const struct VkIndirectCommandsTokenNVX*pIndirectCommandsTokens;unsigned int maxSequencesCount;struct VkCommandBuffer_T*targetCommandBuffer;struct VkBuffer_T*sequencesCountBuffer;unsigned long sequencesCountOffset;struct VkBuffer_T*sequencesIndexBuffer;unsigned long sequencesIndexOffset;};
struct VkCmdReserveSpaceForCommandsInfoNVX {enum VkStructureType sType;const void*pNext;struct VkObjectTableNVX_T*objectTable;struct VkIndirectCommandsLayoutNVX_T*indirectCommandsLayout;unsigned int maxSequencesCount;};
struct VkObjectTableCreateInfoNVX {enum VkStructureType sType;const void*pNext;unsigned int objectCount;const enum VkObjectEntryTypeNVX*pObjectEntryTypes;const unsigned int*pObjectEntryCounts;const unsigned int*pObjectEntryUsageFlags;unsigned int maxUniformBuffersPerDescriptor;unsigned int maxStorageBuffersPerDescriptor;unsigned int maxStorageImagesPerDescriptor;unsigned int maxSampledImagesPerDescriptor;unsigned int maxPipelineLayouts;};
struct VkObjectTableEntryNVX {enum VkObjectEntryTypeNVX type;unsigned int flags;};
struct VkViewportWScalingNV {float xcoeff;float ycoeff;};
struct VkSurfaceCapabilities2EXT {enum VkStructureType sType;void*pNext;unsigned int minImageCount;unsigned int maxImageCount;struct VkExtent2D currentExtent;struct VkExtent2D minImageExtent;struct VkExtent2D maxImageExtent;unsigned int maxImageArrayLayers;unsigned int supportedTransforms;enum VkSurfaceTransformFlagBitsKHR currentTransform;unsigned int supportedCompositeAlpha;unsigned int supportedUsageFlags;unsigned int supportedSurfaceCounters;};
struct VkDisplayPowerInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDisplayPowerStateEXT powerState;};
struct VkDeviceEventInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDeviceEventTypeEXT deviceEvent;};
struct VkDisplayEventInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDisplayEventTypeEXT displayEvent;};
struct VkRefreshCycleDurationGOOGLE {unsigned long refreshDuration;};
struct VkPastPresentationTimingGOOGLE {unsigned int presentID;unsigned long desiredPresentTime;unsigned long actualPresentTime;unsigned long earliestPresentTime;unsigned long presentMargin;};
struct VkXYColorEXT {float x;float y;};
struct VkHdrMetadataEXT {enum VkStructureType sType;const void*pNext;struct VkXYColorEXT displayPrimaryRed;struct VkXYColorEXT displayPrimaryGreen;struct VkXYColorEXT displayPrimaryBlue;struct VkXYColorEXT whitePoint;float maxLuminance;float minLuminance;float maxContentLightLevel;float maxFrameAverageLightLevel;};
void(vkGetBufferMemoryRequirements)(struct VkDevice_T*,struct VkBuffer_T*,struct VkMemoryRequirements*);
enum VkResult(vkDeviceWaitIdle)(struct VkDevice_T*);
enum VkResult(vkCreateBufferView)(struct VkDevice_T*,const struct VkBufferViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkBufferView_T**);
void(vkCmdCopyImageToBuffer)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkBuffer_T*,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdResolveImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageResolve*);
enum VkResult(vkCreateGraphicsPipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkGraphicsPipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
void(vkCmdSetStencilCompareMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkGetPipelineCacheData)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned long*,void*);
void(vkDestroyObjectTableNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,const struct VkAllocationCallbacks*);
void(vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)(struct VkPhysicalDevice_T*,struct VkDeviceGeneratedCommandsFeaturesNVX*,struct VkDeviceGeneratedCommandsLimitsNVX*);
void(vkGetRenderAreaGranularity)(struct VkDevice_T*,struct VkRenderPass_T*,struct VkExtent2D*);
void(vkDestroyInstance)(struct VkInstance_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumerateInstanceLayerProperties)(unsigned int*,struct VkLayerProperties*);
enum VkResult(vkResetEvent)(struct VkDevice_T*,struct VkEvent_T*);
void(vkGetPhysicalDeviceQueueFamilyProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties*);
enum VkResult(vkQueueWaitIdle)(struct VkQueue_T*);
enum VkResult(vkRegisterDisplayEventEXT)(struct VkDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayEventInfoEXT*,const struct VkAllocationCallbacks*,struct VkFence_T**);
enum VkResult(vkImportFenceFdKHR)(struct VkDevice_T*,const struct VkImportFenceFdInfoKHR*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilities2EXT)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,struct VkSurfaceCapabilities2EXT*);
enum VkResult(vkEnumeratePhysicalDevices)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDevice_T**);
void(vkCmdWriteTimestamp)(struct VkCommandBuffer_T*,enum VkPipelineStageFlagBits,struct VkQueryPool_T*,unsigned int);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceImageFormatInfo2KHR*,struct VkImageFormatProperties2KHR*);
void(vkGetPhysicalDeviceFormatProperties2KHR)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties2KHR*);
void(vkCmdSetViewportWScalingNV)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkViewportWScalingNV*);
enum VkResult(vkCreateShaderModule)(struct VkDevice_T*,const struct VkShaderModuleCreateInfo*,const struct VkAllocationCallbacks*,struct VkShaderModule_T**);
void(vkDestroySurfaceKHR)(struct VkInstance_T*,struct VkSurfaceKHR_T*,const struct VkAllocationCallbacks*);
void(vkCmdCopyQueryPoolResults)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
enum VkResult(vkGetMemoryFdKHR)(struct VkDevice_T*,const struct VkMemoryGetFdInfoKHR*,int*);
enum VkResult(vkMergePipelineCaches)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,struct VkPipelineCache_T*const*);
void(vkGetPhysicalDeviceQueueFamilyProperties2KHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties2KHR*);
void(vkCmdSetStencilWriteMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkCreateFramebuffer)(struct VkDevice_T*,const struct VkFramebufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkFramebuffer_T**);
void(vkCmdResetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
enum VkResult(vkBindBufferMemory)(struct VkDevice_T*,struct VkBuffer_T*,struct VkDeviceMemory_T*,unsigned long);
void(vkCmdSetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
void(vkCmdBindDescriptorSets)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipelineLayout_T*,unsigned int,unsigned int,struct VkDescriptorSet_T*const*,unsigned int,const unsigned int*);
enum VkResult(vkEnumerateInstanceExtensionProperties)(const char*,unsigned int*,struct VkExtensionProperties*);
void(vkCmdSetDepthBounds)(struct VkCommandBuffer_T*,float,float);
void(vkCmdDispatchIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long);
void(vkDestroyEvent)(struct VkDevice_T*,struct VkEvent_T*,const struct VkAllocationCallbacks*);
void(vkCmdNextSubpass)(struct VkCommandBuffer_T*,enum VkSubpassContents);
void(vkCmdCopyBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkBuffer_T*,unsigned int,const struct VkBufferCopy*);
enum VkResult(vkRegisterObjectsNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,unsigned int,const struct VkObjectTableEntryNVX*const*,const unsigned int*);
void(vkCmdDrawIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetDisplayPlaneSupportedDisplaysKHR)(struct VkPhysicalDevice_T*,unsigned int,unsigned int*,struct VkDisplayKHR_T**);
void(vkDestroyBuffer)(struct VkDevice_T*,struct VkBuffer_T*,const struct VkAllocationCallbacks*);
void(vkCmdCopyImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageCopy*);
void(vkGetPhysicalDeviceSparseImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkSampleCountFlagBits,unsigned int,enum VkImageTiling,unsigned int*,struct VkSparseImageFormatProperties*);
enum VkResult(vkEnumeratePhysicalDeviceGroupsKHX)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDeviceGroupPropertiesKHX*);
enum VkResult(vkCreateComputePipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkComputePipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
void(vkDestroyIndirectCommandsLayoutNVX)(struct VkDevice_T*,struct VkIndirectCommandsLayoutNVX_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateQueryPool)(struct VkDevice_T*,const struct VkQueryPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkQueryPool_T**);
enum VkResult(vkCreateDescriptorSetLayout)(struct VkDevice_T*,const struct VkDescriptorSetLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorSetLayout_T**);
enum VkResult(vkResetFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*);
enum VkResult(vkAllocateCommandBuffers)(struct VkDevice_T*,const struct VkCommandBufferAllocateInfo*,struct VkCommandBuffer_T**);
enum VkResult(vkGetPastPresentationTimingGOOGLE)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned int*,struct VkPastPresentationTimingGOOGLE*);
enum VkResult(vkGetPhysicalDeviceSurfaceFormatsKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,struct VkSurfaceFormatKHR*);
enum VkResult(vkGetRefreshCycleDurationGOOGLE)(struct VkDevice_T*,struct VkSwapchainKHR_T*,struct VkRefreshCycleDurationGOOGLE*);
void(vkDestroyQueryPool)(struct VkDevice_T*,struct VkQueryPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateDescriptorPool)(struct VkDevice_T*,const struct VkDescriptorPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorPool_T**);
enum VkResult(vkGetSwapchainCounterEXT)(struct VkDevice_T*,struct VkSwapchainKHR_T*,enum VkSurfaceCounterFlagBitsEXT,unsigned long*);
void(vkGetImageSubresourceLayout)(struct VkDevice_T*,struct VkImage_T*,const struct VkImageSubresource*,struct VkSubresourceLayout*);
void(vkCmdUpdateBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,const void*);
enum VkResult(vkCreateEvent)(struct VkDevice_T*,const struct VkEventCreateInfo*,const struct VkAllocationCallbacks*,struct VkEvent_T**);
void(vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalSemaphoreInfoKHR*,struct VkExternalSemaphorePropertiesKHR*);
void(vkCmdSetStencilReference)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkDisplayPowerControlEXT)(struct VkDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayPowerInfoEXT*);
enum VkResult(vkEndCommandBuffer)(struct VkCommandBuffer_T*);
enum VkResult(vkUnregisterObjectsNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,unsigned int,const enum VkObjectEntryTypeNVX*,const unsigned int*);
enum VkResult(vkCreateObjectTableNVX)(struct VkDevice_T*,const struct VkObjectTableCreateInfoNVX*,const struct VkAllocationCallbacks*,struct VkObjectTableNVX_T**);
enum VkResult(vkCreateIndirectCommandsLayoutNVX)(struct VkDevice_T*,const struct VkIndirectCommandsLayoutCreateInfoNVX*,const struct VkAllocationCallbacks*,struct VkIndirectCommandsLayoutNVX_T**);
enum VkResult(vkCreateBuffer)(struct VkDevice_T*,const struct VkBufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkBuffer_T**);
void(vkFreeCommandBuffers)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int,struct VkCommandBuffer_T*const*);
void(vkCmdReserveSpaceForCommandsNVX)(struct VkCommandBuffer_T*,const struct VkCmdReserveSpaceForCommandsInfoNVX*);
void(vkCmdDispatchBaseKHX)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int);
void(vkDestroyDebugReportCallbackEXT)(struct VkInstance_T*,struct VkDebugReportCallbackEXT_T*,const struct VkAllocationCallbacks*);
void(vkCmdSetViewport)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkViewport*);
enum VkResult(vkGetFenceStatus)(struct VkDevice_T*,struct VkFence_T*);
void(vkGetImageSparseMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkImageSparseMemoryRequirementsInfo2KHR*,unsigned int*,struct VkSparseImageMemoryRequirements2KHR*);
void(vkCmdBeginQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
void(vkCmdProcessCommandsNVX)(struct VkCommandBuffer_T*,const struct VkCmdProcessCommandsInfoNVX*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,struct VkSurfaceCapabilitiesKHR*);
void(vkDestroyPipeline)(struct VkDevice_T*,struct VkPipeline_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateSwapchainKHR)(struct VkDevice_T*,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
void(vkGetPhysicalDeviceFeatures2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures2KHR*);
enum VkResult(vkQueueSubmit)(struct VkQueue_T*,unsigned int,const struct VkSubmitInfo*,struct VkFence_T*);
void(vkCmdBlitImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageBlit*,enum VkFilter);
enum VkResult(vkBindImageMemory2KHX)(struct VkDevice_T*,unsigned int,const struct VkBindImageMemoryInfoKHX*);
enum VkResult(vkGetDeviceGroupPresentCapabilitiesKHX)(struct VkDevice_T*,struct VkDeviceGroupPresentCapabilitiesKHX*);
void(vkCmdDrawIndexedIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
void(vkTrimCommandPoolKHR)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
void(vkCmdSetDepthBias)(struct VkCommandBuffer_T*,float,float,float);
void(vkCmdSetDeviceMaskKHX)(struct VkCommandBuffer_T*,unsigned int);
enum VkResult(vkGetDeviceGroupSurfacePresentModesKHX)(struct VkDevice_T*,struct VkSurfaceKHR_T*,unsigned int*);
enum VkResult(vkGetPhysicalDeviceSurfaceSupportKHR)(struct VkPhysicalDevice_T*,unsigned int,struct VkSurfaceKHR_T*,unsigned int*);
enum VkResult(vkCreateSemaphore)(struct VkDevice_T*,const struct VkSemaphoreCreateInfo*,const struct VkAllocationCallbacks*,struct VkSemaphore_T**);
enum VkResult(vkGetSwapchainStatusKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*);
void(vkGetDeviceGroupPeerMemoryFeaturesKHX)(struct VkDevice_T*,unsigned int,unsigned int,unsigned int,unsigned int*);
void(vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSparseImageFormatInfo2KHR*,unsigned int*,struct VkSparseImageFormatProperties2KHR*);
enum VkResult(vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,unsigned int,struct VkExternalImageFormatPropertiesNV*);
void(vkDestroyShaderModule)(struct VkDevice_T*,struct VkShaderModule_T*,const struct VkAllocationCallbacks*);
void(vkGetPhysicalDeviceExternalFencePropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalFenceInfoKHR*,struct VkExternalFencePropertiesKHR*);
enum VkResult(vkCreatePipelineCache)(struct VkDevice_T*,const struct VkPipelineCacheCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineCache_T**);
enum VkResult(vkCreateImageView)(struct VkDevice_T*,const struct VkImageViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkImageView_T**);
void(vkGetPhysicalDeviceFeatures)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures*);
void(vkDestroyPipelineLayout)(struct VkDevice_T*,struct VkPipelineLayout_T*,const struct VkAllocationCallbacks*);
void(vkDestroySampler)(struct VkDevice_T*,struct VkSampler_T*,const struct VkAllocationCallbacks*);
void(vkFreeMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,struct VkImageFormatProperties*);
void(vkDestroySwapchainKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkMapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long,unsigned long,unsigned int,void**);
void(vkDestroyFramebuffer)(struct VkDevice_T*,struct VkFramebuffer_T*,const struct VkAllocationCallbacks*);
void(vkGetDeviceMemoryCommitment)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long*);
void(vkCmdCopyBufferToImage)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdBindVertexBuffers)(struct VkCommandBuffer_T*,unsigned int,unsigned int,struct VkBuffer_T*const*,const unsigned long*);
void(vkGetPhysicalDeviceMemoryProperties2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties2KHR*);
void(vkCmdDebugMarkerEndEXT)(struct VkCommandBuffer_T*);
void(vkCmdDebugMarkerBeginEXT)(struct VkCommandBuffer_T*,const struct VkDebugMarkerMarkerInfoEXT*);
void(vkCmdResetQueryPool)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
enum VkResult(vkDebugMarkerSetObjectTagEXT)(struct VkDevice_T*,const struct VkDebugMarkerObjectTagInfoEXT*);
void(vkDestroyCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,const struct VkAllocationCallbacks*);
void(vkDebugReportMessageEXT)(struct VkInstance_T*,unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*);
void(vkCmdPushDescriptorSetWithTemplateKHR)(struct VkCommandBuffer_T*,struct VkDescriptorUpdateTemplateKHR_T*,struct VkPipelineLayout_T*,unsigned int,const void*);
enum VkResult(vkCreateDebugReportCallbackEXT)(struct VkInstance_T*,const struct VkDebugReportCallbackCreateInfoEXT*,const struct VkAllocationCallbacks*,struct VkDebugReportCallbackEXT_T**);
void(vkGetBufferMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkBufferMemoryRequirementsInfo2KHR*,struct VkMemoryRequirements2KHR*);
void(vkDestroyDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetPhysicalDeviceSurfaceFormats2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSurfaceInfo2KHR*,unsigned int*,struct VkSurfaceFormat2KHR*);
void(vkGetPhysicalDeviceExternalBufferPropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalBufferInfoKHR*,struct VkExternalBufferPropertiesKHR*);
enum VkResult(vkInvalidateMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
enum VkResult(vkGetDisplayPlaneCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayModeKHR_T*,unsigned int,struct VkDisplayPlaneCapabilitiesKHR*);
void(vkCmdBindPipeline)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipeline_T*);
void(vkDestroyBufferView)(struct VkDevice_T*,struct VkBufferView_T*,const struct VkAllocationCallbacks*);
void(vkGetImageSparseMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,unsigned int*,struct VkSparseImageMemoryRequirements*);
void(vkDestroyImageView)(struct VkDevice_T*,struct VkImageView_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkResetCommandBuffer)(struct VkCommandBuffer_T*,unsigned int);
void(vkCmdDrawIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
void(vkDestroySemaphore)(struct VkDevice_T*,struct VkSemaphore_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkBindBufferMemory2KHX)(struct VkDevice_T*,unsigned int,const struct VkBindBufferMemoryInfoKHX*);
enum VkResult(vkCreateSampler)(struct VkDevice_T*,const struct VkSamplerCreateInfo*,const struct VkAllocationCallbacks*,struct VkSampler_T**);
void(vkDestroyDescriptorUpdateTemplateKHR)(struct VkDevice_T*,struct VkDescriptorUpdateTemplateKHR_T*,const struct VkAllocationCallbacks*);
void(vkDestroyPipelineCache)(struct VkDevice_T*,struct VkPipelineCache_T*,const struct VkAllocationCallbacks*);
void(*vkGetInstanceProcAddr(struct VkInstance_T*,const char*))();
void(vkGetImageMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,struct VkMemoryRequirements*);
void(vkCmdPushDescriptorSetKHR)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipelineLayout_T*,unsigned int,unsigned int,const struct VkWriteDescriptorSet*);
enum VkResult(vkSetEvent)(struct VkDevice_T*,struct VkEvent_T*);
enum VkResult(vkGetSemaphoreFdKHR)(struct VkDevice_T*,const struct VkSemaphoreGetFdInfoKHR*,int*);
enum VkResult(vkGetEventStatus)(struct VkDevice_T*,struct VkEvent_T*);
enum VkResult(vkImportSemaphoreFdKHR)(struct VkDevice_T*,const struct VkImportSemaphoreFdInfoKHR*);
enum VkResult(vkCreateDevice)(struct VkPhysicalDevice_T*,const struct VkDeviceCreateInfo*,const struct VkAllocationCallbacks*,struct VkDevice_T**);
enum VkResult(vkCreateInstance)(const struct VkInstanceCreateInfo*,const struct VkAllocationCallbacks*,struct VkInstance_T**);
void(vkCmdClearDepthStencilImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const struct VkClearDepthStencilValue*,unsigned int,const struct VkImageSubresourceRange*);
void(vkCmdEndRenderPass)(struct VkCommandBuffer_T*);
enum VkResult(vkBeginCommandBuffer)(struct VkCommandBuffer_T*,const struct VkCommandBufferBeginInfo*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilities2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSurfaceInfo2KHR*,struct VkSurfaceCapabilities2KHR*);
void(vkCmdDrawIndexed)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,int,unsigned int);
void(vkCmdDebugMarkerInsertEXT)(struct VkCommandBuffer_T*,const struct VkDebugMarkerMarkerInfoEXT*);
enum VkResult(vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPlanePropertiesKHR*);
void(vkCmdFillBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
void(vkGetPhysicalDeviceProperties2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties2KHR*);
void(vkGetDeviceQueue)(struct VkDevice_T*,unsigned int,unsigned int,struct VkQueue_T**);
enum VkResult(vkCreateSharedSwapchainsKHR)(struct VkDevice_T*,unsigned int,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
enum VkResult(vkCreateDisplayPlaneSurfaceKHR)(struct VkInstance_T*,const struct VkDisplaySurfaceCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSurfaceKHR_T**);
void(vkCmdWaitEvents)(struct VkCommandBuffer_T*,unsigned int,struct VkEvent_T*const*,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
enum VkResult(vkGetMemoryFdPropertiesKHR)(struct VkDevice_T*,enum VkExternalMemoryHandleTypeFlagBitsKHR,int,struct VkMemoryFdPropertiesKHR*);
void(vkCmdDrawIndexedIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetPhysicalDeviceDisplayPropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPropertiesKHR*);
enum VkResult(vkQueuePresentKHR)(struct VkQueue_T*,const struct VkPresentInfoKHR*);
enum VkResult(vkAcquireNextImageKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned long,struct VkSemaphore_T*,struct VkFence_T*,unsigned int*);
void(vkDestroyFence)(struct VkDevice_T*,struct VkFence_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetSwapchainImagesKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned int*,struct VkImage_T**);
enum VkResult(vkCreateImage)(struct VkDevice_T*,const struct VkImageCreateInfo*,const struct VkAllocationCallbacks*,struct VkImage_T**);
enum VkResult(vkGetDisplayModePropertiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,unsigned int*,struct VkDisplayModePropertiesKHR*);
enum VkResult(vkAcquireNextImage2KHX)(struct VkDevice_T*,const struct VkAcquireNextImageInfoKHX*,unsigned int*);
enum VkResult(vkGetPhysicalDeviceSurfacePresentModesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,enum VkPresentModeKHR*);
enum VkResult(vkAllocateMemory)(struct VkDevice_T*,const struct VkMemoryAllocateInfo*,const struct VkAllocationCallbacks*,struct VkDeviceMemory_T**);
void(vkCmdClearColorImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const union VkClearColorValue*,unsigned int,const struct VkImageSubresourceRange*);
void(vkCmdExecuteCommands)(struct VkCommandBuffer_T*,unsigned int,struct VkCommandBuffer_T*const*);
enum VkResult(vkCreateDisplayModeKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayModeCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkDisplayModeKHR_T**);
void(vkCmdBeginRenderPass)(struct VkCommandBuffer_T*,const struct VkRenderPassBeginInfo*,enum VkSubpassContents);
void(vkCmdClearAttachments)(struct VkCommandBuffer_T*,unsigned int,const struct VkClearAttachment*,unsigned int,const struct VkClearRect*);
void(vkCmdPushConstants)(struct VkCommandBuffer_T*,struct VkPipelineLayout_T*,unsigned int,unsigned int,unsigned int,const void*);
enum VkResult(vkDebugMarkerSetObjectNameEXT)(struct VkDevice_T*,const struct VkDebugMarkerObjectNameInfoEXT*);
void(vkCmdEndQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int);
enum VkResult(vkCreateFence)(struct VkDevice_T*,const struct VkFenceCreateInfo*,const struct VkAllocationCallbacks*,struct VkFence_T**);
void(vkCmdBindIndexBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,enum VkIndexType);
enum VkResult(vkReleaseDisplayEXT)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*);
enum VkResult(vkCreateRenderPass)(struct VkDevice_T*,const struct VkRenderPassCreateInfo*,const struct VkAllocationCallbacks*,struct VkRenderPass_T**);
void(vkDestroyImage)(struct VkDevice_T*,struct VkImage_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetFenceFdKHR)(struct VkDevice_T*,const struct VkFenceGetFdInfoKHR*,int*);
void(vkCmdSetBlendConstants)(struct VkCommandBuffer_T*,const float);
enum VkResult(vkEnumerateDeviceLayerProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkLayerProperties*);
enum VkResult(vkCreateDescriptorUpdateTemplateKHR)(struct VkDevice_T*,const struct VkDescriptorUpdateTemplateCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkDescriptorUpdateTemplateKHR_T**);
void(*vkGetDeviceProcAddr(struct VkDevice_T*,const char*))();
enum VkResult(vkBindImageMemory)(struct VkDevice_T*,struct VkImage_T*,struct VkDeviceMemory_T*,unsigned long);
void(vkDestroyRenderPass)(struct VkDevice_T*,struct VkRenderPass_T*,const struct VkAllocationCallbacks*);
void(vkUnmapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*);
void(vkGetImageMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkImageMemoryRequirementsInfo2KHR*,struct VkMemoryRequirements2KHR*);
enum VkResult(vkEnumerateDeviceExtensionProperties)(struct VkPhysicalDevice_T*,const char*,unsigned int*,struct VkExtensionProperties*);
void(vkGetPhysicalDeviceProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties*);
void(vkSetHdrMetadataEXT)(struct VkDevice_T*,unsigned int,struct VkSwapchainKHR_T*const*,const struct VkHdrMetadataEXT*);
void(vkCmdDispatch)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int);
void(vkGetPhysicalDeviceFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties*);
enum VkResult(vkResetDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int);
enum VkResult(vkWaitForFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*,unsigned int,unsigned long);
void(vkCmdSetLineWidth)(struct VkCommandBuffer_T*,float);
void(vkCmdSetDiscardRectangleEXT)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkRect2D*);
void(vkUpdateDescriptorSetWithTemplateKHR)(struct VkDevice_T*,struct VkDescriptorSet_T*,struct VkDescriptorUpdateTemplateKHR_T*,const void*);
void(vkDestroyDescriptorSetLayout)(struct VkDevice_T*,struct VkDescriptorSetLayout_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkFlushMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
void(vkDestroyDevice)(struct VkDevice_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkFreeDescriptorSets)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int,struct VkDescriptorSet_T*const*);
void(vkCmdDraw)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int);
enum VkResult(vkCreateCommandPool)(struct VkDevice_T*,const struct VkCommandPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkCommandPool_T**);
enum VkResult(vkRegisterDeviceEventEXT)(struct VkDevice_T*,const struct VkDeviceEventInfoEXT*,const struct VkAllocationCallbacks*,struct VkFence_T**);
void(vkGetPhysicalDeviceMemoryProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties*);
enum VkResult(vkAllocateDescriptorSets)(struct VkDevice_T*,const struct VkDescriptorSetAllocateInfo*,struct VkDescriptorSet_T**);
void(vkCmdSetScissor)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkRect2D*);
enum VkResult(vkCreatePipelineLayout)(struct VkDevice_T*,const struct VkPipelineLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineLayout_T**);
enum VkResult(vkQueueBindSparse)(struct VkQueue_T*,unsigned int,const struct VkBindSparseInfo*,struct VkFence_T*);
void(vkUpdateDescriptorSets)(struct VkDevice_T*,unsigned int,const struct VkWriteDescriptorSet*,unsigned int,const struct VkCopyDescriptorSet*);
enum VkResult(vkGetQueryPoolResults)(struct VkDevice_T*,struct VkQueryPool_T*,unsigned int,unsigned int,unsigned long,void*,unsigned long,unsigned int);
void(vkCmdPipelineBarrier)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
enum VkResult(vkResetCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
enum VkResult(vkGetPhysicalDevicePresentRectanglesKHX)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,struct VkRect2D*);
]])
local CLIB = ffi.load(_G.FFI_LIB or "vulkan")
local library = {}
library = {
	GetBufferMemoryRequirements = CLIB.vkGetBufferMemoryRequirements,
	DeviceWaitIdle = CLIB.vkDeviceWaitIdle,
	CreateBufferView = CLIB.vkCreateBufferView,
	CmdCopyImageToBuffer = CLIB.vkCmdCopyImageToBuffer,
	CmdResolveImage = CLIB.vkCmdResolveImage,
	CreateGraphicsPipelines = CLIB.vkCreateGraphicsPipelines,
	CmdSetStencilCompareMask = CLIB.vkCmdSetStencilCompareMask,
	GetPipelineCacheData = CLIB.vkGetPipelineCacheData,
	GetRenderAreaGranularity = CLIB.vkGetRenderAreaGranularity,
	DestroyInstance = CLIB.vkDestroyInstance,
	EnumerateInstanceLayerProperties = CLIB.vkEnumerateInstanceLayerProperties,
	ResetEvent = CLIB.vkResetEvent,
	GetPhysicalDeviceQueueFamilyProperties = CLIB.vkGetPhysicalDeviceQueueFamilyProperties,
	QueueWaitIdle = CLIB.vkQueueWaitIdle,
	EnumeratePhysicalDevices = CLIB.vkEnumeratePhysicalDevices,
	CmdWriteTimestamp = CLIB.vkCmdWriteTimestamp,
	CreateShaderModule = CLIB.vkCreateShaderModule,
	CmdCopyQueryPoolResults = CLIB.vkCmdCopyQueryPoolResults,
	MergePipelineCaches = CLIB.vkMergePipelineCaches,
	CmdSetStencilWriteMask = CLIB.vkCmdSetStencilWriteMask,
	CreateFramebuffer = CLIB.vkCreateFramebuffer,
	CmdResetEvent = CLIB.vkCmdResetEvent,
	BindBufferMemory = CLIB.vkBindBufferMemory,
	CmdSetEvent = CLIB.vkCmdSetEvent,
	CmdBindDescriptorSets = CLIB.vkCmdBindDescriptorSets,
	EnumerateInstanceExtensionProperties = CLIB.vkEnumerateInstanceExtensionProperties,
	CmdSetDepthBounds = CLIB.vkCmdSetDepthBounds,
	CmdDispatchIndirect = CLIB.vkCmdDispatchIndirect,
	DestroyEvent = CLIB.vkDestroyEvent,
	CmdNextSubpass = CLIB.vkCmdNextSubpass,
	CmdCopyBuffer = CLIB.vkCmdCopyBuffer,
	DestroyBuffer = CLIB.vkDestroyBuffer,
	CmdCopyImage = CLIB.vkCmdCopyImage,
	GetPhysicalDeviceSparseImageFormatProperties = CLIB.vkGetPhysicalDeviceSparseImageFormatProperties,
	CreateComputePipelines = CLIB.vkCreateComputePipelines,
	CreateQueryPool = CLIB.vkCreateQueryPool,
	CreateDescriptorSetLayout = CLIB.vkCreateDescriptorSetLayout,
	ResetFences = CLIB.vkResetFences,
	AllocateCommandBuffers = CLIB.vkAllocateCommandBuffers,
	DestroyQueryPool = CLIB.vkDestroyQueryPool,
	CreateDescriptorPool = CLIB.vkCreateDescriptorPool,
	GetImageSubresourceLayout = CLIB.vkGetImageSubresourceLayout,
	CmdUpdateBuffer = CLIB.vkCmdUpdateBuffer,
	CreateEvent = CLIB.vkCreateEvent,
	CmdSetStencilReference = CLIB.vkCmdSetStencilReference,
	EndCommandBuffer = CLIB.vkEndCommandBuffer,
	CreateBuffer = CLIB.vkCreateBuffer,
	FreeCommandBuffers = CLIB.vkFreeCommandBuffers,
	CmdSetViewport = CLIB.vkCmdSetViewport,
	GetFenceStatus = CLIB.vkGetFenceStatus,
	CmdBeginQuery = CLIB.vkCmdBeginQuery,
	DestroyPipeline = CLIB.vkDestroyPipeline,
	QueueSubmit = CLIB.vkQueueSubmit,
	CmdBlitImage = CLIB.vkCmdBlitImage,
	CmdDrawIndexedIndirect = CLIB.vkCmdDrawIndexedIndirect,
	CmdSetDepthBias = CLIB.vkCmdSetDepthBias,
	CreateSemaphore = CLIB.vkCreateSemaphore,
	DestroyShaderModule = CLIB.vkDestroyShaderModule,
	CreatePipelineCache = CLIB.vkCreatePipelineCache,
	CreateImageView = CLIB.vkCreateImageView,
	GetPhysicalDeviceFeatures = CLIB.vkGetPhysicalDeviceFeatures,
	DestroyPipelineLayout = CLIB.vkDestroyPipelineLayout,
	DestroySampler = CLIB.vkDestroySampler,
	FreeMemory = CLIB.vkFreeMemory,
	GetPhysicalDeviceImageFormatProperties = CLIB.vkGetPhysicalDeviceImageFormatProperties,
	MapMemory = CLIB.vkMapMemory,
	DestroyFramebuffer = CLIB.vkDestroyFramebuffer,
	GetDeviceMemoryCommitment = CLIB.vkGetDeviceMemoryCommitment,
	CmdCopyBufferToImage = CLIB.vkCmdCopyBufferToImage,
	CmdBindVertexBuffers = CLIB.vkCmdBindVertexBuffers,
	CmdResetQueryPool = CLIB.vkCmdResetQueryPool,
	DestroyCommandPool = CLIB.vkDestroyCommandPool,
	DestroyDescriptorPool = CLIB.vkDestroyDescriptorPool,
	InvalidateMappedMemoryRanges = CLIB.vkInvalidateMappedMemoryRanges,
	CmdBindPipeline = CLIB.vkCmdBindPipeline,
	DestroyBufferView = CLIB.vkDestroyBufferView,
	GetImageSparseMemoryRequirements = CLIB.vkGetImageSparseMemoryRequirements,
	DestroyImageView = CLIB.vkDestroyImageView,
	ResetCommandBuffer = CLIB.vkResetCommandBuffer,
	CmdDrawIndirect = CLIB.vkCmdDrawIndirect,
	DestroySemaphore = CLIB.vkDestroySemaphore,
	CreateSampler = CLIB.vkCreateSampler,
	DestroyPipelineCache = CLIB.vkDestroyPipelineCache,
	GetInstanceProcAddr = CLIB.vkGetInstanceProcAddr,
	GetImageMemoryRequirements = CLIB.vkGetImageMemoryRequirements,
	SetEvent = CLIB.vkSetEvent,
	GetEventStatus = CLIB.vkGetEventStatus,
	CreateDevice = CLIB.vkCreateDevice,
	CreateInstance = CLIB.vkCreateInstance,
	CmdClearDepthStencilImage = CLIB.vkCmdClearDepthStencilImage,
	CmdEndRenderPass = CLIB.vkCmdEndRenderPass,
	BeginCommandBuffer = CLIB.vkBeginCommandBuffer,
	CmdDrawIndexed = CLIB.vkCmdDrawIndexed,
	CmdFillBuffer = CLIB.vkCmdFillBuffer,
	GetDeviceQueue = CLIB.vkGetDeviceQueue,
	CmdWaitEvents = CLIB.vkCmdWaitEvents,
	DestroyFence = CLIB.vkDestroyFence,
	CreateImage = CLIB.vkCreateImage,
	AllocateMemory = CLIB.vkAllocateMemory,
	CmdClearColorImage = CLIB.vkCmdClearColorImage,
	CmdExecuteCommands = CLIB.vkCmdExecuteCommands,
	CmdBeginRenderPass = CLIB.vkCmdBeginRenderPass,
	CmdClearAttachments = CLIB.vkCmdClearAttachments,
	CmdPushConstants = CLIB.vkCmdPushConstants,
	CmdEndQuery = CLIB.vkCmdEndQuery,
	CreateFence = CLIB.vkCreateFence,
	CmdBindIndexBuffer = CLIB.vkCmdBindIndexBuffer,
	CreateRenderPass = CLIB.vkCreateRenderPass,
	DestroyImage = CLIB.vkDestroyImage,
	CmdSetBlendConstants = CLIB.vkCmdSetBlendConstants,
	EnumerateDeviceLayerProperties = CLIB.vkEnumerateDeviceLayerProperties,
	GetDeviceProcAddr = CLIB.vkGetDeviceProcAddr,
	BindImageMemory = CLIB.vkBindImageMemory,
	DestroyRenderPass = CLIB.vkDestroyRenderPass,
	UnmapMemory = CLIB.vkUnmapMemory,
	EnumerateDeviceExtensionProperties = CLIB.vkEnumerateDeviceExtensionProperties,
	GetPhysicalDeviceProperties = CLIB.vkGetPhysicalDeviceProperties,
	CmdDispatch = CLIB.vkCmdDispatch,
	GetPhysicalDeviceFormatProperties = CLIB.vkGetPhysicalDeviceFormatProperties,
	ResetDescriptorPool = CLIB.vkResetDescriptorPool,
	WaitForFences = CLIB.vkWaitForFences,
	CmdSetLineWidth = CLIB.vkCmdSetLineWidth,
	DestroyDescriptorSetLayout = CLIB.vkDestroyDescriptorSetLayout,
	FlushMappedMemoryRanges = CLIB.vkFlushMappedMemoryRanges,
	DestroyDevice = CLIB.vkDestroyDevice,
	FreeDescriptorSets = CLIB.vkFreeDescriptorSets,
	CmdDraw = CLIB.vkCmdDraw,
	CreateCommandPool = CLIB.vkCreateCommandPool,
	GetPhysicalDeviceMemoryProperties = CLIB.vkGetPhysicalDeviceMemoryProperties,
	AllocateDescriptorSets = CLIB.vkAllocateDescriptorSets,
	CmdSetScissor = CLIB.vkCmdSetScissor,
	CreatePipelineLayout = CLIB.vkCreatePipelineLayout,
	QueueBindSparse = CLIB.vkQueueBindSparse,
	UpdateDescriptorSets = CLIB.vkUpdateDescriptorSets,
	GetQueryPoolResults = CLIB.vkGetQueryPoolResults,
	CmdPipelineBarrier = CLIB.vkCmdPipelineBarrier,
	ResetCommandPool = CLIB.vkResetCommandPool,
}
library.util = {}
function library.util.StringList(tbl)
	return ffi.new("const char * const ["..#tbl.."]", tbl), #tbl
end
function library.util.GLSLToSpirV(type, glsl)
	local glsl_name = os.tmpname() .. "." .. type
	local spirv_name = os.tmpname()

	local temp

	temp = io.open(glsl_name, "wb")
	temp:write(glsl)
	temp:close()

	local msg = io.popen("glslangValidator -V -o " .. spirv_name .. " " .. glsl_name):read("*all")

	temp = io.open(spirv_name, "rb")
	local spirv = temp:read("*all")
	temp:close()

	if msg:find("ERROR") then
		error(msg, 2)
	end

	return {pCode = ffi.cast("uint32_t *", spirv), codeSize = #spirv}
end
function library.Assert(var, res)
	if var == nil and res ~= "VK_SUCCESS" then
		for name, v in pairs(library.e.result) do
			if res == v then
				name = name:gsub("error_", "")
				name = name:gsub("_", " ")
				error("Assertion failed: " .. name, 2)
				break
			end
		end
	end

	return var
end
function library.e(str_enum)
	return ffi.cast("enum GLFWenum", str_enum)
end
library.struct_gc = setmetatable({},{__mode = "k"})
library.macros = {}
library.macros.MAKE_VERSION = function(major, minor, patch) return bit.bor(bit.lshift(major, 22), bit.lshift(minor, 12) , patch) end
local extensions = {}
extensions.vkDestroyObjectTableNVX = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkDeviceGeneratedCommandsFeaturesNVX * , struct VkDeviceGeneratedCommandsLimitsNVX * )")}
extensions.vkRegisterDisplayEventEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayEventInfoEXT * , const struct VkAllocationCallbacks * , struct VkFence_T * * )")}
extensions.vkImportFenceFdKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkImportFenceFdInfoKHR * )")}
extensions.vkGetPhysicalDeviceSurfaceCapabilities2EXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , struct VkSurfaceCapabilities2EXT * )")}
extensions.vkGetPhysicalDeviceImageFormatProperties2KHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceImageFormatInfo2KHR * , struct VkImageFormatProperties2KHR * )")}
extensions.vkGetPhysicalDeviceFormatProperties2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , enum VkFormat , struct VkFormatProperties2KHR * )")}
extensions.vkCmdSetViewportWScalingNV = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , const struct VkViewportWScalingNV * )")}
extensions.vkDestroySurfaceKHR = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , struct VkSurfaceKHR_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetMemoryFdKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkMemoryGetFdInfoKHR * , int * )")}
extensions.vkGetPhysicalDeviceQueueFamilyProperties2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkQueueFamilyProperties2KHR * )")}
extensions.vkRegisterObjectsNVX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , unsigned int , const struct VkObjectTableEntryNVX * const * , const unsigned int * )")}
extensions.vkCmdDrawIndirectCountAMD = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )")}
extensions.vkGetDisplayPlaneSupportedDisplaysKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , unsigned int * , struct VkDisplayKHR_T * * )")}
extensions.vkEnumeratePhysicalDeviceGroupsKHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkInstance_T * , unsigned int * , struct VkPhysicalDeviceGroupPropertiesKHX * )")}
extensions.vkDestroyIndirectCommandsLayoutNVX = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkIndirectCommandsLayoutNVX_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetPastPresentationTimingGOOGLE = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned int * , struct VkPastPresentationTimingGOOGLE * )")}
extensions.vkGetPhysicalDeviceSurfaceFormatsKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , struct VkSurfaceFormatKHR * )")}
extensions.vkGetRefreshCycleDurationGOOGLE = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , struct VkRefreshCycleDurationGOOGLE * )")}
extensions.vkGetSwapchainCounterEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , enum VkSurfaceCounterFlagBitsEXT , unsigned long * )")}
extensions.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalSemaphoreInfoKHR * , struct VkExternalSemaphorePropertiesKHR * )")}
extensions.vkDisplayPowerControlEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayPowerInfoEXT * )")}
extensions.vkUnregisterObjectsNVX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , unsigned int , const enum VkObjectEntryTypeNVX * , const unsigned int * )")}
extensions.vkCreateObjectTableNVX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkObjectTableCreateInfoNVX * , const struct VkAllocationCallbacks * , struct VkObjectTableNVX_T * * )")}
extensions.vkCreateIndirectCommandsLayoutNVX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkIndirectCommandsLayoutCreateInfoNVX * , const struct VkAllocationCallbacks * , struct VkIndirectCommandsLayoutNVX_T * * )")}
extensions.vkCmdReserveSpaceForCommandsNVX = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkCmdReserveSpaceForCommandsInfoNVX * )")}
extensions.vkCmdDispatchBaseKHX = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int )")}
extensions.vkDestroyDebugReportCallbackEXT = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , struct VkDebugReportCallbackEXT_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetImageSparseMemoryRequirements2KHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , const struct VkImageSparseMemoryRequirementsInfo2KHR * , unsigned int * , struct VkSparseImageMemoryRequirements2KHR * )")}
extensions.vkCmdProcessCommandsNVX = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkCmdProcessCommandsInfoNVX * )")}
extensions.vkGetPhysicalDeviceSurfaceCapabilitiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , struct VkSurfaceCapabilitiesKHR * )")}
extensions.vkCreateSwapchainKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )")}
extensions.vkGetPhysicalDeviceFeatures2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceFeatures2KHR * )")}
extensions.vkBindImageMemory2KHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkBindImageMemoryInfoKHX * )")}
extensions.vkGetDeviceGroupPresentCapabilitiesKHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkDeviceGroupPresentCapabilitiesKHX * )")}
extensions.vkTrimCommandPoolKHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkCommandPool_T * , unsigned int )")}
extensions.vkCmdSetDeviceMaskKHX = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , unsigned int )")}
extensions.vkGetDeviceGroupSurfacePresentModesKHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSurfaceKHR_T * , unsigned int * )")}
extensions.vkGetPhysicalDeviceSurfaceSupportKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , struct VkSurfaceKHR_T * , unsigned int * )")}
extensions.vkGetSwapchainStatusKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * )")}
extensions.vkGetDeviceGroupPeerMemoryFeaturesKHX = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , unsigned int , unsigned int , unsigned int , unsigned int * )")}
extensions.vkGetPhysicalDeviceSparseImageFormatProperties2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSparseImageFormatInfo2KHR * , unsigned int * , struct VkSparseImageFormatProperties2KHR * )")}
extensions.vkGetPhysicalDeviceExternalImageFormatPropertiesNV = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , enum VkFormat , enum VkImageType , enum VkImageTiling , unsigned int , unsigned int , unsigned int , struct VkExternalImageFormatPropertiesNV * )")}
extensions.vkGetPhysicalDeviceExternalFencePropertiesKHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalFenceInfoKHR * , struct VkExternalFencePropertiesKHR * )")}
extensions.vkDestroySwapchainKHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetPhysicalDeviceMemoryProperties2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceMemoryProperties2KHR * )")}
extensions.vkCmdDebugMarkerEndEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * )")}
extensions.vkCmdDebugMarkerBeginEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkDebugMarkerMarkerInfoEXT * )")}
extensions.vkDebugMarkerSetObjectTagEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkDebugMarkerObjectTagInfoEXT * )")}
extensions.vkDebugReportMessageEXT = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , unsigned int , enum VkDebugReportObjectTypeEXT , unsigned long , unsigned long , int , const char * , const char * )")}
extensions.vkCmdPushDescriptorSetWithTemplateKHR = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkDescriptorUpdateTemplateKHR_T * , struct VkPipelineLayout_T * , unsigned int , const void * )")}
extensions.vkCreateDebugReportCallbackEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkInstance_T * , const struct VkDebugReportCallbackCreateInfoEXT * , const struct VkAllocationCallbacks * , struct VkDebugReportCallbackEXT_T * * )")}
extensions.vkGetBufferMemoryRequirements2KHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , const struct VkBufferMemoryRequirementsInfo2KHR * , struct VkMemoryRequirements2KHR * )")}
extensions.vkGetPhysicalDeviceSurfaceFormats2KHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSurfaceInfo2KHR * , unsigned int * , struct VkSurfaceFormat2KHR * )")}
extensions.vkGetPhysicalDeviceExternalBufferPropertiesKHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalBufferInfoKHR * , struct VkExternalBufferPropertiesKHR * )")}
extensions.vkGetDisplayPlaneCapabilitiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayModeKHR_T * , unsigned int , struct VkDisplayPlaneCapabilitiesKHR * )")}
extensions.vkBindBufferMemory2KHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkBindBufferMemoryInfoKHX * )")}
extensions.vkDestroyDescriptorUpdateTemplateKHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkDescriptorUpdateTemplateKHR_T * , const struct VkAllocationCallbacks * )")}
extensions.vkCmdPushDescriptorSetKHR = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , enum VkPipelineBindPoint , struct VkPipelineLayout_T * , unsigned int , unsigned int , const struct VkWriteDescriptorSet * )")}
extensions.vkGetSemaphoreFdKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkSemaphoreGetFdInfoKHR * , int * )")}
extensions.vkImportSemaphoreFdKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkImportSemaphoreFdInfoKHR * )")}
extensions.vkGetPhysicalDeviceSurfaceCapabilities2KHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSurfaceInfo2KHR * , struct VkSurfaceCapabilities2KHR * )")}
extensions.vkCmdDebugMarkerInsertEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkDebugMarkerMarkerInfoEXT * )")}
extensions.vkGetPhysicalDeviceDisplayPlanePropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPlanePropertiesKHR * )")}
extensions.vkGetPhysicalDeviceProperties2KHR = {ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceProperties2KHR * )")}
extensions.vkCreateSharedSwapchainsKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )")}
extensions.vkCreateDisplayPlaneSurfaceKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkInstance_T * , const struct VkDisplaySurfaceCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSurfaceKHR_T * * )")}
extensions.vkGetMemoryFdPropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , enum VkExternalMemoryHandleTypeFlagBitsKHR , int , struct VkMemoryFdPropertiesKHR * )")}
extensions.vkCmdDrawIndexedIndirectCountAMD = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )")}
extensions.vkGetPhysicalDeviceDisplayPropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPropertiesKHR * )")}
extensions.vkQueuePresentKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkQueue_T * , const struct VkPresentInfoKHR * )")}
extensions.vkAcquireNextImageKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned long , struct VkSemaphore_T * , struct VkFence_T * , unsigned int * )")}
extensions.vkGetSwapchainImagesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned int * , struct VkImage_T * * )")}
extensions.vkGetDisplayModePropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , unsigned int * , struct VkDisplayModePropertiesKHR * )")}
extensions.vkAcquireNextImage2KHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkAcquireNextImageInfoKHX * , unsigned int * )")}
extensions.vkGetPhysicalDeviceSurfacePresentModesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , enum VkPresentModeKHR * )")}
extensions.vkCreateDisplayModeKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayModeCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkDisplayModeKHR_T * * )")}
extensions.vkDebugMarkerSetObjectNameEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkDebugMarkerObjectNameInfoEXT * )")}
extensions.vkReleaseDisplayEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * )")}
extensions.vkGetFenceFdKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkFenceGetFdInfoKHR * , int * )")}
extensions.vkCreateDescriptorUpdateTemplateKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkDescriptorUpdateTemplateCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkDescriptorUpdateTemplateKHR_T * * )")}
extensions.vkGetImageMemoryRequirements2KHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , const struct VkImageMemoryRequirementsInfo2KHR * , struct VkMemoryRequirements2KHR * )")}
extensions.vkSetHdrMetadataEXT = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , unsigned int , struct VkSwapchainKHR_T * const * , const struct VkHdrMetadataEXT * )")}
extensions.vkCmdSetDiscardRectangleEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , const struct VkRect2D * )")}
extensions.vkUpdateDescriptorSetWithTemplateKHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkDescriptorSet_T * , struct VkDescriptorUpdateTemplateKHR_T * , const void * )")}
extensions.vkRegisterDeviceEventEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkDeviceEventInfoEXT * , const struct VkAllocationCallbacks * , struct VkFence_T * * )")}
extensions.vkGetPhysicalDevicePresentRectanglesKHX = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , struct VkRect2D * )")}
local function load(func, ptr, ext, decl, name)
	if extensions[ext] and not decl and not name then
		decl = extensions[ext].ctype
	end

	local ptr = func(ptr, ext)

	if ptr ~= nil then
		name = name or ext:match("^vk(.+)")

		local func = ffi.cast(decl, ptr)

		library[name] = func

		return func
	end
end

library.util.LoadInstanceProcAddr = function(...) return load(CLIB.vkGetInstanceProcAddr, ...) end
library.util.LoadDeviceProcAddr = function(...) return load(CLIB.vkGetDeviceProcAddr, ...) end
library.e = {
	LOD_CLAMP_NONE = 1000.0,
	REMAINING_MIP_LEVELS = 0xFFFFFFFF,
	REMAINING_ARRAY_LAYERS = 0xFFFFFFFF,
	WHOLE_SIZE = 0xFFFFFFFFFFFFFFFFULL,
	ATTACHMENT_UNUSED = 0xFFFFFFFF,
	TRUE = 1,
	FALSE = 0,
	QUEUE_FAMILY_IGNORED = 0xFFFFFFFF,
	SUBPASS_EXTERNAL = 0xFFFFFFFF,
	MAX_PHYSICAL_DEVICE_NAME_SIZE = 256,
	UUID_SIZE = 16,
	MAX_MEMORY_TYPES = 32,
	MAX_MEMORY_HEAPS = 16,
	MAX_EXTENSION_NAME_SIZE = 256,
	MAX_DESCRIPTION_SIZE = 256,
	DYNAMIC_STATE_VIEWPORT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
	DYNAMIC_STATE_SCISSOR = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
	DYNAMIC_STATE_LINE_WIDTH = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
	DYNAMIC_STATE_DEPTH_BIAS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
	DYNAMIC_STATE_BLEND_CONSTANTS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
	DYNAMIC_STATE_DEPTH_BOUNDS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
	DYNAMIC_STATE_STENCIL_COMPARE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
	DYNAMIC_STATE_STENCIL_WRITE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
	DYNAMIC_STATE_STENCIL_REFERENCE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
	DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
	DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
	DYNAMIC_STATE_BEGIN_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
	DYNAMIC_STATE_END_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
	DYNAMIC_STATE_RANGE_SIZE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	DYNAMIC_STATE_MAX_ENUM = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
	OBJECT_TYPE_UNKNOWN = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_UNKNOWN"),
	OBJECT_TYPE_INSTANCE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INSTANCE"),
	OBJECT_TYPE_PHYSICAL_DEVICE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
	OBJECT_TYPE_DEVICE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE"),
	OBJECT_TYPE_QUEUE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUEUE"),
	OBJECT_TYPE_SEMAPHORE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SEMAPHORE"),
	OBJECT_TYPE_COMMAND_BUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_BUFFER"),
	OBJECT_TYPE_FENCE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FENCE"),
	OBJECT_TYPE_DEVICE_MEMORY = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE_MEMORY"),
	OBJECT_TYPE_BUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER"),
	OBJECT_TYPE_IMAGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE"),
	OBJECT_TYPE_EVENT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_EVENT"),
	OBJECT_TYPE_QUERY_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUERY_POOL"),
	OBJECT_TYPE_BUFFER_VIEW = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER_VIEW"),
	OBJECT_TYPE_IMAGE_VIEW = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE_VIEW"),
	OBJECT_TYPE_SHADER_MODULE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SHADER_MODULE"),
	OBJECT_TYPE_PIPELINE_CACHE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_CACHE"),
	OBJECT_TYPE_PIPELINE_LAYOUT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
	OBJECT_TYPE_RENDER_PASS = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RENDER_PASS"),
	OBJECT_TYPE_PIPELINE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE"),
	OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
	OBJECT_TYPE_SAMPLER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER"),
	OBJECT_TYPE_DESCRIPTOR_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
	OBJECT_TYPE_DESCRIPTOR_SET = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET"),
	OBJECT_TYPE_FRAMEBUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FRAMEBUFFER"),
	OBJECT_TYPE_COMMAND_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_POOL"),
	OBJECT_TYPE_SURFACE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SURFACE_KHR"),
	OBJECT_TYPE_SWAPCHAIN_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
	OBJECT_TYPE_DISPLAY_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_KHR"),
	OBJECT_TYPE_DISPLAY_MODE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
	OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
	OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR"),
	OBJECT_TYPE_OBJECT_TABLE_NVX = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_OBJECT_TABLE_NVX"),
	OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX"),
	OBJECT_TYPE_BEGIN_RANGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BEGIN_RANGE"),
	OBJECT_TYPE_END_RANGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_END_RANGE"),
	OBJECT_TYPE_RANGE_SIZE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RANGE_SIZE"),
	OBJECT_TYPE_MAX_ENUM = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_MAX_ENUM"),
	IMAGE_LAYOUT_UNDEFINED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
	IMAGE_LAYOUT_GENERAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
	IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
	IMAGE_LAYOUT_PREINITIALIZED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
	IMAGE_LAYOUT_PRESENT_SRC_KHR = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
	IMAGE_LAYOUT_SHARED_PRESENT_KHR = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
	IMAGE_LAYOUT_BEGIN_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
	IMAGE_LAYOUT_END_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
	IMAGE_LAYOUT_RANGE_SIZE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
	IMAGE_LAYOUT_MAX_ENUM = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
	SAMPLER_MIPMAP_MODE_NEAREST = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
	SAMPLER_MIPMAP_MODE_LINEAR = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
	SAMPLER_MIPMAP_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
	SAMPLER_MIPMAP_MODE_END_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
	SAMPLER_MIPMAP_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	SAMPLER_MIPMAP_MODE_MAX_ENUM = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
	INDEX_TYPE_UINT16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
	INDEX_TYPE_UINT32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
	INDEX_TYPE_BEGIN_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
	INDEX_TYPE_END_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
	INDEX_TYPE_RANGE_SIZE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	INDEX_TYPE_MAX_ENUM = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
	CULL_MODE_NONE = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
	CULL_MODE_FRONT_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
	CULL_MODE_BACK_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
	CULL_MODE_FRONT_AND_BACK = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	CULL_MODE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
	OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX"),
	OBJECT_ENTRY_TYPE_PIPELINE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX"),
	OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX"),
	OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX"),
	OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX"),
	OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX"),
	OBJECT_ENTRY_TYPE_END_RANGE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX"),
	OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX"),
	OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX"),
	PIPELINE_STAGE_TOP_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
	PIPELINE_STAGE_DRAW_INDIRECT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
	PIPELINE_STAGE_VERTEX_INPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
	PIPELINE_STAGE_VERTEX_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
	PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
	PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
	PIPELINE_STAGE_GEOMETRY_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
	PIPELINE_STAGE_FRAGMENT_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
	PIPELINE_STAGE_COMPUTE_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
	PIPELINE_STAGE_TRANSFER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
	PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
	PIPELINE_STAGE_HOST_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
	PIPELINE_STAGE_ALL_GRAPHICS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
	PIPELINE_STAGE_ALL_COMMANDS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
	PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"),
	PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
	IMAGE_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
	IMAGE_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
	IMAGE_USAGE_SAMPLED_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
	IMAGE_USAGE_STORAGE_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	IMAGE_USAGE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
	IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
	IMAGE_USAGE_INPUT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
	IMAGE_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
	COMMAND_POOL_CREATE_TRANSIENT_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
	COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
	COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
	DEPENDENCY_BY_REGION_BIT = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	DEPENDENCY_VIEW_LOCAL_BIT_KHX = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX"),
	DEPENDENCY_DEVICE_GROUP_BIT_KHX = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX"),
	DEPENDENCY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
	SYSTEM_ALLOCATION_SCOPE_COMMAND = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
	SYSTEM_ALLOCATION_SCOPE_OBJECT = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
	SYSTEM_ALLOCATION_SCOPE_CACHE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
	SYSTEM_ALLOCATION_SCOPE_DEVICE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
	SYSTEM_ALLOCATION_SCOPE_INSTANCE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
	SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_END_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
	SURFACE_COUNTER_VBLANK_EXT = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_VBLANK_EXT"),
	SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT"),
	FILTER_NEAREST = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
	FILTER_LINEAR = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
	FILTER_CUBIC_IMG = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
	FILTER_BEGIN_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
	FILTER_END_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
	FILTER_RANGE_SIZE = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	FILTER_MAX_ENUM = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
	BUFFER_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
	BUFFER_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_UNIFORM_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
	BUFFER_USAGE_INDEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
	BUFFER_USAGE_VERTEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
	BUFFER_USAGE_INDIRECT_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
	BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX"),
	DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
	PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
	PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
	PIPELINE_CREATE_DERIVATIVE_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
	PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX"),
	PIPELINE_CREATE_DISPATCH_BASE_KHX = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISPATCH_BASE_KHX"),
	PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
	COVERAGE_MODULATION_MODE_NONE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_NONE_NV"),
	COVERAGE_MODULATION_MODE_RGB_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGB_NV"),
	COVERAGE_MODULATION_MODE_ALPHA_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
	COVERAGE_MODULATION_MODE_RGBA_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
	COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV"),
	COVERAGE_MODULATION_MODE_END_RANGE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_END_RANGE_NV"),
	COVERAGE_MODULATION_MODE_RANGE_SIZE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV"),
	COVERAGE_MODULATION_MODE_MAX_ENUM_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV"),
	DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
	IMAGE_VIEW_TYPE_1D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
	IMAGE_VIEW_TYPE_2D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
	IMAGE_VIEW_TYPE_3D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
	IMAGE_VIEW_TYPE_CUBE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
	IMAGE_VIEW_TYPE_1D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	IMAGE_VIEW_TYPE_2D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
	IMAGE_VIEW_TYPE_CUBE_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
	IMAGE_VIEW_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
	IMAGE_VIEW_TYPE_END_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
	IMAGE_VIEW_TYPE_RANGE_SIZE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
	IMAGE_VIEW_TYPE_MAX_ENUM = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
	QUERY_CONTROL_PRECISE_BIT = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	QUERY_CONTROL_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
	ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
	PIPELINE_CACHE_HEADER_VERSION_ONE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
	PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"),
	PIPELINE_CACHE_HEADER_VERSION_END_RANGE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
	PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"),
	PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
	DEBUG_REPORT_INFORMATION_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	DEBUG_REPORT_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
	DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
	DEBUG_REPORT_ERROR_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
	DEBUG_REPORT_DEBUG_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
	DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
	PRIMITIVE_TOPOLOGY_POINT_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
	PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_PATCH_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	PRIMITIVE_TOPOLOGY_BEGIN_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
	PRIMITIVE_TOPOLOGY_END_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
	PRIMITIVE_TOPOLOGY_RANGE_SIZE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
	PRIMITIVE_TOPOLOGY_MAX_ENUM = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
	DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = ffi.cast("enum VkDescriptorSetLayoutCreateFlagBits", "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"),
	DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDescriptorSetLayoutCreateFlagBits", "VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM"),
	DISPLAY_POWER_STATE_OFF_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_OFF_EXT"),
	DISPLAY_POWER_STATE_SUSPEND_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
	DISPLAY_POWER_STATE_ON_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_ON_EXT"),
	DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT"),
	DISPLAY_POWER_STATE_END_RANGE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_END_RANGE_EXT"),
	DISPLAY_POWER_STATE_RANGE_SIZE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT"),
	DISPLAY_POWER_STATE_MAX_ENUM_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT"),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = ffi.cast("enum VkExternalMemoryFeatureFlagBitsKHR", "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR"),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast("enum VkExternalMemoryFeatureFlagBitsKHR", "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR"),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast("enum VkExternalMemoryFeatureFlagBitsKHR", "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR"),
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalMemoryFeatureFlagBitsKHR", "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHR"),
	SURFACE_TRANSFORM_IDENTITY_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
	SURFACE_TRANSFORM_INHERIT_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
	SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"),
	FENCE_IMPORT_TEMPORARY_BIT_KHR = ffi.cast("enum VkFenceImportFlagBitsKHR", "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR"),
	FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkFenceImportFlagBitsKHR", "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR"),
	COMPARE_OP_NEVER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
	COMPARE_OP_LESS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
	COMPARE_OP_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
	COMPARE_OP_LESS_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
	COMPARE_OP_GREATER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
	COMPARE_OP_NOT_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
	COMPARE_OP_GREATER_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
	COMPARE_OP_ALWAYS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
	COMPARE_OP_BEGIN_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
	COMPARE_OP_END_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
	COMPARE_OP_RANGE_SIZE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	COMPARE_OP_MAX_ENUM = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
	SHADER_STAGE_VERTEX_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
	SHADER_STAGE_TESSELLATION_CONTROL_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
	SHADER_STAGE_TESSELLATION_EVALUATION_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
	SHADER_STAGE_GEOMETRY_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
	SHADER_STAGE_FRAGMENT_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
	SHADER_STAGE_COMPUTE_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
	SHADER_STAGE_ALL_GRAPHICS = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
	SHADER_STAGE_ALL = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
	SHADER_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
	SUCCESS = ffi.cast("enum VkResult", "VK_SUCCESS"),
	NOT_READY = ffi.cast("enum VkResult", "VK_NOT_READY"),
	TIMEOUT = ffi.cast("enum VkResult", "VK_TIMEOUT"),
	EVENT_SET = ffi.cast("enum VkResult", "VK_EVENT_SET"),
	EVENT_RESET = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
	INCOMPLETE = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
	ERROR_OUT_OF_HOST_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
	ERROR_OUT_OF_DEVICE_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
	ERROR_INITIALIZATION_FAILED = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
	ERROR_DEVICE_LOST = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
	ERROR_MEMORY_MAP_FAILED = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
	ERROR_LAYER_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
	ERROR_EXTENSION_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
	ERROR_FEATURE_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
	ERROR_INCOMPATIBLE_DRIVER = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
	ERROR_TOO_MANY_OBJECTS = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
	ERROR_FORMAT_NOT_SUPPORTED = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
	ERROR_FRAGMENTED_POOL = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
	ERROR_SURFACE_LOST_KHR = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
	ERROR_NATIVE_WINDOW_IN_USE_KHR = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
	SUBOPTIMAL_KHR = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
	ERROR_OUT_OF_DATE_KHR = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
	ERROR_INCOMPATIBLE_DISPLAY_KHR = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
	ERROR_VALIDATION_FAILED_EXT = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
	ERROR_INVALID_SHADER_NV = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
	ERROR_OUT_OF_POOL_MEMORY_KHR = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_POOL_MEMORY_KHR"),
	ERROR_INVALID_EXTERNAL_HANDLE_KHR = ffi.cast("enum VkResult", "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR"),
	RESULT_BEGIN_RANGE = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
	RESULT_END_RANGE = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
	RESULT_RANGE_SIZE = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
	RESULT_MAX_ENUM = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
	SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX"),
	SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR"),
	FENCE_CREATE_SIGNALED_BIT = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
	FENCE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	IMAGE_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
	IMAGE_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	IMAGE_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
	IMAGE_CREATE_MUTABLE_FORMAT_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
	IMAGE_CREATE_CUBE_COMPATIBLE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
	IMAGE_CREATE_BIND_SFR_BIT_KHX = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_BIND_SFR_BIT_KHX"),
	IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR"),
	IMAGE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
	SAMPLE_COUNT_1_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
	SAMPLE_COUNT_2_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
	SAMPLE_COUNT_4_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
	SAMPLE_COUNT_8_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
	SAMPLE_COUNT_16_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	SAMPLE_COUNT_32_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
	SAMPLE_COUNT_64_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
	SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
	QUERY_RESULT_64_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
	QUERY_RESULT_WAIT_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	QUERY_RESULT_WITH_AVAILABILITY_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
	QUERY_RESULT_PARTIAL_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
	QUERY_RESULT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
	PRESENT_MODE_IMMEDIATE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
	PRESENT_MODE_MAILBOX_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
	PRESENT_MODE_FIFO_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
	PRESENT_MODE_FIFO_RELAXED_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
	PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
	PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
	PRESENT_MODE_BEGIN_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
	PRESENT_MODE_END_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
	PRESENT_MODE_RANGE_SIZE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	PRESENT_MODE_MAX_ENUM_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR"),
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR"),
	ACCESS_INDIRECT_COMMAND_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
	ACCESS_INDEX_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
	ACCESS_VERTEX_ATTRIBUTE_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
	ACCESS_UNIFORM_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
	ACCESS_INPUT_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
	ACCESS_SHADER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
	ACCESS_SHADER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
	ACCESS_COLOR_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
	ACCESS_COLOR_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
	ACCESS_TRANSFER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	ACCESS_TRANSFER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
	ACCESS_HOST_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
	ACCESS_HOST_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
	ACCESS_MEMORY_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
	ACCESS_MEMORY_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
	ACCESS_COMMAND_PROCESS_READ_BIT_NVX = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"),
	ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"),
	ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
	ACCESS_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"),
	DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
	DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
	FORMAT_FEATURE_SAMPLED_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
	FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
	FORMAT_FEATURE_VERTEX_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
	FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	FORMAT_FEATURE_BLIT_SRC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
	FORMAT_FEATURE_BLIT_DST_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"),
	FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR"),
	FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT"),
	FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
	SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"),
	SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"),
	SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
	COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
	MEMORY_HEAP_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
	MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX"),
	MEMORY_HEAP_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
	OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"),
	OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"),
	OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX"),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV"),
	VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV"),
	BUFFER_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
	BUFFER_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	BUFFER_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
	BUFFER_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
	DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
	DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT"),
	DISPLAY_EVENT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT"),
	DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT"),
	DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT"),
	STRUCTURE_TYPE_APPLICATION_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
	STRUCTURE_TYPE_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_SUBMIT_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
	STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
	STRUCTURE_TYPE_BIND_SPARSE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
	STRUCTURE_TYPE_FENCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
	STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
	STRUCTURE_TYPE_EVENT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
	STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_SAMPLER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
	STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
	STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
	STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
	STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
	STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR"),
	STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR"),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX"),
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX"),
	STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX"),
	STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX"),
	STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
	STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX"),
	STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"),
	STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"),
	STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
	STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
	STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"),
	STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
	STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
	STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR"),
	STRUCTURE_TYPE_PRESENT_REGIONS_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
	STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"),
	STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"),
	STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"),
	STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"),
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"),
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT"),
	STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
	STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
	STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
	STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
	STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_HDR_METADATA_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
	STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"),
	STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
	STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
	STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
	STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"),
	STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
	STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
	STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"),
	STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"),
	STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR"),
	STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
	STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
	STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR"),
	STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_BEGIN_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
	STRUCTURE_TYPE_END_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
	STRUCTURE_TYPE_RANGE_SIZE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
	STRUCTURE_TYPE_MAX_ENUM = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
	INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"),
	INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"),
	INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"),
	INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"),
	INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX"),
	VERTEX_INPUT_RATE_VERTEX = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
	VERTEX_INPUT_RATE_INSTANCE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
	VERTEX_INPUT_RATE_BEGIN_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
	VERTEX_INPUT_RATE_END_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
	VERTEX_INPUT_RATE_RANGE_SIZE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	VERTEX_INPUT_RATE_MAX_ENUM = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
	COMPOSITE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
	COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_INHERIT_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
	COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
	COLOR_SPACE_SRGB_NONLINEAR_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
	COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
	COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
	COLOR_SPACE_DCI_P3_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT"),
	COLOR_SPACE_DCI_P3_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
	COLOR_SPACE_BT709_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_LINEAR_EXT"),
	COLOR_SPACE_BT709_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
	COLOR_SPACE_BT2020_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
	COLOR_SPACE_HDR10_ST2084_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_ST2084_EXT"),
	COLOR_SPACE_DOLBYVISION_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DOLBYVISION_EXT"),
	COLOR_SPACE_HDR10_HLG_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_HLG_EXT"),
	COLOR_SPACE_ADOBERGB_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
	COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
	COLOR_SPACE_PASS_THROUGH_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_PASS_THROUGH_EXT"),
	COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
	COLOR_SPACE_BEGIN_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
	COLOR_SPACE_END_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
	COLOR_SPACE_RANGE_SIZE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
	COLOR_SPACE_MAX_ENUM_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
	MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX = ffi.cast("enum VkMemoryAllocateFlagBitsKHX", "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX"),
	MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX = ffi.cast("enum VkMemoryAllocateFlagBitsKHX", "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX"),
	DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX"),
	DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX"),
	DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX"),
	DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX"),
	DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX"),
	IMAGE_TILING_OPTIMAL = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	IMAGE_TILING_LINEAR = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
	IMAGE_TILING_BEGIN_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
	IMAGE_TILING_END_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
	IMAGE_TILING_RANGE_SIZE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
	IMAGE_TILING_MAX_ENUM = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
	QUERY_TYPE_OCCLUSION = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
	QUERY_TYPE_PIPELINE_STATISTICS = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
	QUERY_TYPE_TIMESTAMP = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
	QUERY_TYPE_BEGIN_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
	QUERY_TYPE_END_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
	QUERY_TYPE_RANGE_SIZE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	QUERY_TYPE_MAX_ENUM = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
	FORMAT_UNDEFINED = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
	FORMAT_R4G4_UNORM_PACK8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
	FORMAT_R4G4B4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
	FORMAT_B4G4R4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
	FORMAT_R5G6B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
	FORMAT_B5G6R5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
	FORMAT_R5G5B5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
	FORMAT_B5G5R5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
	FORMAT_A1R5G5B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
	FORMAT_R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
	FORMAT_R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
	FORMAT_R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
	FORMAT_R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
	FORMAT_R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
	FORMAT_R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
	FORMAT_R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
	FORMAT_R8G8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
	FORMAT_R8G8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
	FORMAT_R8G8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
	FORMAT_R8G8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
	FORMAT_R8G8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
	FORMAT_R8G8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
	FORMAT_R8G8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
	FORMAT_R8G8B8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
	FORMAT_R8G8B8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
	FORMAT_R8G8B8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
	FORMAT_R8G8B8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
	FORMAT_R8G8B8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
	FORMAT_R8G8B8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
	FORMAT_R8G8B8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
	FORMAT_B8G8R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
	FORMAT_B8G8R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
	FORMAT_B8G8R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
	FORMAT_B8G8R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
	FORMAT_B8G8R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
	FORMAT_B8G8R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
	FORMAT_B8G8R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
	FORMAT_R8G8B8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
	FORMAT_R8G8B8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
	FORMAT_R8G8B8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
	FORMAT_R8G8B8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
	FORMAT_R8G8B8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
	FORMAT_R8G8B8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
	FORMAT_R8G8B8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
	FORMAT_B8G8R8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
	FORMAT_B8G8R8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
	FORMAT_B8G8R8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
	FORMAT_B8G8R8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
	FORMAT_B8G8R8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
	FORMAT_B8G8R8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
	FORMAT_B8G8R8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
	FORMAT_A8B8G8R8_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
	FORMAT_A8B8G8R8_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
	FORMAT_A8B8G8R8_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
	FORMAT_A8B8G8R8_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
	FORMAT_A8B8G8R8_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
	FORMAT_A8B8G8R8_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
	FORMAT_A8B8G8R8_SRGB_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
	FORMAT_A2R10G10B10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
	FORMAT_A2R10G10B10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
	FORMAT_A2R10G10B10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
	FORMAT_A2R10G10B10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
	FORMAT_A2R10G10B10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
	FORMAT_A2R10G10B10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
	FORMAT_A2B10G10R10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
	FORMAT_A2B10G10R10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
	FORMAT_A2B10G10R10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
	FORMAT_A2B10G10R10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
	FORMAT_A2B10G10R10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
	FORMAT_A2B10G10R10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
	FORMAT_R16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
	FORMAT_R16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
	FORMAT_R16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
	FORMAT_R16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
	FORMAT_R16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
	FORMAT_R16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
	FORMAT_R16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
	FORMAT_R16G16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
	FORMAT_R16G16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
	FORMAT_R16G16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
	FORMAT_R16G16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
	FORMAT_R16G16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
	FORMAT_R16G16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
	FORMAT_R16G16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
	FORMAT_R16G16B16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
	FORMAT_R16G16B16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
	FORMAT_R16G16B16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
	FORMAT_R16G16B16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
	FORMAT_R16G16B16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
	FORMAT_R16G16B16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
	FORMAT_R16G16B16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
	FORMAT_R16G16B16A16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
	FORMAT_R16G16B16A16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
	FORMAT_R16G16B16A16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
	FORMAT_R16G16B16A16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
	FORMAT_R16G16B16A16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
	FORMAT_R16G16B16A16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
	FORMAT_R16G16B16A16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
	FORMAT_R32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	FORMAT_R32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
	FORMAT_R32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
	FORMAT_R32G32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
	FORMAT_R32G32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
	FORMAT_R32G32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
	FORMAT_R32G32B32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
	FORMAT_R32G32B32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
	FORMAT_R32G32B32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
	FORMAT_R32G32B32A32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
	FORMAT_R32G32B32A32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
	FORMAT_R32G32B32A32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
	FORMAT_R64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
	FORMAT_R64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
	FORMAT_R64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
	FORMAT_R64G64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
	FORMAT_R64G64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
	FORMAT_R64G64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
	FORMAT_R64G64B64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
	FORMAT_R64G64B64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
	FORMAT_R64G64B64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
	FORMAT_R64G64B64A64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
	FORMAT_R64G64B64A64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
	FORMAT_R64G64B64A64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
	FORMAT_B10G11R11_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
	FORMAT_E5B9G9R9_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
	FORMAT_D16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
	FORMAT_X8_D24_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
	FORMAT_D32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
	FORMAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
	FORMAT_D16_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
	FORMAT_D24_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
	FORMAT_D32_SFLOAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
	FORMAT_BC1_RGB_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
	FORMAT_BC1_RGB_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
	FORMAT_BC1_RGBA_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
	FORMAT_BC1_RGBA_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
	FORMAT_BC2_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
	FORMAT_BC2_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
	FORMAT_BC3_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
	FORMAT_BC3_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
	FORMAT_BC4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
	FORMAT_BC4_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
	FORMAT_BC5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
	FORMAT_BC5_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
	FORMAT_BC6H_UFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
	FORMAT_BC6H_SFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
	FORMAT_BC7_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
	FORMAT_BC7_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
	FORMAT_EAC_R11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
	FORMAT_EAC_R11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
	FORMAT_EAC_R11G11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
	FORMAT_EAC_R11G11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
	FORMAT_ASTC_4x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
	FORMAT_ASTC_4x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
	FORMAT_ASTC_5x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
	FORMAT_ASTC_5x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
	FORMAT_ASTC_6x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
	FORMAT_ASTC_6x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
	FORMAT_ASTC_8x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
	FORMAT_ASTC_8x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
	FORMAT_ASTC_8x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
	FORMAT_ASTC_8x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
	FORMAT_ASTC_10x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
	FORMAT_ASTC_10x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
	FORMAT_ASTC_10x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
	FORMAT_ASTC_10x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
	FORMAT_ASTC_10x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
	FORMAT_ASTC_10x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
	FORMAT_ASTC_12x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x12_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
	FORMAT_ASTC_12x12_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
	FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_BEGIN_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
	FORMAT_END_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
	FORMAT_RANGE_SIZE = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
	FORMAT_MAX_ENUM = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
	ATTACHMENT_STORE_OP_STORE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	ATTACHMENT_STORE_OP_DONT_CARE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
	ATTACHMENT_STORE_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
	ATTACHMENT_STORE_OP_END_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
	ATTACHMENT_STORE_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
	ATTACHMENT_STORE_OP_MAX_ENUM = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
	LOGIC_OP_CLEAR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
	LOGIC_OP_AND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
	LOGIC_OP_AND_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
	LOGIC_OP_COPY = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
	LOGIC_OP_AND_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
	LOGIC_OP_NO_OP = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
	LOGIC_OP_XOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	LOGIC_OP_OR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
	LOGIC_OP_NOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
	LOGIC_OP_EQUIVALENT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
	LOGIC_OP_INVERT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
	LOGIC_OP_OR_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
	LOGIC_OP_COPY_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
	LOGIC_OP_OR_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
	LOGIC_OP_NAND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
	LOGIC_OP_SET = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
	LOGIC_OP_BEGIN_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
	LOGIC_OP_END_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
	LOGIC_OP_RANGE_SIZE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
	LOGIC_OP_MAX_ENUM = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
	ATTACHMENT_LOAD_OP_LOAD = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
	ATTACHMENT_LOAD_OP_CLEAR = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
	ATTACHMENT_LOAD_OP_DONT_CARE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
	ATTACHMENT_LOAD_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
	ATTACHMENT_LOAD_OP_END_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
	ATTACHMENT_LOAD_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	ATTACHMENT_LOAD_OP_MAX_ENUM = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"),
	RASTERIZATION_ORDER_STRICT_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
	RASTERIZATION_ORDER_RELAXED_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
	RASTERIZATION_ORDER_BEGIN_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
	RASTERIZATION_ORDER_END_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
	RASTERIZATION_ORDER_RANGE_SIZE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
	RASTERIZATION_ORDER_MAX_ENUM_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
	IMAGE_ASPECT_COLOR_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
	IMAGE_ASPECT_DEPTH_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
	IMAGE_ASPECT_STENCIL_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
	IMAGE_ASPECT_METADATA_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
	IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR"),
	EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR"),
	EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR"),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
	EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
	EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR"),
	POLYGON_MODE_FILL = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
	POLYGON_MODE_LINE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
	POLYGON_MODE_POINT = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
	POLYGON_MODE_FILL_RECTANGLE_NV = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
	POLYGON_MODE_BEGIN_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
	POLYGON_MODE_END_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
	POLYGON_MODE_RANGE_SIZE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	POLYGON_MODE_MAX_ENUM = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR"),
	IMAGE_TYPE_1D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
	IMAGE_TYPE_2D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
	IMAGE_TYPE_3D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
	IMAGE_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
	IMAGE_TYPE_END_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
	IMAGE_TYPE_RANGE_SIZE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	IMAGE_TYPE_MAX_ENUM = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
	SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
	SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
	SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
	SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
	BORDER_COLOR_INT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	BORDER_COLOR_INT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
	BORDER_COLOR_INT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
	BORDER_COLOR_BEGIN_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
	BORDER_COLOR_END_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
	BORDER_COLOR_RANGE_SIZE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
	BORDER_COLOR_MAX_ENUM = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
	DESCRIPTOR_TYPE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
	DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
	DESCRIPTOR_TYPE_SAMPLED_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
	DESCRIPTOR_TYPE_STORAGE_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
	DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_INPUT_ATTACHMENT = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
	DESCRIPTOR_TYPE_BEGIN_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
	DESCRIPTOR_TYPE_END_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
	DESCRIPTOR_TYPE_RANGE_SIZE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	DESCRIPTOR_TYPE_MAX_ENUM = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
	SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = ffi.cast("enum VkSemaphoreImportFlagBitsKHR", "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR"),
	SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkSemaphoreImportFlagBitsKHR", "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR"),
	INTERNAL_ALLOCATION_TYPE_EXECUTABLE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
	INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
	INTERNAL_ALLOCATION_TYPE_END_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
	INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	INTERNAL_ALLOCATION_TYPE_MAX_ENUM = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
	STENCIL_OP_KEEP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
	STENCIL_OP_ZERO = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
	STENCIL_OP_REPLACE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
	STENCIL_OP_INCREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
	STENCIL_OP_DECREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
	STENCIL_OP_INVERT = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
	STENCIL_OP_INCREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
	STENCIL_OP_DECREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
	STENCIL_OP_BEGIN_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
	STENCIL_OP_END_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
	STENCIL_OP_RANGE_SIZE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	STENCIL_OP_MAX_ENUM = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
	BLEND_OVERLAP_UNCORRELATED_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
	BLEND_OVERLAP_DISJOINT_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_DISJOINT_EXT"),
	BLEND_OVERLAP_CONJOINT_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_CONJOINT_EXT"),
	BLEND_OVERLAP_BEGIN_RANGE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_BEGIN_RANGE_EXT"),
	BLEND_OVERLAP_END_RANGE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_END_RANGE_EXT"),
	BLEND_OVERLAP_RANGE_SIZE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_RANGE_SIZE_EXT"),
	BLEND_OVERLAP_MAX_ENUM_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_MAX_ENUM_EXT"),
	VALIDATION_CHECK_ALL_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_ALL_EXT"),
	VALIDATION_CHECK_SHADERS_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_SHADERS_EXT"),
	VALIDATION_CHECK_BEGIN_RANGE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_BEGIN_RANGE_EXT"),
	VALIDATION_CHECK_END_RANGE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_END_RANGE_EXT"),
	VALIDATION_CHECK_RANGE_SIZE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_RANGE_SIZE_EXT"),
	VALIDATION_CHECK_MAX_ENUM_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_MAX_ENUM_EXT"),
	DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
	DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT"),
	DEVICE_EVENT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_END_RANGE_EXT"),
	DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT"),
	DEVICE_EVENT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT"),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"),
	COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
	COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
	FRONT_FACE_COUNTER_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
	FRONT_FACE_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	FRONT_FACE_BEGIN_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
	FRONT_FACE_END_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
	FRONT_FACE_RANGE_SIZE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
	FRONT_FACE_MAX_ENUM = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR"),
	BLEND_OP_ADD = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
	BLEND_OP_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
	BLEND_OP_REVERSE_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
	BLEND_OP_MIN = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
	BLEND_OP_MAX = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
	BLEND_OP_ZERO_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ZERO_EXT"),
	BLEND_OP_SRC_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_EXT"),
	BLEND_OP_DST_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_EXT"),
	BLEND_OP_SRC_OVER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OVER_EXT"),
	BLEND_OP_DST_OVER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OVER_EXT"),
	BLEND_OP_SRC_IN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_IN_EXT"),
	BLEND_OP_DST_IN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_IN_EXT"),
	BLEND_OP_SRC_OUT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OUT_EXT"),
	BLEND_OP_DST_OUT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OUT_EXT"),
	BLEND_OP_SRC_ATOP_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_ATOP_EXT"),
	BLEND_OP_DST_ATOP_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_ATOP_EXT"),
	BLEND_OP_XOR_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_XOR_EXT"),
	BLEND_OP_MULTIPLY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MULTIPLY_EXT"),
	BLEND_OP_SCREEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SCREEN_EXT"),
	BLEND_OP_OVERLAY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_OVERLAY_EXT"),
	BLEND_OP_DARKEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DARKEN_EXT"),
	BLEND_OP_LIGHTEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LIGHTEN_EXT"),
	BLEND_OP_COLORDODGE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORDODGE_EXT"),
	BLEND_OP_COLORBURN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORBURN_EXT"),
	BLEND_OP_HARDLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDLIGHT_EXT"),
	BLEND_OP_SOFTLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SOFTLIGHT_EXT"),
	BLEND_OP_DIFFERENCE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DIFFERENCE_EXT"),
	BLEND_OP_EXCLUSION_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_EXCLUSION_EXT"),
	BLEND_OP_INVERT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_EXT"),
	BLEND_OP_INVERT_RGB_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_RGB_EXT"),
	BLEND_OP_LINEARDODGE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARDODGE_EXT"),
	BLEND_OP_LINEARBURN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARBURN_EXT"),
	BLEND_OP_VIVIDLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_VIVIDLIGHT_EXT"),
	BLEND_OP_LINEARLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARLIGHT_EXT"),
	BLEND_OP_PINLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PINLIGHT_EXT"),
	BLEND_OP_HARDMIX_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDMIX_EXT"),
	BLEND_OP_HSL_HUE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_HUE_EXT"),
	BLEND_OP_HSL_SATURATION_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_SATURATION_EXT"),
	BLEND_OP_HSL_COLOR_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_COLOR_EXT"),
	BLEND_OP_HSL_LUMINOSITY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
	BLEND_OP_PLUS_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_EXT"),
	BLEND_OP_PLUS_CLAMPED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_EXT"),
	BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
	BLEND_OP_PLUS_DARKER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_DARKER_EXT"),
	BLEND_OP_MINUS_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_EXT"),
	BLEND_OP_MINUS_CLAMPED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_CLAMPED_EXT"),
	BLEND_OP_CONTRAST_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_CONTRAST_EXT"),
	BLEND_OP_INVERT_OVG_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_OVG_EXT"),
	BLEND_OP_RED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RED_EXT"),
	BLEND_OP_GREEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_GREEN_EXT"),
	BLEND_OP_BLUE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BLUE_EXT"),
	BLEND_OP_BEGIN_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
	BLEND_OP_END_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
	BLEND_OP_RANGE_SIZE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
	BLEND_OP_MAX_ENUM = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
	BLEND_FACTOR_ZERO = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
	BLEND_FACTOR_ONE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	BLEND_FACTOR_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
	BLEND_FACTOR_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
	BLEND_FACTOR_ONE_MINUS_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
	BLEND_FACTOR_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
	BLEND_FACTOR_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
	BLEND_FACTOR_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
	BLEND_FACTOR_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
	BLEND_FACTOR_SRC_ALPHA_SATURATE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
	BLEND_FACTOR_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
	BLEND_FACTOR_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
	BLEND_FACTOR_BEGIN_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
	BLEND_FACTOR_END_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
	BLEND_FACTOR_RANGE_SIZE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
	BLEND_FACTOR_MAX_ENUM = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
	PIPELINE_BIND_POINT_GRAPHICS = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	PIPELINE_BIND_POINT_COMPUTE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
	PIPELINE_BIND_POINT_BEGIN_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
	PIPELINE_BIND_POINT_END_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
	PIPELINE_BIND_POINT_RANGE_SIZE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
	PIPELINE_BIND_POINT_MAX_ENUM = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
	SHARING_MODE_EXCLUSIVE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
	SHARING_MODE_CONCURRENT = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
	SHARING_MODE_BEGIN_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
	SHARING_MODE_END_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
	SHARING_MODE_RANGE_SIZE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	SHARING_MODE_MAX_ENUM = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
	SAMPLER_ADDRESS_MODE_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
	SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
	SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
	SAMPLER_ADDRESS_MODE_END_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
	SAMPLER_ADDRESS_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	SAMPLER_ADDRESS_MODE_MAX_ENUM = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
	SPARSE_MEMORY_BIND_METADATA_BIT = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
	SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	PHYSICAL_DEVICE_TYPE_OTHER = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
	PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
	PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
	PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
	PHYSICAL_DEVICE_TYPE_CPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
	PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
	PHYSICAL_DEVICE_TYPE_END_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
	PHYSICAL_DEVICE_TYPE_RANGE_SIZE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	PHYSICAL_DEVICE_TYPE_MAX_ENUM = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
	PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX"),
	PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX"),
	PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX"),
	PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX"),
	PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX"),
	MEMORY_PROPERTY_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
	MEMORY_PROPERTY_HOST_VISIBLE_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	MEMORY_PROPERTY_HOST_COHERENT_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
	MEMORY_PROPERTY_HOST_CACHED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
	MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
	MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
	SUBPASS_CONTENTS_INLINE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
	SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
	SUBPASS_CONTENTS_BEGIN_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
	SUBPASS_CONTENTS_END_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
	SUBPASS_CONTENTS_RANGE_SIZE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	SUBPASS_CONTENTS_MAX_ENUM = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
	QUEUE_GRAPHICS_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
	QUEUE_COMPUTE_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
	QUEUE_TRANSFER_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	QUEUE_SPARSE_BINDING_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
	QUEUE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
	COLOR_COMPONENT_R_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
	COLOR_COMPONENT_G_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	COLOR_COMPONENT_B_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
	COLOR_COMPONENT_A_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
	COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
	COMPONENT_SWIZZLE_IDENTITY = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
	COMPONENT_SWIZZLE_ZERO = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
	COMPONENT_SWIZZLE_ONE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
	COMPONENT_SWIZZLE_R = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
	COMPONENT_SWIZZLE_G = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
	COMPONENT_SWIZZLE_B = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
	COMPONENT_SWIZZLE_A = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
	COMPONENT_SWIZZLE_BEGIN_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
	COMPONENT_SWIZZLE_END_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
	COMPONENT_SWIZZLE_RANGE_SIZE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	COMPONENT_SWIZZLE_MAX_ENUM = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
	COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
	COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
	COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
	COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR"),
	EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR"),
	EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR"),
	STENCIL_FACE_FRONT_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
	STENCIL_FACE_BACK_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
	STENCIL_FRONT_AND_BACK = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
	STENCIL_FACE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	COMMAND_BUFFER_LEVEL_PRIMARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
	COMMAND_BUFFER_LEVEL_SECONDARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
	COMMAND_BUFFER_LEVEL_BEGIN_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
	COMMAND_BUFFER_LEVEL_END_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
	COMMAND_BUFFER_LEVEL_RANGE_SIZE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	COMMAND_BUFFER_LEVEL_MAX_ENUM = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
	DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
	DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
	DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT"),
	DISCARD_RECTANGLE_MODE_END_RANGE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT"),
	DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT"),
	DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT"),
	SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"),
	SAMPLER_REDUCTION_MODE_MIN_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MIN_EXT"),
	SAMPLER_REDUCTION_MODE_MAX_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_EXT"),
	SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT"),
	SAMPLER_REDUCTION_MODE_END_RANGE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT"),
	SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT"),
	SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT"),
	blend_overlap = {
		conjoint = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_CONJOINT_EXT"),
		end_range = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_END_RANGE_EXT"),
		disjoint = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_DISJOINT_EXT"),
		max_enum = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_MAX_ENUM_EXT"),
		uncorrelated = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
		begin_range = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_RANGE_SIZE_EXT"),
	},
	front_face = {
		counter_clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
		end_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
		max_enum = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
		clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	},
	object_type = {
		swapchain = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
		instance = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INSTANCE"),
		end_range = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_END_RANGE"),
		buffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER"),
		command_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_POOL"),
		fence = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FENCE"),
		pipeline_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
		event = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_EVENT"),
		pipeline = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE"),
		display = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_KHR"),
		semaphore = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SEMAPHORE"),
		image_view = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE_VIEW"),
		max_enum = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_MAX_ENUM"),
		surface = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SURFACE_KHR"),
		descriptor_update_template = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR"),
		indirect_commands_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX"),
		image = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE"),
		device_memory = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE_MEMORY"),
		begin_range = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BEGIN_RANGE"),
		display_mode = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
		buffer_view = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER_VIEW"),
		range_size = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RANGE_SIZE"),
		descriptor_set = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET"),
		object_table = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_OBJECT_TABLE_NVX"),
		query_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUERY_POOL"),
		framebuffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FRAMEBUFFER"),
		sampler = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER"),
		descriptor_set_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
		debug_report_callback = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
		device = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE"),
		physical_device = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
		pipeline_cache = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_CACHE"),
		shader_module = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SHADER_MODULE"),
		unknown = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_UNKNOWN"),
		queue = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUEUE"),
		render_pass = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RENDER_PASS"),
		descriptor_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
		command_buffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_BUFFER"),
	},
	display_plane_alpha = {
		flag_bits_max_enum = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
		per_pixel = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
		global = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.display_plane_alpha[v] end return bit.bor(unpack(flags)) end,
		per_pixel_premultiplied = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
		opaque = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	},
	attachment_load_op = {
		load = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
		dont_care = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
		max_enum = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
		end_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
		clear = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
		range_size = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	},
	descriptor_pool_create = {
		flag_bits_max_enum = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.descriptor_pool_create[v] end return bit.bor(unpack(flags)) end,
		free_descriptor_set = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
	},
	access = {
		color_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
		transfer_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
		memory_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
		shader_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
		uniform_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
		host_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
		host_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
		color_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
		shader_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
		depth_stencil_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
		memory_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
		vertex_attribute_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
		depth_stencil_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
		command_process_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"),
		input_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
		color_attachment_read_noncoherent = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
		index_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
		command_process_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.access[v] end return bit.bor(unpack(flags)) end,
		indirect_command_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
		transfer_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	},
	internal_allocation_type = {
		end_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
		executable = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
		begin_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	},
	pipeline_create = {
		flag_bits_max_enum = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
		disable_optimization = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
		view_index_from_device_index = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX"),
		derivative = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
		allow_derivatives = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.pipeline_create[v] end return bit.bor(unpack(flags)) end,
		dispatch_base = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISPATCH_BASE_KHX"),
	},
	display_power_state = {
		suspend = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
		off = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_OFF_EXT"),
		max_enum = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT"),
		end_range = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_END_RANGE_EXT"),
		begin_range = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT"),
		on = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_ON_EXT"),
		range_size = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT"),
	},
	swapchain_create = {
		bind_sfr = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.swapchain_create[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR"),
	},
	indirect_commands_token_type = {
		type_push_constant = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX"),
		type_max_enum = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX"),
		type_pipeline = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX"),
		type_dispatch = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX"),
		type_index_buffer = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX"),
		type_end_range = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX"),
		type_vertex_buffer = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX"),
		type_begin_range = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX"),
		type_range_size = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX"),
		type_draw = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX"),
		type_draw_indexed = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX"),
		type_descriptor_set = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX"),
	},
	memory_allocate = {
		flag_bits_max_enum = ffi.cast("enum VkMemoryAllocateFlagBitsKHX", "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.memory_allocate[v] end return bit.bor(unpack(flags)) end,
		device_mask = ffi.cast("enum VkMemoryAllocateFlagBitsKHX", "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX"),
	},
	blend_op = {
		softlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SOFTLIGHT_EXT"),
		hardlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDLIGHT_EXT"),
		src_out = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OUT_EXT"),
		dst_atop = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_ATOP_EXT"),
		contrast = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_CONTRAST_EXT"),
		colordodge = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORDODGE_EXT"),
		hsl_hue = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_HUE_EXT"),
		exclusion = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_EXCLUSION_EXT"),
		minus_clamped = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_CLAMPED_EXT"),
		dst = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_EXT"),
		multiply = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MULTIPLY_EXT"),
		dst_in = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_IN_EXT"),
		end_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
		pinlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PINLIGHT_EXT"),
		min = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
		max_enum = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
		dst_out = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OUT_EXT"),
		lighten = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LIGHTEN_EXT"),
		src_in = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_IN_EXT"),
		range_size = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
		difference = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DIFFERENCE_EXT"),
		begin_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
		plus_clamped = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_EXT"),
		hsl_saturation = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_SATURATION_EXT"),
		green = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_GREEN_EXT"),
		red = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RED_EXT"),
		add = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
		plus_darker = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_DARKER_EXT"),
		plus = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_EXT"),
		vividlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_VIVIDLIGHT_EXT"),
		minus = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_EXT"),
		hardmix = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDMIX_EXT"),
		plus_clamped_alpha = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
		hsl_luminosity = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
		colorburn = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORBURN_EXT"),
		hsl_color = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_COLOR_EXT"),
		zero = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ZERO_EXT"),
		overlay = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_OVERLAY_EXT"),
		blue = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BLUE_EXT"),
		max = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
		linearlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARLIGHT_EXT"),
		src_atop = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_ATOP_EXT"),
		invert = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_EXT"),
		invert_rgb = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_RGB_EXT"),
		reverse_subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
		screen = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SCREEN_EXT"),
		src = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_EXT"),
		linearburn = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARBURN_EXT"),
		lineardodge = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARDODGE_EXT"),
		dst_over = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OVER_EXT"),
		darken = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DARKEN_EXT"),
		subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
		invert_ovg = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_OVG_EXT"),
		src_over = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OVER_EXT"),
		xor = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_XOR_EXT"),
	},
	descriptor_set_layout_create = {
		flag_bits_max_enum = ffi.cast("enum VkDescriptorSetLayoutCreateFlagBits", "VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.descriptor_set_layout_create[v] end return bit.bor(unpack(flags)) end,
		push_descriptor = ffi.cast("enum VkDescriptorSetLayoutCreateFlagBits", "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"),
	},
	pipeline_bind_point = {
		end_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
		compute = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
		begin_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
		graphics = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	},
	external_memory_feature = {
		exportable = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"),
		dedicated_only = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_memory_feature[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"),
		importable = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
	},
	object_entry_type = {
		descriptor_set = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX"),
		end_range = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX"),
		max_enum = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX"),
		index_buffer = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX"),
		vertex_buffer = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX"),
		push_constant = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX"),
		begin_range = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX"),
		pipeline = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX"),
		range_size = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX"),
	},
	structure_type = {
		bind_image_memory_swapchain_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX"),
		pipeline_input_assembly_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
		pipeline_viewport_w_scaling_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
		pipeline_dynamic_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
		descriptor_update_template_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"),
		device_generated_commands_limits = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"),
		begin_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
		descriptor_set_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
		export_semaphore_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
		compute_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
		present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
		sampler_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
		cmd_process_commands_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"),
		physical_device_image_format_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR"),
		loader_instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
		buffer_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
		dedicated_allocation_image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
		command_buffer_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
		write_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
		semaphore_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
		device_group_submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX"),
		dedicated_allocation_buffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
		image_swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX"),
		device_group_render_pass_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX"),
		device_event_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
		debug_marker_object_name_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
		import_fence_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
		command_buffer_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
		format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR"),
		graphics_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
		event_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
		physical_device_memory_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR"),
		instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
		device_group_device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX"),
		debug_marker_object_tag_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
		physical_device_multiview_per_view_attributes_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
		image_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
		physical_device_external_semaphore_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"),
		memory_dedicated_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"),
		bind_sparse_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
		memory_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
		fence_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
		memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
		queue_family_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR"),
		mapped_memory_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
		render_pass_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
		pipeline_cache_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
		dedicated_allocation_memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
		import_memory_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
		pipeline_rasterization_state_rasterization_order = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
		image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
		vi_surface_create_info_nn = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
		fence_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
		display_power_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
		physical_device_external_fence_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"),
		framebuffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
		buffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
		semaphore_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
		memory_fd_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
		pipeline_color_blend_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
		display_mode_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
		external_semaphore_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"),
		pipeline_viewport_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
		export_fence_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		import_semaphore_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
		hdr_metadata = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
		device_generated_commands_features = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"),
		android_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
		command_buffer_inheritance_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
		descriptor_set_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
		physical_device_external_image_format_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"),
		display_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
		export_fence_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"),
		memory_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
		export_semaphore_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"),
		texture_lod_gather_format_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
		pipeline_rasterization_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
		buffer_memory_requirements_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		device_group_command_buffer_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX"),
		physical_device_blend_operation_advanced_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
		d3d12_fence_submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
		range_size = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
		physical_device_surface_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
		end_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
		pipeline_coverage_modulation_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
		pipeline_coverage_to_color_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
		display_present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
		max_enum = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
		physical_device_blend_operation_advanced_features = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
		external_image_format_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"),
		import_semaphore_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
		shader_module_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
		device_group_present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX"),
		sparse_image_memory_requirements_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR"),
		memory_requirements_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR"),
		pipeline_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
		image_format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		sampler_reduction_mode_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"),
		mir_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
		win32_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
		memory_dedicated_requirements = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"),
		bind_buffer_memory_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX"),
		macos_surface_create_info_mvk = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
		ios_surface_create_info_mvk = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
		physical_device_push_descriptor_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"),
		render_pass_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
		device_group_swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX"),
		device_group_present_capabilities = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX"),
		external_memory_buffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"),
		physical_device_multiview_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX"),
		debug_marker_marker_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
		command_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
		win32_keyed_mutex_acquire_release_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
		present_times_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
		import_fence_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		external_memory_image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"),
		physical_device_features_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR"),
		external_fence_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"),
		buffer_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
		shared_present_surface_capabilities = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
		pipeline_discard_rectangle_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
		application_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
		physical_device_external_buffer_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"),
		pipeline_multisample_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
		object_table_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"),
		pipeline_viewport_swizzle_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
		device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
		physical_device_group_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX"),
		bind_image_memory_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX"),
		physical_device_discard_rectangle_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
		debug_report_callback_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
		render_pass_multiview_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX"),
		fence_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
		device_queue_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
		import_memory_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		export_memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"),
		loader_device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
		surface_capabilities2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT"),
		cmd_reserve_space_for_commands_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"),
		indirect_commands_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"),
		physical_device_16bit_storage_features = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR"),
		external_buffer_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"),
		xlib_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
		wayland_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
		copy_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
		pipeline_depth_stencil_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
		xcb_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
		physical_device_variable_pointer_features = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"),
		query_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
		descriptor_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
		display_event_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
		sparse_image_format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		physical_device_multiview_features = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX"),
		pipeline_shader_stage_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
		pipeline_tessellation_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
		physical_device_sampler_filter_minmax_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"),
		swapchain_counter_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
		acquire_next_image_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX"),
		export_memory_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		validation_flags = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
		surface_capabilities_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
		physical_device_sparse_image_format_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR"),
		image_memory_requirements_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		physical_device_id_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR"),
		memory_allocate_flags_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX"),
		image_sparse_memory_requirements_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
		device_group_bind_sparse_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX"),
		surface_format_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
		memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
		pipeline_vertex_input_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
		memory_win32_handle_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
		physical_device_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR"),
		present_regions = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
		image_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
		submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
		semaphore_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
		pipeline_color_blend_advanced_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
	},
	sampler_reduction_mode = {
		weighted_average = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"),
		end_range = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT"),
		max = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_EXT"),
		begin_range = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT"),
		min = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MIN_EXT"),
		range_size = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT"),
	},
	display_event_type = {
		end_range = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT"),
		begin_range = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT"),
		first_pixel_out = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
		range_size = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT"),
	},
	format_feature = {
		sampled_image_filter_linear = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
		color_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
		sampled_image_filter_cubic_bit_img = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"),
		transfer_dst = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR"),
		color_attachment_blend = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
		storage_texel_buffer_atomic = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
		vertex_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
		blit_src = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
		storage_image_atomic = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
		transfer_src = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR"),
		sampled_image_filter_minmax = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT"),
		flag_bits_max_enum = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
		storage_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
		blit_dst = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
		depth_stencil_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		storage_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.format_feature[v] end return bit.bor(unpack(flags)) end,
		uniform_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
		sampled_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
	},
	command_buffer_usage = {
		render_pass_continue = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
		simultaneous_use = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_buffer_usage[v] end return bit.bor(unpack(flags)) end,
		one_time_submit = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	},
	query_control = {
		flag_bits_max_enum = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_control[v] end return bit.bor(unpack(flags)) end,
		precise = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	},
	logic_op = {
		["or"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
		invert = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
		max_enum = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
		or_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
		nor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
		nand = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
		begin_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
		end_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
		set = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
		and_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
		["and"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
		or_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
		copy_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
		no_op = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
		copy = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
		and_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
		equivalent = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
		clear = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
		xor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	},
	command_pool_create = {
		transient = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_pool_create[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
		reset_command_buffer = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
	},
	primitive_topology = {
		line_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
		triangle_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
		end_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
		triangle_fan = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
		max_enum = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
		line_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
		range_size = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
		point_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
		line_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
		line_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
		triangle_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
		triangle_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
		begin_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
		triangle_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
		patch_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	},
	external_semaphore_handle_type = {
		flag_bits_max_enum = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR"),
		opaque_win32_kmt = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
		opaque_fd = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
		sync_fd = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_semaphore_handle_type[v] end return bit.bor(unpack(flags)) end,
		opaque_win32 = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
		d3d12_fence = ffi.cast("enum VkExternalSemaphoreHandleTypeFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR"),
	},
	present_mode = {
		fifo = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
		mailbox = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
		end_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
		max_enum = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
		fifo_relaxed = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
		shared_continuous_refresh = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
		immediate = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
		begin_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
		shared_demand_refresh = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
		range_size = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	},
	sampler_mipmap_mode = {
		linear = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
		nearest = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
		max_enum = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
		range_size = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	},
	sampler_address_mode = {
		end_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
		["repeat"] = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
		clamp_to_border = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
		mirrored_repeat = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
		max_enum = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
		clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
		begin_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
		mirror_clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
		range_size = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	},
	device_event_type = {
		end_range = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_END_RANGE_EXT"),
		display_hotplug = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
		begin_range = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT"),
		range_size = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT"),
	},
	debug_report = {
		warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
		flag_bits_max_enum = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
		performance_warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
		debug = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.debug_report[v] end return bit.bor(unpack(flags)) end,
		error = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
		information = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	},
	image_create = {
		bind_sfr = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_BIND_SFR_BIT_KHX"),
		flag_bits_max_enum = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
		sparse_aliased = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
		cube_compatible = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
		mutable_format = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_create[v] end return bit.bor(unpack(flags)) end,
		sparse_binding = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
		["2d_array_compatible"] = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR"),
		sparse_residency = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	indirect_commands_layout_usage = {
		flag_bits_max_enum = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX"),
		sparse_sequences = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"),
		empty_executions = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.indirect_commands_layout_usage[v] end return bit.bor(unpack(flags)) end,
		indexed_sequences = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"),
		unordered_sequences = ffi.cast("enum VkIndirectCommandsLayoutUsageFlagBitsNVX", "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"),
	},
	filter = {
		linear = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
		nearest = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
		max_enum = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
		cubic_img = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
		begin_range = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
		range_size = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	},
	image_tiling = {
		linear = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
		end_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
		max_enum = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
		optimal = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	},
	composite_alpha = {
		flag_bits_max_enum = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
		opaque = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.composite_alpha[v] end return bit.bor(unpack(flags)) end,
		post_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
		inherit = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
		pre_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	},
	coverage_modulation_mode = {
		none = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_NONE_NV"),
		max_enum = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV"),
		rgb = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGB_NV"),
		rgba = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
		alpha = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
		begin_range = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV"),
		end_range = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_END_RANGE_NV"),
		range_size = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV"),
	},
	command_pool_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_pool_reset[v] end return bit.bor(unpack(flags)) end,
		release_resources = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	},
	format = {
		r64g64b64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
		b8g8r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
		r8g8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
		r8g8b8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
		r64g64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
		astc_5x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
		begin_range = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
		r8g8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
		eac_r11g11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
		astc_10x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
		a2r10g10b10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
		d32_sfloat_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
		astc_12x12_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
		r64g64b64a64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
		b8g8r8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
		d16_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
		r8g8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
		r64g64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
		range_size = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
		r16g16b16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
		r8g8b8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
		d24_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
		a2b10g10r10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
		astc_12x12_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
		r16g16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
		s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
		r16g16b16a16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
		r8g8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
		pvrtc2_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
		pvrtc1_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
		pvrtc2_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
		r64g64b64a64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
		r64g64b64a64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
		a2r10g10b10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
		r16g16b16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
		r16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
		r8g8b8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
		r16g16b16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
		r32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
		r16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
		bc1_rgba_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
		r16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
		a8b8g8r8_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
		b8g8r8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
		b10g11r11_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
		bc1_rgba_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
		r8g8b8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
		r16g16b16a16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
		etc2_r8g8b8a8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
		r8g8b8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
		pvrtc1_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
		bc4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
		pvrtc2_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
		bc5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
		astc_10x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
		r8g8b8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
		etc2_r8g8b8a1_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
		pvrtc1_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
		a8b8g8r8_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
		r8g8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
		r32g32b32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
		bc7_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
		pvrtc1_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
		astc_12x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
		etc2_r8g8b8a8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
		eac_r11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
		astc_12x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
		astc_10x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
		r5g6b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
		r32g32b32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
		r64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
		astc_10x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
		r32g32b32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
		bc1_rgb_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
		r64g64b64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
		etc2_r8g8b8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
		a2b10g10r10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
		r4g4_unorm_pack8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
		astc_10x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
		e5b9g9r9_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
		astc_10x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
		r16g16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
		r32g32b32a32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
		astc_8x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
		astc_8x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
		astc_8x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
		a8b8g8r8_srgb_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
		b8g8r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
		r16g16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
		astc_5x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
		astc_6x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
		astc_8x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
		a8b8g8r8_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
		astc_8x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
		r8g8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
		r32g32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
		astc_6x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
		astc_6x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
		r16g16b16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
		astc_6x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
		astc_5x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
		r32g32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
		astc_5x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
		a8b8g8r8_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
		r64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
		astc_4x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
		max_enum = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
		a2b10g10r10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
		eac_r11g11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
		a8b8g8r8_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
		a2b10g10r10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
		bc2_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
		x8_d24_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
		r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
		b8g8r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
		a1r5g5b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
		b5g6r5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
		r16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
		b8g8r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
		undefined = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
		eac_r11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
		etc2_r8g8b8a1_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
		r16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
		a2r10g10b10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
		pvrtc2_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
		r16g16b16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
		r16g16b16a16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
		bc3_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
		b8g8r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
		b8g8r8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
		etc2_r8g8b8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
		bc7_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
		r16g16b16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
		d32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
		bc6h_ufloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
		r64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
		bc5_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
		r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
		bc4_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
		r16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
		bc3_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
		bc2_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
		r32g32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
		bc1_rgb_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
		astc_10x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
		r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
		b8g8r8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
		r8g8b8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
		astc_4x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
		r8g8b8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
		a2r10g10b10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
		end_range = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
		b8g8r8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
		b5g5r5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
		astc_10x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
		astc_8x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
		r16g16b16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
		b4g4r4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
		a2r10g10b10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
		r16g16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
		r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
		r16g16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
		r8g8b8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
		a8b8g8r8_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
		b8g8r8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
		r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
		r8g8b8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
		r8g8b8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
		r8g8b8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
		b8g8r8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
		r8g8b8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
		r8g8b8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
		r64g64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
		a2b10g10r10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
		r64g64b64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
		r16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
		a2r10g10b10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
		a2b10g10r10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
		r16g16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
		r4g4b4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
		r16g16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
		bc6h_sfloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
		b8g8r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
		r5g5b5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
		r8g8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
		r16g16b16a16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
		r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
		r16g16b16a16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
		r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
		r16g16b16a16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
		r16g16b16a16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
		d16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
		b8g8r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
		r32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
		r32g32b32a32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
		r32g32b32a32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
		r32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	},
	discard_rectangle_mode = {
		end_range = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT"),
		exclusive = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
		begin_range = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT"),
		inclusive = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
	},
	command_buffer_level = {
		end_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
		secondary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
		max_enum = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
		begin_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
		primary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
		range_size = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	},
	stencil_face = {
		front_and_back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
		back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
		front = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.stencil_face[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	},
	external_semaphore_feature = {
		exportable = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_semaphore_feature[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR"),
		importable = ffi.cast("enum VkExternalSemaphoreFeatureFlagBitsKHR", "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR"),
	},
	stencil_op = {
		invert = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
		max_enum = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
		decrement_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
		increment_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
		end_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
		replace = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
		decrement_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
		zero = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
		increment_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
		keep = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
		range_size = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	},
	vertex_input_rate = {
		end_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
		max_enum = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
		vertex = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
		instance = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
		begin_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	},
	dynamic_state = {
		blend_constants = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
		stencil_write_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
		end_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
		viewport_w_scaling = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
		viewport = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
		depth_bias = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
		line_width = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
		max_enum = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
		stencil_compare_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
		discard_rectangle = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
		begin_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
		depth_bounds = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
		scissor = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
		stencil_reference = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
		range_size = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	},
	query_result = {
		flag_bits_max_enum = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
		["64"] = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
		with_availability = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_result[v] end return bit.bor(unpack(flags)) end,
		partial = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
		wait = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	},
	physical_device_type = {
		integrated_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
		end_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
		other = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
		max_enum = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
		virtual_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
		discrete_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
		cpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
		begin_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	},
	external_fence_handle_type = {
		flag_bits_max_enum = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR"),
		opaque_win32_kmt = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
		opaque_fd = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
		sync_fd = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_fence_handle_type[v] end return bit.bor(unpack(flags)) end,
		opaque_win32 = ffi.cast("enum VkExternalFenceHandleTypeFlagBitsKHR", "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
	},
	polygon_mode = {
		line = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
		max_enum = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
		end_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
		fill_rectangle = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
		begin_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
		point = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
		fill = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
		range_size = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	},
	surface_counter = {
		flag_bits_max_enum = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.surface_counter[v] end return bit.bor(unpack(flags)) end,
		vblank = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_VBLANK_EXT"),
	},
	device_group_present_mode = {
		remote = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX"),
		sum = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX"),
		["local"] = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.device_group_present_mode[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX"),
		local_multi_device = ffi.cast("enum VkDeviceGroupPresentModeFlagBitsKHX", "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX"),
	},
	cull_mode = {
		none = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
		back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
		front = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.cull_mode[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
		front_and_back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	},
	fence_create = {
		signaled = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.fence_create[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	},
	memory_property = {
		device_local = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
		host_coherent = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
		host_cached = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
		lazily_allocated = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.memory_property[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
		host_visible = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	},
	blend_factor = {
		src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
		max_enum = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
		one_minus_dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
		one_minus_src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
		constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
		one_minus_constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
		one_minus_src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
		zero = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
		range_size = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
		one_minus_dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
		one_minus_src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
		src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
		dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
		src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
		dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
		one_minus_constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
		end_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
		src_alpha_saturate = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
		constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
		begin_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
		src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
		one_minus_src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
		one = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	},
	buffer_create = {
		flag_bits_max_enum = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
		sparse_aliased = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.buffer_create[v] end return bit.bor(unpack(flags)) end,
		sparse_binding = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
		sparse_residency = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	queue = {
		flag_bits_max_enum = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
		sparse_binding = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
		compute = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.queue[v] end return bit.bor(unpack(flags)) end,
		graphics = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
		transfer = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	},
	rasterization_order = {
		relaxed = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
		end_range = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
		strict = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
		begin_range = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
		max_enum = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
		range_size = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
	},
	image_usage = {
		sampled = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
		color_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
		transfer_src = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
		input_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
		transfer_dst = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
		depth_stencil_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_usage[v] end return bit.bor(unpack(flags)) end,
		transient_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
		storage = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	},
	external_fence_feature = {
		exportable = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_fence_feature[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR"),
		importable = ffi.cast("enum VkExternalFenceFeatureFlagBitsKHR", "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR"),
	},
	external_memory_handle_type = {
		d3d11_texture_kmt = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR"),
		opaque_win32_kmt = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
		opaque_win32 = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
		flag_bits_max_enum = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"),
		d3d11_image_kmt = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
		opaque_fd = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
		d3d11_texture = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR"),
		d3d11_image = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_memory_handle_type[v] end return bit.bor(unpack(flags)) end,
		d3d12_resource = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR"),
		d3d12_heap = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsKHR", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR"),
	},
	object_entry_usage = {
		compute = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.object_entry_usage[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX"),
		graphics = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"),
	},
	subpass_description = {
		per_view_position_x_only = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.subpass_description[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
		per_view_attributes = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"),
	},
	debug_report_object_type = {
		swapchain = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
		instance = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
		end_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
		buffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
		command_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
		object_table = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"),
		pipeline_layout = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
		event = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
		pipeline = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
		display = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
		semaphore = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
		image_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
		debug_report_callback_ext = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"),
		surface = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
		descriptor_update_template = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT"),
		max_enum = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
		image = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
		device_memory = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
		begin_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
		display_mode = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"),
		buffer_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
		range_size = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
		descriptor_set = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
		indirect_commands_layout = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"),
		query_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
		framebuffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
		sampler = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
		descriptor_set_layout = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
		pipeline_cache = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
		device = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
		physical_device = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
		fence = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
		shader_module = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
		unknown = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
		queue = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
		render_pass = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
		descriptor_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
		command_buffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
	},
	image_layout = {
		present_src = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
		transfer_dst_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
		preinitialized = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
		max_enum = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
		general = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
		undefined = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
		transfer_src_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
		end_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
		depth_stencil_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
		shader_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
		begin_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
		depth_stencil_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
		shared_present = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
		color_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
		range_size = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
	},
	sparse_memory_bind = {
		metadata = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sparse_memory_bind[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	},
	dependency = {
		device_group = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX"),
		view_local = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.dependency[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
		by_region = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	},
	surface_transform = {
		identity = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
		rotate_90 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
		rotate_180 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
		horizontal_mirror_rotate_180 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
		horizontal_mirror_rotate_270 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
		rotate_270 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
		horizontal_mirror = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
		flag_bits_max_enum = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.surface_transform[v] end return bit.bor(unpack(flags)) end,
		inherit = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
		horizontal_mirror_rotate_90 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
	},
	system_allocation_scope = {
		object = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
		end_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
		max_enum = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
		cache = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
		command = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
		device = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
		begin_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
		instance = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
		range_size = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	},
	peer_memory_feature = {
		flag_bits_max_enum = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX"),
		generic_src = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX"),
		copy_dst = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.peer_memory_feature[v] end return bit.bor(unpack(flags)) end,
		copy_src = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX"),
		generic_dst = ffi.cast("enum VkPeerMemoryFeatureFlagBitsKHX", "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX"),
	},
	descriptor_update_template_type = {
		descriptor_set = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR"),
		end_range = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR"),
		push_descriptors = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR"),
		begin_range = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR"),
		max_enum = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR"),
		range_size = ffi.cast("enum VkDescriptorUpdateTemplateTypeKHR", "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR"),
	},
	descriptor_type = {
		max_enum = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
		sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
		storage_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
		sampled_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
		input_attachment = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
		uniform_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
		combined_image_sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
		storage_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
		uniform_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
		end_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
		storage_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
		begin_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
		uniform_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
		storage_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
		range_size = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	},
	command_buffer_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_buffer_reset[v] end return bit.bor(unpack(flags)) end,
		release_resources = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
	},
	query_pipeline_statistic = {
		clipping_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
		fragment_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
		geometry_shader_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
		input_assembly_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
		compute_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"),
		tessellation_evaluation_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
		tessellation_control_shader_patches = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
		vertex_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
		clipping_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_pipeline_statistic[v] end return bit.bor(unpack(flags)) end,
		geometry_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
		input_assembly_vertices = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
	},
	validation_check = {
		end_range = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_MAX_ENUM_EXT"),
		shaders = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_SHADERS_EXT"),
		begin_range = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_RANGE_SIZE_EXT"),
		all = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_ALL_EXT"),
	},
	component_swizzle = {
		identity = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
		one = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
		max_enum = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
		g = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
		b = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
		zero = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
		end_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
		r = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
		begin_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
		a = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
		range_size = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	},
	query_type = {
		occlusion = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
		end_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
		pipeline_statistics = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
		timestamp = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
		range_size = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	},
	semaphore_import = {
		flag_bits_max_enum = ffi.cast("enum VkSemaphoreImportFlagBitsKHR", "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.semaphore_import[v] end return bit.bor(unpack(flags)) end,
		temporary = ffi.cast("enum VkSemaphoreImportFlagBitsKHR", "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR"),
	},
	memory_heap = {
		device_local = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.memory_heap[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
		multi_instance = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX"),
	},
	sample_count = {
		["4"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
		["8"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
		["32"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
		["2"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
		["64"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sample_count[v] end return bit.bor(unpack(flags)) end,
		["1"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
		["16"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	},
	border_color = {
		end_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
		float_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
		float_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
		max_enum = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
		int_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
		range_size = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
		int_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
		begin_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
		int_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
		float_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	},
	sparse_image_format = {
		nonstandard_block_size = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
		aligned_mip_size = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sparse_image_format[v] end return bit.bor(unpack(flags)) end,
		single_miptail = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	},
	image_type = {
		["1d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
		end_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
		["2d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
		range_size = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	},
	index_type = {
		uint32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
		uint16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
		max_enum = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
		range_size = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	},
	image_aspect = {
		flag_bits_max_enum = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
		stencil = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
		color = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
		metadata = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_aspect[v] end return bit.bor(unpack(flags)) end,
		depth = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
	},
	pipeline_cache_header_version = {
		end_range = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
		begin_range = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"),
		one = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
		range_size = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"),
	},
	pipeline_stage = {
		tessellation_control_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
		host = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
		draw_indirect = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
		tessellation_evaluation_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
		color_attachment_output = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
		command_process = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"),
		early_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
		all_commands = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
		all_graphics = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
		top_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
		compute_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
		vertex_input = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
		transfer = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
		bottom_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
		late_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
		geometry_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.pipeline_stage[v] end return bit.bor(unpack(flags)) end,
		vertex_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
		fragment_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	},
	attachment_description = {
		flag_bits_max_enum = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.attachment_description[v] end return bit.bor(unpack(flags)) end,
		may_alias = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	},
	result = {
		error_validation_failed = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
		error_initialization_failed = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
		event_set = ffi.cast("enum VkResult", "VK_EVENT_SET"),
		error_memory_map_failed = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
		result_max_enum = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
		error_invalid_shader = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
		result_range_size = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
		error_feature_not_present = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
		result_end_range = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
		error_incompatible_driver = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
		result_begin_range = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
		error_invalid_external_handle = ffi.cast("enum VkResult", "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR"),
		not_ready = ffi.cast("enum VkResult", "VK_NOT_READY"),
		error_device_lost = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
		error_incompatible_display = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
		incomplete = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
		event_reset = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
		error_out_of_date = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
		suboptimal = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
		error_native_window_in_use = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
		error_out_of_device_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
		timeout = ffi.cast("enum VkResult", "VK_TIMEOUT"),
		error_surface_lost = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
		error_extension_not_present = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
		error_format_not_supported = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
		error_out_of_pool_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_POOL_MEMORY_KHR"),
		success = ffi.cast("enum VkResult", "VK_SUCCESS"),
		error_fragmented_pool = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
		error_layer_not_present = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
		error_out_of_host_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
		error_too_many_objects = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
	},
	sharing_mode = {
		end_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
		max_enum = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
		exclusive = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
		begin_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
		concurrent = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
		range_size = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	},
	buffer_usage = {
		transfer_src = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
		index_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
		uniform_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
		uniform_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
		vertex_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
		storage_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
		indirect_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.buffer_usage[v] end return bit.bor(unpack(flags)) end,
		storage_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
		transfer_dst = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	},
	shader_stage = {
		compute = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
		fragment = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
		all = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
		flag_bits_max_enum = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
		geometry = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
		all_graphics = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
		vertex = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
		tessellation_control = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
		tessellation_evaluation = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.shader_stage[v] end return bit.bor(unpack(flags)) end,
	},
	subpass_contents = {
		end_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
		inline = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
		secondary_command_buffers = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
		begin_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
		max_enum = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
		range_size = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	},
	color_component = {
		b = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
		r = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.color_component[v] end return bit.bor(unpack(flags)) end,
		a = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
		g = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	},
	fence_import = {
		flag_bits_max_enum = ffi.cast("enum VkFenceImportFlagBitsKHR", "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.fence_import[v] end return bit.bor(unpack(flags)) end,
		temporary = ffi.cast("enum VkFenceImportFlagBitsKHR", "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR"),
	},
	compare_op = {
		not_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
		end_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
		greater_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
		max_enum = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
		never = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
		equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
		less = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
		greater = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
		less_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
		always = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
		begin_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	},
	colorspace = {
		_hdr10_hlg = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_HLG_EXT"),
		_adobergb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
		_display_p3_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
		_end_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
		_bt2020_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
		_bt709_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
		_adobergb_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
		_dci_p3_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT"),
		_begin_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
		_extended_srgb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
		_extended_srgb_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
		_max_enum = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
		_range_size = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
		_srgb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
		_dci_p3_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
		_pass_through = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_PASS_THROUGH_EXT"),
		_bt709_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_LINEAR_EXT"),
		_hdr10_st2084 = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_ST2084_EXT"),
		_dolbyvision = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DOLBYVISION_EXT"),
	},
	viewport_coordinate_swizzle = {
		negative_z = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"),
		negative_y = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"),
		negative_x = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"),
		max_enum = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV"),
		negative_w = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"),
		positive_z = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"),
		positive_y = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"),
		range_size = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV"),
		end_range = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV"),
		positive_x = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"),
		begin_range = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV"),
		positive_w = ffi.cast("enum VkViewportCoordinateSwizzleNV", "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"),
	},
	image_view_type = {
		["2d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
		end_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
		["2d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
		["1d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
		cube = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
		cube_array = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
		begin_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
		["1d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	},
	attachment_store_op = {
		end_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
		max_enum = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
		range_size = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
		begin_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
		dont_care = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
		store = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	},
}
function library.GetInstanceLayerProperties()
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceLayerProperties(count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceLayerProperties(count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetPhysicalDevices(instance)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumeratePhysicalDevices(instance, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDevice_T * [?]", count[0])
	local status = CLIB.vkEnumeratePhysicalDevices(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetInstanceExtensionProperties(pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetPhysicalDeviceGroups(instance)
	local count = ffi.new("uint32_t[1]")
	library.EnumeratePhysicalDeviceGroupsKHX(instance, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDeviceGroupPropertiesKHX [?]", count[0])
	local status = library.EnumeratePhysicalDeviceGroupsKHX(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetDeviceLayerProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetDeviceExtensionProperties(physicalDevice, pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetBufferMemoryRequirements(device, buffer)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetBufferMemoryRequirements(device, buffer, box)
	return box[0]
end
function library.GetPipelineCacheData(device, pipelineCache, pDataSize)
	local box = ffi.new("void [1]")
	local status = CLIB.vkGetPipelineCacheData(device, pipelineCache, pDataSize, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceGeneratedCommandsProperties(physicalDevice, pFeatures)
	if type(pFeatures) == "table" then
		pFeatures = library.s.DeviceGeneratedCommandsFeaturesNVX(pFeatures, false)
	end
	local box = ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX [1]")
	library.GetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, box)
	return box[0]
end
function library.GetRenderAreaGranularity(device, renderPass)
	local box = ffi.new("struct VkExtent2D [1]")
	CLIB.vkGetRenderAreaGranularity(device, renderPass, box)
	return box[0]
end
function library.GetPhysicalDeviceQueueFamilyProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, nil)

	local array = ffi.new("struct VkQueueFamilyProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPhysicalDeviceSurfaceCapabilities2(physicalDevice, surface)
	local box = ffi.new("struct VkSurfaceCapabilities2EXT [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo)
	if type(pImageFormatInfo) == "table" then
		pImageFormatInfo = library.s.PhysicalDeviceImageFormatInfo2KHR(pImageFormatInfo, false)
	end
	local box = ffi.new("struct VkImageFormatProperties2KHR [1]")
	local status = library.GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceFormatProperties2(physicalDevice, format)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	local box = ffi.new("struct VkFormatProperties2KHR [1]")
	library.GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, box)
	return box[0]
end
function library.GetMemoryFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.MemoryGetFdInfoKHR(pGetFdInfo, false)
	end
	local box = ffi.new("int [1]")
	local status = library.GetMemoryFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceQueueFamilyProperties2(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, count, nil)

	local array = ffi.new("struct VkQueueFamilyProperties2KHR [?]", count[0])
	library.GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetDisplayPlaneSupportedDisplays(physicalDevice, planeIndex)
	local count = ffi.new("uint32_t[1]")

	library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, nil)

	local array = ffi.new("struct VkDisplayKHR_T * [?]", count[0])
	local status = library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(samples) == "table" then
		samples = library.e.sample_count.make_enums(samples)
	elseif type(samples) == "string" then
		samples = library.e.sample_count[samples]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, nil)

	local array = ffi.new("struct VkSparseImageFormatProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPastPresentationTimingGOO(device, swapchain)
	local count = ffi.new("uint32_t[1]")

	library.GetPastPresentationTimingGOOGLE(device, swapchain, count, nil)

	local array = ffi.new("struct VkPastPresentationTimingGOOGLE [?]", count[0])
	local status = library.GetPastPresentationTimingGOOGLE(device, swapchain, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceSurfaceFormats(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, nil)

	local array = ffi.new("struct VkSurfaceFormatKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetRefreshCycleDurationGOO(device, swapchain)
	local box = ffi.new("struct VkRefreshCycleDurationGOOGLE [1]")
	local status = library.GetRefreshCycleDurationGOOGLE(device, swapchain, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetSwapchainCounter(device, swapchain, counter)
	if type(counter) == "table" then
		counter = library.e.surface_counter.make_enums(counter)
	elseif type(counter) == "string" then
		counter = library.e.surface_counter[counter]
	end
	local box = ffi.new("unsigned long [1]")
	local status = library.GetSwapchainCounterEXT(device, swapchain, counter, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageSubresourceLayout(device, image, pSubresource)
	if type(pSubresource) == "table" then
		pSubresource = library.s.ImageSubresource(pSubresource, false)
	end
	local box = ffi.new("struct VkSubresourceLayout [1]")
	CLIB.vkGetImageSubresourceLayout(device, image, pSubresource, box)
	return box[0]
end
function library.GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo)
	if type(pExternalSemaphoreInfo) == "table" then
		pExternalSemaphoreInfo = library.s.PhysicalDeviceExternalSemaphoreInfoKHR(pExternalSemaphoreInfo, false)
	end
	local box = ffi.new("struct VkExternalSemaphorePropertiesKHR [1]")
	library.GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, box)
	return box[0]
end
function library.GetFenceStatus(device)
	local box = ffi.new("struct VkFence_T [1]")
	local status = CLIB.vkGetFenceStatus(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageSparseMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageSparseMemoryRequirementsInfo2KHR(pInfo, false)
	end
	local count = ffi.new("uint32_t[1]")

	library.GetImageSparseMemoryRequirements2KHR(device, pInfo, count, nil)

	local array = ffi.new("struct VkSparseImageMemoryRequirements2KHR [?]", count[0])
	library.GetImageSparseMemoryRequirements2KHR(device, pInfo, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPhysicalDeviceSurfaceCapabilities(physicalDevice, surface)
	local box = ffi.new("struct VkSurfaceCapabilitiesKHR [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceFeatures2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures2KHR [1]")
	library.GetPhysicalDeviceFeatures2KHR(physicalDevice, box)
	return box[0]
end
function library.GetDeviceGroupPresentCapabilities(device)
	local box = ffi.new("struct VkDeviceGroupPresentCapabilitiesKHX [1]")
	local status = library.GetDeviceGroupPresentCapabilitiesKHX(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetDeviceGroupSurfacePresentModes(device, surface)
	local box = ffi.new("unsigned int [1]")
	local status = library.GetDeviceGroupSurfacePresentModesKHX(device, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceSurfaceSupport(physicalDevice, queueFamilyIndex, surface)
	local box = ffi.new("unsigned int [1]")
	local status = library.GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetSwapchainStatus(device)
	local box = ffi.new("struct VkSwapchainKHR_T [1]")
	local status = library.GetSwapchainStatusKHR(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex)
	local box = ffi.new("unsigned int [1]")
	library.GetDeviceGroupPeerMemoryFeaturesKHX(device, heapIndex, localDeviceIndex, remoteDeviceIndex, box)
	return box[0]
end
function library.GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo)
	if type(pFormatInfo) == "table" then
		pFormatInfo = library.s.PhysicalDeviceSparseImageFormatInfo2KHR(pFormatInfo, false)
	end
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, count, nil)

	local array = ffi.new("struct VkSparseImageFormatProperties2KHR [?]", count[0])
	library.GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPhysicalDeviceExternalImageFormatPropertie(physicalDevice, format, type, tiling, usage, flags, externalHandleType)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end
	if type(externalHandleType) == "table" then
		externalHandleType = library.e.external_memory_handle_type.make_enums(externalHandleType)
	elseif type(externalHandleType) == "string" then
		externalHandleType = library.e.external_memory_handle_type[externalHandleType]
	end
	local box = ffi.new("struct VkExternalImageFormatPropertiesNV [1]")
	local status = library.GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo)
	if type(pExternalFenceInfo) == "table" then
		pExternalFenceInfo = library.s.PhysicalDeviceExternalFenceInfoKHR(pExternalFenceInfo, false)
	end
	local box = ffi.new("struct VkExternalFencePropertiesKHR [1]")
	library.GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, box)
	return box[0]
end
function library.GetPhysicalDeviceFeatures(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures [1]")
	CLIB.vkGetPhysicalDeviceFeatures(physicalDevice, box)
	return box[0]
end
function library.GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end
	local box = ffi.new("struct VkImageFormatProperties [1]")
	local status = CLIB.vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetDeviceMemoryCommitment(device, memory)
	local box = ffi.new("unsigned long [1]")
	CLIB.vkGetDeviceMemoryCommitment(device, memory, box)
	return box[0]
end
function library.GetPhysicalDeviceMemoryProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties2KHR [1]")
	library.GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, box)
	return box[0]
end
function library.GetBufferMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.BufferMemoryRequirementsInfo2KHR(pInfo, false)
	end
	local box = ffi.new("struct VkMemoryRequirements2KHR [1]")
	library.GetBufferMemoryRequirements2KHR(device, pInfo, box)
	return box[0]
end
function library.GetPhysicalDeviceSurfaceFormats2(physicalDevice, pSurfaceInfo)
	if type(pSurfaceInfo) == "table" then
		pSurfaceInfo = library.s.PhysicalDeviceSurfaceInfo2KHR(pSurfaceInfo, false)
	end
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, count, nil)

	local array = ffi.new("struct VkSurfaceFormat2KHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo)
	if type(pExternalBufferInfo) == "table" then
		pExternalBufferInfo = library.s.PhysicalDeviceExternalBufferInfoKHR(pExternalBufferInfo, false)
	end
	local box = ffi.new("struct VkExternalBufferPropertiesKHR [1]")
	library.GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, box)
	return box[0]
end
function library.GetDisplayPlaneCapabilities(physicalDevice, mode, planeIndex)
	local box = ffi.new("struct VkDisplayPlaneCapabilitiesKHR [1]")
	local status = library.GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageSparseMemoryRequirements(device, image)
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, nil)

	local array = ffi.new("struct VkSparseImageMemoryRequirements [?]", count[0])
	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetImageMemoryRequirements(device, image)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetImageMemoryRequirements(device, image, box)
	return box[0]
end
function library.GetSemaphoreFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.SemaphoreGetFdInfoKHR(pGetFdInfo, false)
	end
	local box = ffi.new("int [1]")
	local status = library.GetSemaphoreFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetEventStatus(device)
	local box = ffi.new("struct VkEvent_T [1]")
	local status = CLIB.vkGetEventStatus(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceSurfaceCapabilities2(physicalDevice, pSurfaceInfo)
	if type(pSurfaceInfo) == "table" then
		pSurfaceInfo = library.s.PhysicalDeviceSurfaceInfo2KHR(pSurfaceInfo, false)
	end
	local box = ffi.new("struct VkSurfaceCapabilities2KHR [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceDisplayPlaneProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, nil)

	local array = ffi.new("struct VkDisplayPlanePropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties2KHR [1]")
	library.GetPhysicalDeviceProperties2KHR(physicalDevice, box)
	return box[0]
end
function library.GetDeviceQueue(device, queueFamilyIndex, queueIndex)
	local box = ffi.new("struct VkQueue_T * [1]")
	CLIB.vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, box)
	return box[0]
end
function library.GetMemoryFdProperties(device, handleType, fd)
	if type(handleType) == "table" then
		handleType = library.e.external_memory_handle_type.make_enums(handleType)
	elseif type(handleType) == "string" then
		handleType = library.e.external_memory_handle_type[handleType]
	end
	local box = ffi.new("struct VkMemoryFdPropertiesKHR [1]")
	local status = library.GetMemoryFdPropertiesKHR(device, handleType, fd, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceDisplayProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, nil)

	local array = ffi.new("struct VkDisplayPropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.AcquireNextImage(device, swapchain, timeout, semaphore, fence)
	local box = ffi.new("unsigned int [1]")
	local status = library.AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetSwapchainImages(device, swapchain)
	local count = ffi.new("uint32_t[1]")

	library.GetSwapchainImagesKHR(device, swapchain, count, nil)

	local array = ffi.new("struct VkImage_T * [?]", count[0])
	local status = library.GetSwapchainImagesKHR(device, swapchain, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetDisplayModeProperties(physicalDevice, display)
	local count = ffi.new("uint32_t[1]")

	library.GetDisplayModePropertiesKHR(physicalDevice, display, count, nil)

	local array = ffi.new("struct VkDisplayModePropertiesKHR [?]", count[0])
	local status = library.GetDisplayModePropertiesKHR(physicalDevice, display, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.AcquireNextImage2(device, pAcquireInfo)
	if type(pAcquireInfo) == "table" then
		pAcquireInfo = library.s.AcquireNextImageInfoKHX(pAcquireInfo, false)
	end
	local box = ffi.new("unsigned int [1]")
	local status = library.AcquireNextImage2KHX(device, pAcquireInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceSurfacePresentModes(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, nil)

	local array = ffi.new("enum VkPresentModeKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetFenceFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.FenceGetFdInfoKHR(pGetFdInfo, false)
	end
	local box = ffi.new("int [1]")
	local status = library.GetFenceFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageMemoryRequirementsInfo2KHR(pInfo, false)
	end
	local box = ffi.new("struct VkMemoryRequirements2KHR [1]")
	library.GetImageMemoryRequirements2KHR(device, pInfo, box)
	return box[0]
end
function library.GetPhysicalDeviceProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties [1]")
	CLIB.vkGetPhysicalDeviceProperties(physicalDevice, box)
	return box[0]
end
function library.GetPhysicalDeviceFormatProperties(physicalDevice, format)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	local box = ffi.new("struct VkFormatProperties [1]")
	CLIB.vkGetPhysicalDeviceFormatProperties(physicalDevice, format, box)
	return box[0]
end
function library.GetPhysicalDeviceMemoryProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties [1]")
	CLIB.vkGetPhysicalDeviceMemoryProperties(physicalDevice, box)
	return box[0]
end
function library.GetPhysicalDevicePresentRectangles(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDevicePresentRectanglesKHX(physicalDevice, surface, count, nil)

	local array = ffi.new("struct VkRect2D [?]", count[0])
	local status = library.GetPhysicalDevicePresentRectanglesKHX(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.MapMemory(device, memory, a, b, c, type, func)
	local data = ffi.new("void *[1]")

	local status = CLIB.vkMapMemory(device, memory, a, b, c, data)

	if status == "VK_SUCCESS" then
		if func then
			local ptr = func(ffi.cast(type .. " *", data[0]))
			if ptr then
				data[0] = ptr
			end
			library.UnmapMemory(device, memory)
		end
		return data[0]
	end

	return nil, status
end
	library.s = {}
function library.s.ApplicationInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_APPLICATION_INFO"
	return table_only and tbl or ffi.new("struct VkApplicationInfo", tbl)
end
function library.s.InstanceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"
	if type(tbl.pApplicationInfo) == "table" then
		tbl.pApplicationInfo = library.s.ApplicationInfo(tbl.pApplicationInfo, false)
	end
	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end
	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end
	return table_only and tbl or ffi.new("struct VkInstanceCreateInfo", tbl)
end
function library.s.DeviceQueueCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkDeviceQueueCreateInfo", tbl)
end
function library.s.DeviceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"
	if type(tbl.pQueueCreateInfos) == "table" then
		if not tbl.queueCreateInfoCount then
			tbl.queueCreateInfoCount = #tbl.pQueueCreateInfos
		end
		tbl.pQueueCreateInfos = library.s.DeviceQueueCreateInfoArray(tbl.pQueueCreateInfos, false)
	end
	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end
	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end
	if type(tbl.pEnabledFeatures) == "table" then
		tbl.pEnabledFeatures = library.s.PhysicalDeviceFeatures(tbl.pEnabledFeatures, false)
	end
	return table_only and tbl or ffi.new("struct VkDeviceCreateInfo", tbl)
end
function library.s.SubmitInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SUBMIT_INFO"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pCommandBuffers) == "table" then
		if not tbl.commandBufferCount then
			tbl.commandBufferCount = #tbl.pCommandBuffers
		end
		tbl.pCommandBuffers = library.s.CommandBufferArray(tbl.pCommandBuffers, false)
	end
	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end
		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end
	return table_only and tbl or ffi.new("struct VkSubmitInfo", tbl)
end
function library.s.MemoryAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"
	return table_only and tbl or ffi.new("struct VkMemoryAllocateInfo", tbl)
end
function library.s.MappedMemoryRange(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"
	return table_only and tbl or ffi.new("struct VkMappedMemoryRange", tbl)
end
function library.s.BindSparseInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pBufferBinds) == "table" then
		if not tbl.bufferBindCount then
			tbl.bufferBindCount = #tbl.pBufferBinds
		end
		tbl.pBufferBinds = library.s.SparseBufferMemoryBindInfoArray(tbl.pBufferBinds, false)
	end
	if type(tbl.pImageOpaqueBinds) == "table" then
		if not tbl.imageOpaqueBindCount then
			tbl.imageOpaqueBindCount = #tbl.pImageOpaqueBinds
		end
		tbl.pImageOpaqueBinds = library.s.SparseImageOpaqueMemoryBindInfoArray(tbl.pImageOpaqueBinds, false)
	end
	if type(tbl.pImageBinds) == "table" then
		if not tbl.imageBindCount then
			tbl.imageBindCount = #tbl.pImageBinds
		end
		tbl.pImageBinds = library.s.SparseImageMemoryBindInfoArray(tbl.pImageBinds, false)
	end
	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end
		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end
	return table_only and tbl or ffi.new("struct VkBindSparseInfo", tbl)
end
function library.s.FenceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.fence_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.fence_create[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkFenceCreateInfo", tbl)
end
function library.s.SemaphoreCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkSemaphoreCreateInfo", tbl)
end
function library.s.EventCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkEventCreateInfo", tbl)
end
function library.s.QueryPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"
	if type(tbl.queryType) == "string" then
		tbl.queryType = library.e.query_type[tbl.queryType]
	end
	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end
	return table_only and tbl or ffi.new("struct VkQueryPoolCreateInfo", tbl)
end
function library.s.BufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.buffer_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.buffer_create[tbl.flags]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.buffer_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.buffer_usage[tbl.usage]
	end
	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end
	return table_only and tbl or ffi.new("struct VkBufferCreateInfo", tbl)
end
function library.s.BufferViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	return table_only and tbl or ffi.new("struct VkBufferViewCreateInfo", tbl)
end
function library.s.ImageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end
	if type(tbl.imageType) == "string" then
		tbl.imageType = library.e.image_type[tbl.imageType]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end
	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end
	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end
	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end
	return table_only and tbl or ffi.new("struct VkImageCreateInfo", tbl)
end
function library.s.ImageViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"
	if type(tbl.viewType) == "string" then
		tbl.viewType = library.e.image_view_type[tbl.viewType]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.components) == "table" then
		tbl.components = library.s.ComponentMapping(tbl.components, true)
	end
	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end
	return table_only and tbl or ffi.new("struct VkImageViewCreateInfo", tbl)
end
function library.s.ShaderModuleCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkShaderModuleCreateInfo", tbl)
end
function library.s.PipelineCacheCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkPipelineCacheCreateInfo", tbl)
end
function library.s.PipelineShaderStageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"
	if type(tbl.stage) == "table" then
		tbl.stage = library.e.shader_stage.make_enums(tbl.stage)
	elseif type(tbl.stage) == "string" then
		tbl.stage = library.e.shader_stage[tbl.stage]
	end
	if type(tbl.pSpecializationInfo) == "table" then
		tbl.pSpecializationInfo = library.s.SpecializationInfo(tbl.pSpecializationInfo, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineShaderStageCreateInfo", tbl)
end
function library.s.PipelineVertexInputStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"
	if type(tbl.pVertexBindingDescriptions) == "table" then
		if not tbl.vertexBindingDescriptionCount then
			tbl.vertexBindingDescriptionCount = #tbl.pVertexBindingDescriptions
		end
		tbl.pVertexBindingDescriptions = library.s.VertexInputBindingDescriptionArray(tbl.pVertexBindingDescriptions, false)
	end
	if type(tbl.pVertexAttributeDescriptions) == "table" then
		if not tbl.vertexAttributeDescriptionCount then
			tbl.vertexAttributeDescriptionCount = #tbl.pVertexAttributeDescriptions
		end
		tbl.pVertexAttributeDescriptions = library.s.VertexInputAttributeDescriptionArray(tbl.pVertexAttributeDescriptions, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineVertexInputStateCreateInfo", tbl)
end
function library.s.PipelineInputAssemblyStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"
	if type(tbl.topology) == "string" then
		tbl.topology = library.e.primitive_topology[tbl.topology]
	end
	tbl.primitiveRestartEnable = tbl.primitiveRestartEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineInputAssemblyStateCreateInfo", tbl)
end
function library.s.PipelineTessellationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkPipelineTessellationStateCreateInfo", tbl)
end
function library.s.PipelineViewportStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"
	if type(tbl.pViewports) == "table" then
		if not tbl.viewportCount then
			tbl.viewportCount = #tbl.pViewports
		end
		tbl.pViewports = library.s.ViewportArray(tbl.pViewports, false)
	end
	if type(tbl.pScissors) == "table" then
		if not tbl.scissorCount then
			tbl.scissorCount = #tbl.pScissors
		end
		tbl.pScissors = library.s.Rect2DArray(tbl.pScissors, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineViewportStateCreateInfo", tbl)
end
function library.s.PipelineRasterizationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"
	tbl.depthClampEnable = tbl.depthClampEnable and 1 or 0
	tbl.rasterizerDiscardEnable = tbl.rasterizerDiscardEnable and 1 or 0
	if type(tbl.polygonMode) == "string" then
		tbl.polygonMode = library.e.polygon_mode[tbl.polygonMode]
	end
	if type(tbl.cullMode) == "table" then
		tbl.cullMode = library.e.cull_mode.make_enums(tbl.cullMode)
	elseif type(tbl.cullMode) == "string" then
		tbl.cullMode = library.e.cull_mode[tbl.cullMode]
	end
	if type(tbl.frontFace) == "string" then
		tbl.frontFace = library.e.front_face[tbl.frontFace]
	end
	tbl.depthBiasEnable = tbl.depthBiasEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineRasterizationStateCreateInfo", tbl)
end
function library.s.PipelineMultisampleStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"
	if type(tbl.rasterizationSamples) == "table" then
		tbl.rasterizationSamples = library.e.sample_count.make_enums(tbl.rasterizationSamples)
	elseif type(tbl.rasterizationSamples) == "string" then
		tbl.rasterizationSamples = library.e.sample_count[tbl.rasterizationSamples]
	end
	tbl.sampleShadingEnable = tbl.sampleShadingEnable and 1 or 0
	tbl.alphaToCoverageEnable = tbl.alphaToCoverageEnable and 1 or 0
	tbl.alphaToOneEnable = tbl.alphaToOneEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineMultisampleStateCreateInfo", tbl)
end
function library.s.PipelineDepthStencilStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"
	tbl.depthTestEnable = tbl.depthTestEnable and 1 or 0
	tbl.depthWriteEnable = tbl.depthWriteEnable and 1 or 0
	if type(tbl.depthCompareOp) == "string" then
		tbl.depthCompareOp = library.e.compare_op[tbl.depthCompareOp]
	end
	tbl.depthBoundsTestEnable = tbl.depthBoundsTestEnable and 1 or 0
	tbl.stencilTestEnable = tbl.stencilTestEnable and 1 or 0
	if type(tbl.front) == "table" then
		tbl.front = library.s.StencilOpState(tbl.front, true)
	end
	if type(tbl.back) == "table" then
		tbl.back = library.s.StencilOpState(tbl.back, true)
	end
	return table_only and tbl or ffi.new("struct VkPipelineDepthStencilStateCreateInfo", tbl)
end
function library.s.PipelineColorBlendStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"
	tbl.logicOpEnable = tbl.logicOpEnable and 1 or 0
	if type(tbl.logicOp) == "string" then
		tbl.logicOp = library.e.logic_op[tbl.logicOp]
	end
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.PipelineColorBlendAttachmentStateArray(tbl.pAttachments, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineColorBlendStateCreateInfo", tbl)
end
function library.s.PipelineDynamicStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"
	if type(tbl.pDynamicStates) == "string" then
		tbl.pDynamicStates = library.e.dynamic_state[tbl.pDynamicStates]
	end
	return table_only and tbl or ffi.new("struct VkPipelineDynamicStateCreateInfo", tbl)
end
function library.s.GraphicsPipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end
	if type(tbl.pStages) == "table" then
		if not tbl.stageCount then
			tbl.stageCount = #tbl.pStages
		end
		tbl.pStages = library.s.PipelineShaderStageCreateInfoArray(tbl.pStages, false)
	end
	if type(tbl.pVertexInputState) == "table" then
		tbl.pVertexInputState = library.s.PipelineVertexInputStateCreateInfo(tbl.pVertexInputState, false)
	end
	if type(tbl.pInputAssemblyState) == "table" then
		tbl.pInputAssemblyState = library.s.PipelineInputAssemblyStateCreateInfo(tbl.pInputAssemblyState, false)
	end
	if type(tbl.pTessellationState) == "table" then
		tbl.pTessellationState = library.s.PipelineTessellationStateCreateInfo(tbl.pTessellationState, false)
	end
	if type(tbl.pViewportState) == "table" then
		tbl.pViewportState = library.s.PipelineViewportStateCreateInfo(tbl.pViewportState, false)
	end
	if type(tbl.pRasterizationState) == "table" then
		tbl.pRasterizationState = library.s.PipelineRasterizationStateCreateInfo(tbl.pRasterizationState, false)
	end
	if type(tbl.pMultisampleState) == "table" then
		tbl.pMultisampleState = library.s.PipelineMultisampleStateCreateInfo(tbl.pMultisampleState, false)
	end
	if type(tbl.pDepthStencilState) == "table" then
		tbl.pDepthStencilState = library.s.PipelineDepthStencilStateCreateInfo(tbl.pDepthStencilState, false)
	end
	if type(tbl.pColorBlendState) == "table" then
		tbl.pColorBlendState = library.s.PipelineColorBlendStateCreateInfo(tbl.pColorBlendState, false)
	end
	if type(tbl.pDynamicState) == "table" then
		tbl.pDynamicState = library.s.PipelineDynamicStateCreateInfo(tbl.pDynamicState, false)
	end
	return table_only and tbl or ffi.new("struct VkGraphicsPipelineCreateInfo", tbl)
end
function library.s.ComputePipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end
	if type(tbl.stage) == "table" then
		tbl.stage = library.s.PipelineShaderStageCreateInfo(tbl.stage, true)
	end
	return table_only and tbl or ffi.new("struct VkComputePipelineCreateInfo", tbl)
end
function library.s.PipelineLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"
	if type(tbl.pSetLayouts) == "table" then
		if not tbl.setLayoutCount then
			tbl.setLayoutCount = #tbl.pSetLayouts
		end
		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end
	if type(tbl.pPushConstantRanges) == "table" then
		if not tbl.pushConstantRangeCount then
			tbl.pushConstantRangeCount = #tbl.pPushConstantRanges
		end
		tbl.pPushConstantRanges = library.s.PushConstantRangeArray(tbl.pPushConstantRanges, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineLayoutCreateInfo", tbl)
end
function library.s.SamplerCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"
	if type(tbl.magFilter) == "string" then
		tbl.magFilter = library.e.filter[tbl.magFilter]
	end
	if type(tbl.minFilter) == "string" then
		tbl.minFilter = library.e.filter[tbl.minFilter]
	end
	if type(tbl.mipmapMode) == "string" then
		tbl.mipmapMode = library.e.sampler_mipmap_mode[tbl.mipmapMode]
	end
	if type(tbl.addressModeU) == "string" then
		tbl.addressModeU = library.e.sampler_address_mode[tbl.addressModeU]
	end
	if type(tbl.addressModeV) == "string" then
		tbl.addressModeV = library.e.sampler_address_mode[tbl.addressModeV]
	end
	if type(tbl.addressModeW) == "string" then
		tbl.addressModeW = library.e.sampler_address_mode[tbl.addressModeW]
	end
	tbl.anisotropyEnable = tbl.anisotropyEnable and 1 or 0
	tbl.compareEnable = tbl.compareEnable and 1 or 0
	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end
	if type(tbl.borderColor) == "string" then
		tbl.borderColor = library.e.border_color[tbl.borderColor]
	end
	return table_only and tbl or ffi.new("struct VkSamplerCreateInfo", tbl)
end
function library.s.DescriptorSetLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.descriptor_set_layout_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.descriptor_set_layout_create[tbl.flags]
	end
	if type(tbl.pBindings) == "table" then
		if not tbl.bindingCount then
			tbl.bindingCount = #tbl.pBindings
		end
		tbl.pBindings = library.s.DescriptorSetLayoutBindingArray(tbl.pBindings, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutCreateInfo", tbl)
end
function library.s.DescriptorPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.descriptor_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.descriptor_pool_create[tbl.flags]
	end
	if type(tbl.pPoolSizes) == "table" then
		if not tbl.poolSizeCount then
			tbl.poolSizeCount = #tbl.pPoolSizes
		end
		tbl.pPoolSizes = library.s.DescriptorPoolSizeArray(tbl.pPoolSizes, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorPoolCreateInfo", tbl)
end
function library.s.DescriptorSetAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"
	if type(tbl.pSetLayouts) == "table" then
		if not tbl.descriptorSetCount then
			tbl.descriptorSetCount = #tbl.pSetLayouts
		end
		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetAllocateInfo", tbl)
end
function library.s.WriteDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end
	if type(tbl.pImageInfo) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pImageInfo
		end
		tbl.pImageInfo = library.s.DescriptorImageInfoArray(tbl.pImageInfo)
	end
	if type(tbl.pBufferInfo) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pBufferInfo
		end
		tbl.pBufferInfo = library.s.DescriptorBufferInfoArray(tbl.pBufferInfo)
	end
	if type(tbl.pTexelBufferView) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pTexelBufferView
		end
		tbl.pTexelBufferView = library.s.BufferViewArray(tbl.pTexelBufferView)
	end
	return table_only and tbl or ffi.new("struct VkWriteDescriptorSet", tbl)
end
function library.s.CopyDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"
	return table_only and tbl or ffi.new("struct VkCopyDescriptorSet", tbl)
end
function library.s.FramebufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.ImageViewArray(tbl.pAttachments, false)
	end
	return table_only and tbl or ffi.new("struct VkFramebufferCreateInfo", tbl)
end
function library.s.RenderPassCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.AttachmentDescriptionArray(tbl.pAttachments, false)
	end
	if type(tbl.pSubpasses) == "table" then
		if not tbl.subpassCount then
			tbl.subpassCount = #tbl.pSubpasses
		end
		tbl.pSubpasses = library.s.SubpassDescriptionArray(tbl.pSubpasses, false)
	end
	if type(tbl.pDependencies) == "table" then
		if not tbl.dependencyCount then
			tbl.dependencyCount = #tbl.pDependencies
		end
		tbl.pDependencies = library.s.SubpassDependencyArray(tbl.pDependencies, false)
	end
	return table_only and tbl or ffi.new("struct VkRenderPassCreateInfo", tbl)
end
function library.s.CommandPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_pool_create[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkCommandPoolCreateInfo", tbl)
end
function library.s.CommandBufferAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"
	if type(tbl.level) == "string" then
		tbl.level = library.e.command_buffer_level[tbl.level]
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferAllocateInfo", tbl)
end
function library.s.CommandBufferInheritanceInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"
	tbl.occlusionQueryEnable = tbl.occlusionQueryEnable and 1 or 0
	if type(tbl.queryFlags) == "table" then
		tbl.queryFlags = library.e.query_control.make_enums(tbl.queryFlags)
	elseif type(tbl.queryFlags) == "string" then
		tbl.queryFlags = library.e.query_control[tbl.queryFlags]
	end
	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferInheritanceInfo", tbl)
end
function library.s.CommandBufferBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_buffer_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_buffer_usage[tbl.flags]
	end
	if type(tbl.pInheritanceInfo) == "table" then
		tbl.pInheritanceInfo = library.s.CommandBufferInheritanceInfo(tbl.pInheritanceInfo, false)
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferBeginInfo", tbl)
end
function library.s.RenderPassBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"
	if type(tbl.renderArea) == "table" then
		tbl.renderArea = library.s.Rect2D(tbl.renderArea, true)
	end
	if type(tbl.pClearValues) == "table" then
		if not tbl.clearValueCount then
			tbl.clearValueCount = #tbl.pClearValues
		end
		tbl.pClearValues = library.s.ClearValueArray(tbl.pClearValues, false)
	end
	return table_only and tbl or ffi.new("struct VkRenderPassBeginInfo", tbl)
end
function library.s.BufferMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	return table_only and tbl or ffi.new("struct VkBufferMemoryBarrier", tbl)
end
function library.s.ImageMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	if type(tbl.oldLayout) == "string" then
		tbl.oldLayout = library.e.image_layout[tbl.oldLayout]
	end
	if type(tbl.newLayout) == "string" then
		tbl.newLayout = library.e.image_layout[tbl.newLayout]
	end
	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end
	return table_only and tbl or ffi.new("struct VkImageMemoryBarrier", tbl)
end
function library.s.MemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	return table_only and tbl or ffi.new("struct VkMemoryBarrier", tbl)
end
function library.s.SwapchainCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.swapchain_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.swapchain_create[tbl.flags]
	end
	if type(tbl.imageFormat) == "string" then
		tbl.imageFormat = library.e.format[tbl.imageFormat]
	end
	if type(tbl.imageColorSpace) == "string" then
		tbl.imageColorSpace = library.e.colorspace[tbl.imageColorSpace]
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end
	if type(tbl.imageUsage) == "table" then
		tbl.imageUsage = library.e.image_usage.make_enums(tbl.imageUsage)
	elseif type(tbl.imageUsage) == "string" then
		tbl.imageUsage = library.e.image_usage[tbl.imageUsage]
	end
	if type(tbl.imageSharingMode) == "string" then
		tbl.imageSharingMode = library.e.sharing_mode[tbl.imageSharingMode]
	end
	if type(tbl.preTransform) == "table" then
		tbl.preTransform = library.e.surface_transform.make_enums(tbl.preTransform)
	elseif type(tbl.preTransform) == "string" then
		tbl.preTransform = library.e.surface_transform[tbl.preTransform]
	end
	if type(tbl.compositeAlpha) == "table" then
		tbl.compositeAlpha = library.e.composite_alpha.make_enums(tbl.compositeAlpha)
	elseif type(tbl.compositeAlpha) == "string" then
		tbl.compositeAlpha = library.e.composite_alpha[tbl.compositeAlpha]
	end
	if type(tbl.presentMode) == "string" then
		tbl.presentMode = library.e.present_mode[tbl.presentMode]
	end
	return table_only and tbl or ffi.new("struct VkSwapchainCreateInfoKHR", tbl)
end
function library.s.PresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pSwapchains) == "table" then
		if not tbl.swapchainCount then
			tbl.swapchainCount = #tbl.pSwapchains
		end
		tbl.pSwapchains = library.s.SwapchainKHRArray(tbl.pSwapchains, false)
	end
	if type(tbl.pResults) == "string" then
		tbl.pResults = library.e.result[tbl.pResults]
	end
	return table_only and tbl or ffi.new("struct VkPresentInfoKHR", tbl)
end
function library.s.DisplayModeCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"
	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModeCreateInfoKHR", tbl)
end
function library.s.DisplaySurfaceCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"
	if type(tbl.transform) == "table" then
		tbl.transform = library.e.surface_transform.make_enums(tbl.transform)
	elseif type(tbl.transform) == "string" then
		tbl.transform = library.e.surface_transform[tbl.transform]
	end
	if type(tbl.alphaMode) == "table" then
		tbl.alphaMode = library.e.display_plane_alpha.make_enums(tbl.alphaMode)
	elseif type(tbl.alphaMode) == "string" then
		tbl.alphaMode = library.e.display_plane_alpha[tbl.alphaMode]
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplaySurfaceCreateInfoKHR", tbl)
end
function library.s.DisplayPresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"
	if type(tbl.srcRect) == "table" then
		tbl.srcRect = library.s.Rect2D(tbl.srcRect, true)
	end
	if type(tbl.dstRect) == "table" then
		tbl.dstRect = library.s.Rect2D(tbl.dstRect, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayPresentInfoKHR", tbl)
end
function library.s.DebugReportCallbackCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.debug_report.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.debug_report[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkDebugReportCallbackCreateInfoEXT", tbl)
end
function library.s.PipelineRasterizationStateRasterizationOrderAMD(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"
	if type(tbl.rasterizationOrder) == "string" then
		tbl.rasterizationOrder = library.e.rasterization_order[tbl.rasterizationOrder]
	end
	return table_only and tbl or ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD", tbl)
end
function library.s.DebugMarkerObjectNameInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"
	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end
	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectNameInfoEXT", tbl)
end
function library.s.DebugMarkerObjectTagInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"
	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end
	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectTagInfoEXT", tbl)
end
function library.s.DebugMarkerMarkerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"
	return table_only and tbl or ffi.new("struct VkDebugMarkerMarkerInfoEXT", tbl)
end
function library.s.DedicatedAllocationImageCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationImageCreateInfoNV", tbl)
end
function library.s.DedicatedAllocationBufferCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV", tbl)
end
function library.s.DedicatedAllocationMemoryAllocateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV", tbl)
end
function library.s.RenderPassMultiviewCreateInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkRenderPassMultiviewCreateInfoKHX", tbl)
end
function library.s.PhysicalDeviceMultiviewFeaturesKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMultiviewFeaturesKHX", tbl)
end
function library.s.PhysicalDeviceMultiviewPropertiesKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMultiviewPropertiesKHX", tbl)
end
function library.s.ExternalMemoryImageCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalMemoryImageCreateInfoNV", tbl)
end
function library.s.ExportMemoryAllocateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExportMemoryAllocateInfoNV", tbl)
end
function library.s.MemoryAllocateFlagsInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.memory_allocate.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.memory_allocate[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkMemoryAllocateFlagsInfoKHX", tbl)
end
function library.s.BindBufferMemoryInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkBindBufferMemoryInfoKHX", tbl)
end
function library.s.BindImageMemoryInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX"
	if type(tbl.pSFRRects) == "table" then
		if not tbl.SFRRectCount then
			tbl.SFRRectCount = #tbl.pSFRRects
		end
		tbl.pSFRRects = library.s.Rect2DArray(tbl.pSFRRects, false)
	end
	return table_only and tbl or ffi.new("struct VkBindImageMemoryInfoKHX", tbl)
end
function library.s.DeviceGroupRenderPassBeginInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX"
	if type(tbl.pDeviceRenderAreas) == "table" then
		if not tbl.deviceRenderAreaCount then
			tbl.deviceRenderAreaCount = #tbl.pDeviceRenderAreas
		end
		tbl.pDeviceRenderAreas = library.s.Rect2DArray(tbl.pDeviceRenderAreas, false)
	end
	return table_only and tbl or ffi.new("struct VkDeviceGroupRenderPassBeginInfoKHX", tbl)
end
function library.s.DeviceGroupCommandBufferBeginInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkDeviceGroupCommandBufferBeginInfoKHX", tbl)
end
function library.s.DeviceGroupSubmitInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkDeviceGroupSubmitInfoKHX", tbl)
end
function library.s.DeviceGroupBindSparseInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkDeviceGroupBindSparseInfoKHX", tbl)
end
function library.s.DeviceGroupPresentCapabilitiesKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX"
	if type(tbl.modes) == "table" then
		tbl.modes = library.e.device_group_present_mode.make_enums(tbl.modes)
	elseif type(tbl.modes) == "string" then
		tbl.modes = library.e.device_group_present_mode[tbl.modes]
	end
	return table_only and tbl or ffi.new("struct VkDeviceGroupPresentCapabilitiesKHX", tbl)
end
function library.s.ImageSwapchainCreateInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkImageSwapchainCreateInfoKHX", tbl)
end
function library.s.BindImageMemorySwapchainInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkBindImageMemorySwapchainInfoKHX", tbl)
end
function library.s.AcquireNextImageInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX"
	return table_only and tbl or ffi.new("struct VkAcquireNextImageInfoKHX", tbl)
end
function library.s.DeviceGroupPresentInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX"
	if type(tbl.mode) == "table" then
		tbl.mode = library.e.device_group_present_mode.make_enums(tbl.mode)
	elseif type(tbl.mode) == "string" then
		tbl.mode = library.e.device_group_present_mode[tbl.mode]
	end
	return table_only and tbl or ffi.new("struct VkDeviceGroupPresentInfoKHX", tbl)
end
function library.s.DeviceGroupSwapchainCreateInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX"
	if type(tbl.modes) == "table" then
		tbl.modes = library.e.device_group_present_mode.make_enums(tbl.modes)
	elseif type(tbl.modes) == "string" then
		tbl.modes = library.e.device_group_present_mode[tbl.modes]
	end
	return table_only and tbl or ffi.new("struct VkDeviceGroupSwapchainCreateInfoKHX", tbl)
end
function library.s.ValidationFlagsEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"
	if type(tbl.pDisabledValidationChecks) == "string" then
		tbl.pDisabledValidationChecks = library.e.validation_check[tbl.pDisabledValidationChecks]
	end
	return table_only and tbl or ffi.new("struct VkValidationFlagsEXT", tbl)
end
function library.s.PhysicalDeviceGroupPropertiesKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX"
	if type(tbl.physicalDevices) == "table" then
		if not tbl.physicalDeviceCount then
			tbl.physicalDeviceCount = #tbl.physicalDevices
		end
		tbl.physicalDevices = library.s.PhysicalDeviceArray(tbl.physicalDevices, false)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceGroupPropertiesKHX", tbl)
end
function library.s.DeviceGroupDeviceCreateInfoKHX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX"
	if type(tbl.pPhysicalDevices) == "table" then
		if not tbl.physicalDeviceCount then
			tbl.physicalDeviceCount = #tbl.pPhysicalDevices
		end
		tbl.pPhysicalDevices = library.s.PhysicalDeviceArray(tbl.pPhysicalDevices, false)
	end
	return table_only and tbl or ffi.new("struct VkDeviceGroupDeviceCreateInfoKHX", tbl)
end
function library.s.PhysicalDeviceExternalImageFormatInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalImageFormatInfoKHR", tbl)
end
function library.s.ExternalImageFormatPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"
	if type(tbl.externalMemoryProperties) == "table" then
		tbl.externalMemoryProperties = library.s.ExternalMemoryPropertiesKHR(tbl.externalMemoryProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkExternalImageFormatPropertiesKHR", tbl)
end
function library.s.PhysicalDeviceExternalBufferInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.buffer_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.buffer_create[tbl.flags]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.buffer_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.buffer_usage[tbl.usage]
	end
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalBufferInfoKHR", tbl)
end
function library.s.ExternalBufferPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"
	if type(tbl.externalMemoryProperties) == "table" then
		tbl.externalMemoryProperties = library.s.ExternalMemoryPropertiesKHR(tbl.externalMemoryProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkExternalBufferPropertiesKHR", tbl)
end
function library.s.ExternalMemoryBufferCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalMemoryBufferCreateInfoKHR", tbl)
end
function library.s.ExternalMemoryImageCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalMemoryImageCreateInfoKHR", tbl)
end
function library.s.ExportMemoryAllocateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExportMemoryAllocateInfoKHR", tbl)
end
function library.s.ImportMemoryFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkImportMemoryFdInfoKHR", tbl)
end
function library.s.MemoryFdPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"
	return table_only and tbl or ffi.new("struct VkMemoryFdPropertiesKHR", tbl)
end
function library.s.MemoryGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkMemoryGetFdInfoKHR", tbl)
end
function library.s.PhysicalDeviceExternalSemaphoreInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalSemaphoreInfoKHR", tbl)
end
function library.s.ExternalSemaphorePropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"
	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_semaphore_handle_type[tbl.exportFromImportedHandleTypes]
	end
	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_semaphore_handle_type[tbl.compatibleHandleTypes]
	end
	if type(tbl.externalSemaphoreFeatures) == "table" then
		tbl.externalSemaphoreFeatures = library.e.external_semaphore_feature.make_enums(tbl.externalSemaphoreFeatures)
	elseif type(tbl.externalSemaphoreFeatures) == "string" then
		tbl.externalSemaphoreFeatures = library.e.external_semaphore_feature[tbl.externalSemaphoreFeatures]
	end
	return table_only and tbl or ffi.new("struct VkExternalSemaphorePropertiesKHR", tbl)
end
function library.s.ExportSemaphoreCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_semaphore_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExportSemaphoreCreateInfoKHR", tbl)
end
function library.s.ImportSemaphoreFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.semaphore_import.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.semaphore_import[tbl.flags]
	end
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkImportSemaphoreFdInfoKHR", tbl)
end
function library.s.SemaphoreGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkSemaphoreGetFdInfoKHR", tbl)
end
function library.s.PhysicalDevicePushDescriptorPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"
	return table_only and tbl or ffi.new("struct VkPhysicalDevicePushDescriptorPropertiesKHR", tbl)
end
function library.s.PresentRegionsKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"
	if type(tbl.pRegions) == "table" then
		if not tbl.swapchainCount then
			tbl.swapchainCount = #tbl.pRegions
		end
		tbl.pRegions = library.s.PresentRegionKHRArray(tbl.pRegions, false)
	end
	return table_only and tbl or ffi.new("struct VkPresentRegionsKHR", tbl)
end
function library.s.DescriptorUpdateTemplateCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"
	if type(tbl.pDescriptorUpdateEntries) == "table" then
		if not tbl.descriptorUpdateEntryCount then
			tbl.descriptorUpdateEntryCount = #tbl.pDescriptorUpdateEntries
		end
		tbl.pDescriptorUpdateEntries = library.s.DescriptorUpdateTemplateEntryKHRArray(tbl.pDescriptorUpdateEntries, false)
	end
	if type(tbl.templateType) == "string" then
		tbl.templateType = library.e.descriptor_update_template_type[tbl.templateType]
	end
	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorUpdateTemplateCreateInfoKHR", tbl)
end
function library.s.ObjectTableCreateInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"
	if type(tbl.pObjectEntryTypes) == "string" then
		tbl.pObjectEntryTypes = library.e.object_entry_type[tbl.pObjectEntryTypes]
	end
	return table_only and tbl or ffi.new("struct VkObjectTableCreateInfoNVX", tbl)
end
function library.s.IndirectCommandsLayoutCreateInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"
	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.indirect_commands_layout_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.indirect_commands_layout_usage[tbl.flags]
	end
	if type(tbl.pTokens) == "table" then
		if not tbl.tokenCount then
			tbl.tokenCount = #tbl.pTokens
		end
		tbl.pTokens = library.s.IndirectCommandsLayoutTokenNVXArray(tbl.pTokens, false)
	end
	return table_only and tbl or ffi.new("struct VkIndirectCommandsLayoutCreateInfoNVX", tbl)
end
function library.s.CmdProcessCommandsInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"
	if type(tbl.pIndirectCommandsTokens) == "table" then
		if not tbl.indirectCommandsTokenCount then
			tbl.indirectCommandsTokenCount = #tbl.pIndirectCommandsTokens
		end
		tbl.pIndirectCommandsTokens = library.s.IndirectCommandsTokenNVXArray(tbl.pIndirectCommandsTokens, false)
	end
	return table_only and tbl or ffi.new("struct VkCmdProcessCommandsInfoNVX", tbl)
end
function library.s.CmdReserveSpaceForCommandsInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"
	return table_only and tbl or ffi.new("struct VkCmdReserveSpaceForCommandsInfoNVX", tbl)
end
function library.s.DeviceGeneratedCommandsLimitsNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"
	return table_only and tbl or ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX", tbl)
end
function library.s.DeviceGeneratedCommandsFeaturesNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"
	return table_only and tbl or ffi.new("struct VkDeviceGeneratedCommandsFeaturesNVX", tbl)
end
function library.s.PipelineViewportWScalingStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"
	tbl.viewportWScalingEnable = tbl.viewportWScalingEnable and 1 or 0
	if type(tbl.pViewportWScalings) == "table" then
		if not tbl.viewportCount then
			tbl.viewportCount = #tbl.pViewportWScalings
		end
		tbl.pViewportWScalings = library.s.ViewportWScalingNVArray(tbl.pViewportWScalings, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineViewportWScalingStateCreateInfoNV", tbl)
end
function library.s.SurfaceCapabilities2EXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT"
	if type(tbl.currentExtent) == "table" then
		tbl.currentExtent = library.s.Extent2D(tbl.currentExtent, true)
	end
	if type(tbl.minImageExtent) == "table" then
		tbl.minImageExtent = library.s.Extent2D(tbl.minImageExtent, true)
	end
	if type(tbl.maxImageExtent) == "table" then
		tbl.maxImageExtent = library.s.Extent2D(tbl.maxImageExtent, true)
	end
	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end
	if type(tbl.currentTransform) == "table" then
		tbl.currentTransform = library.e.surface_transform.make_enums(tbl.currentTransform)
	elseif type(tbl.currentTransform) == "string" then
		tbl.currentTransform = library.e.surface_transform[tbl.currentTransform]
	end
	if type(tbl.supportedCompositeAlpha) == "table" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha.make_enums(tbl.supportedCompositeAlpha)
	elseif type(tbl.supportedCompositeAlpha) == "string" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha[tbl.supportedCompositeAlpha]
	end
	if type(tbl.supportedUsageFlags) == "table" then
		tbl.supportedUsageFlags = library.e.image_usage.make_enums(tbl.supportedUsageFlags)
	elseif type(tbl.supportedUsageFlags) == "string" then
		tbl.supportedUsageFlags = library.e.image_usage[tbl.supportedUsageFlags]
	end
	if type(tbl.supportedSurfaceCounters) == "table" then
		tbl.supportedSurfaceCounters = library.e.surface_counter.make_enums(tbl.supportedSurfaceCounters)
	elseif type(tbl.supportedSurfaceCounters) == "string" then
		tbl.supportedSurfaceCounters = library.e.surface_counter[tbl.supportedSurfaceCounters]
	end
	return table_only and tbl or ffi.new("struct VkSurfaceCapabilities2EXT", tbl)
end
function library.s.DisplayPowerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"
	if type(tbl.powerState) == "string" then
		tbl.powerState = library.e.display_power_state[tbl.powerState]
	end
	return table_only and tbl or ffi.new("struct VkDisplayPowerInfoEXT", tbl)
end
function library.s.DeviceEventInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"
	if type(tbl.deviceEvent) == "string" then
		tbl.deviceEvent = library.e.device_event_type[tbl.deviceEvent]
	end
	return table_only and tbl or ffi.new("struct VkDeviceEventInfoEXT", tbl)
end
function library.s.DisplayEventInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"
	if type(tbl.displayEvent) == "string" then
		tbl.displayEvent = library.e.display_event_type[tbl.displayEvent]
	end
	return table_only and tbl or ffi.new("struct VkDisplayEventInfoEXT", tbl)
end
function library.s.SwapchainCounterCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"
	if type(tbl.surfaceCounters) == "table" then
		tbl.surfaceCounters = library.e.surface_counter.make_enums(tbl.surfaceCounters)
	elseif type(tbl.surfaceCounters) == "string" then
		tbl.surfaceCounters = library.e.surface_counter[tbl.surfaceCounters]
	end
	return table_only and tbl or ffi.new("struct VkSwapchainCounterCreateInfoEXT", tbl)
end
function library.s.PresentTimesInfoGOOGLE(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"
	if type(tbl.pTimes) == "table" then
		if not tbl.swapchainCount then
			tbl.swapchainCount = #tbl.pTimes
		end
		tbl.pTimes = library.s.PresentTimeGOOGLEArray(tbl.pTimes, false)
	end
	return table_only and tbl or ffi.new("struct VkPresentTimesInfoGOOGLE", tbl)
end
function library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", tbl)
end
function library.s.PipelineViewportSwizzleStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"
	if type(tbl.pViewportSwizzles) == "table" then
		if not tbl.viewportCount then
			tbl.viewportCount = #tbl.pViewportSwizzles
		end
		tbl.pViewportSwizzles = library.s.ViewportSwizzleNVArray(tbl.pViewportSwizzles, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineViewportSwizzleStateCreateInfoNV", tbl)
end
function library.s.PhysicalDeviceDiscardRectanglePropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceDiscardRectanglePropertiesEXT", tbl)
end
function library.s.PipelineDiscardRectangleStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"
	if type(tbl.discardRectangleMode) == "string" then
		tbl.discardRectangleMode = library.e.discard_rectangle_mode[tbl.discardRectangleMode]
	end
	if type(tbl.pDiscardRectangles) == "table" then
		if not tbl.discardRectangleCount then
			tbl.discardRectangleCount = #tbl.pDiscardRectangles
		end
		tbl.pDiscardRectangles = library.s.Rect2DArray(tbl.pDiscardRectangles, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineDiscardRectangleStateCreateInfoEXT", tbl)
end
function library.s.HdrMetadataEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"
	if type(tbl.displayPrimaryRed) == "table" then
		tbl.displayPrimaryRed = library.s.XYColorEXT(tbl.displayPrimaryRed, true)
	end
	if type(tbl.displayPrimaryGreen) == "table" then
		tbl.displayPrimaryGreen = library.s.XYColorEXT(tbl.displayPrimaryGreen, true)
	end
	if type(tbl.displayPrimaryBlue) == "table" then
		tbl.displayPrimaryBlue = library.s.XYColorEXT(tbl.displayPrimaryBlue, true)
	end
	if type(tbl.whitePoint) == "table" then
		tbl.whitePoint = library.s.XYColorEXT(tbl.whitePoint, true)
	end
	return table_only and tbl or ffi.new("struct VkHdrMetadataEXT", tbl)
end
function library.s.SharedPresentSurfaceCapabilitiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"
	if type(tbl.sharedPresentSupportedUsageFlags) == "table" then
		tbl.sharedPresentSupportedUsageFlags = library.e.image_usage.make_enums(tbl.sharedPresentSupportedUsageFlags)
	elseif type(tbl.sharedPresentSupportedUsageFlags) == "string" then
		tbl.sharedPresentSupportedUsageFlags = library.e.image_usage[tbl.sharedPresentSupportedUsageFlags]
	end
	return table_only and tbl or ffi.new("struct VkSharedPresentSurfaceCapabilitiesKHR", tbl)
end
function library.s.PhysicalDeviceExternalFenceInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalFenceInfoKHR", tbl)
end
function library.s.ExternalFencePropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"
	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_fence_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_fence_handle_type[tbl.exportFromImportedHandleTypes]
	end
	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_fence_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_fence_handle_type[tbl.compatibleHandleTypes]
	end
	if type(tbl.externalFenceFeatures) == "table" then
		tbl.externalFenceFeatures = library.e.external_fence_feature.make_enums(tbl.externalFenceFeatures)
	elseif type(tbl.externalFenceFeatures) == "string" then
		tbl.externalFenceFeatures = library.e.external_fence_feature[tbl.externalFenceFeatures]
	end
	return table_only and tbl or ffi.new("struct VkExternalFencePropertiesKHR", tbl)
end
function library.s.ExportFenceCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_fence_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_fence_handle_type[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExportFenceCreateInfoKHR", tbl)
end
function library.s.ImportFenceFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.fence_import.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.fence_import[tbl.flags]
	end
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkImportFenceFdInfoKHR", tbl)
end
function library.s.FenceGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"
	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end
	return table_only and tbl or ffi.new("struct VkFenceGetFdInfoKHR", tbl)
end
function library.s.PhysicalDeviceVariablePointerFeaturesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceVariablePointerFeaturesKHR", tbl)
end
function library.s.MemoryDedicatedRequirementsKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"
	return table_only and tbl or ffi.new("struct VkMemoryDedicatedRequirementsKHR", tbl)
end
function library.s.MemoryDedicatedAllocateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"
	return table_only and tbl or ffi.new("struct VkMemoryDedicatedAllocateInfoKHR", tbl)
end
function library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", tbl)
end
function library.s.SamplerReductionModeCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"
	if type(tbl.reductionMode) == "string" then
		tbl.reductionMode = library.e.sampler_reduction_mode[tbl.reductionMode]
	end
	return table_only and tbl or ffi.new("struct VkSamplerReductionModeCreateInfoEXT", tbl)
end
function library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", tbl)
end
function library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", tbl)
end
function library.s.PipelineColorBlendAdvancedStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"
	if type(tbl.blendOverlap) == "string" then
		tbl.blendOverlap = library.e.blend_overlap[tbl.blendOverlap]
	end
	return table_only and tbl or ffi.new("struct VkPipelineColorBlendAdvancedStateCreateInfoEXT", tbl)
end
function library.s.PipelineCoverageToColorStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"
	tbl.coverageToColorEnable = tbl.coverageToColorEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineCoverageToColorStateCreateInfoNV", tbl)
end
function library.s.PipelineCoverageModulationStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"
	if type(tbl.coverageModulationMode) == "string" then
		tbl.coverageModulationMode = library.e.coverage_modulation_mode[tbl.coverageModulationMode]
	end
	tbl.coverageModulationTableEnable = tbl.coverageModulationTableEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineCoverageModulationStateCreateInfoNV", tbl)
end
function library.s.DedicatedAllocationMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationMemoryAllocateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV[?]", #tbl, tbl)
end
function library.s.DescriptorPoolArray(tbl) return ffi.new("struct VkDescriptorPool_T *[?]", #tbl, tbl) end
function library.s.ClearDepthStencilValue(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkClearDepthStencilValue", tbl)
end
function library.s.ClearDepthStencilValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearDepthStencilValue(v)
	end
	return ffi.new("struct VkClearDepthStencilValue[?]", #tbl, tbl)
end
function library.s.SparseBufferMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseBufferMemoryBindInfo", tbl)
end
function library.s.SparseBufferMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseBufferMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseBufferMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.ImageViewArray(tbl) return ffi.new("struct VkImageView_T *[?]", #tbl, tbl) end
function library.s.DescriptorSetArray(tbl) return ffi.new("struct VkDescriptorSet_T *[?]", #tbl, tbl) end
function library.s.ValidationFlagsEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ValidationFlagsEXT(v)
	end
	return ffi.new("struct VkValidationFlagsEXT[?]", #tbl, tbl)
end
function library.s.ComponentMapping(tbl, table_only)
	if type(tbl.r) == "string" then
		tbl.r = library.e.component_swizzle[tbl.r]
	end
	if type(tbl.g) == "string" then
		tbl.g = library.e.component_swizzle[tbl.g]
	end
	if type(tbl.b) == "string" then
		tbl.b = library.e.component_swizzle[tbl.b]
	end
	if type(tbl.a) == "string" then
		tbl.a = library.e.component_swizzle[tbl.a]
	end
	return table_only and tbl or ffi.new("struct VkComponentMapping", tbl)
end
function library.s.ComponentMappingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComponentMapping(v)
	end
	return ffi.new("struct VkComponentMapping[?]", #tbl, tbl)
end
function library.s.PipelineMultisampleStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineMultisampleStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineMultisampleStateCreateInfo[?]", #tbl, tbl)
end
function library.s.SurfaceCapabilities2EXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilities2EXT(v)
	end
	return ffi.new("struct VkSurfaceCapabilities2EXT[?]", #tbl, tbl)
end
function library.s.ExternalMemoryPropertiesKHR(tbl, table_only)
	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature[tbl.externalMemoryFeatures]
	end
	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type[tbl.exportFromImportedHandleTypes]
	end
	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type[tbl.compatibleHandleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalMemoryPropertiesKHR", tbl)
end
function library.s.ExternalMemoryPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryPropertiesKHR(v)
	end
	return ffi.new("struct VkExternalMemoryPropertiesKHR[?]", #tbl, tbl)
end
function library.s.DispatchIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDispatchIndirectCommand", tbl)
end
function library.s.DispatchIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DispatchIndirectCommand(v)
	end
	return ffi.new("struct VkDispatchIndirectCommand[?]", #tbl, tbl)
end
function library.s.PipelineColorBlendAdvancedStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendAdvancedStateCreateInfoEXT(v)
	end
	return ffi.new("struct VkPipelineColorBlendAdvancedStateCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.DebugMarkerObjectTagInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectTagInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerObjectTagInfoEXT[?]", #tbl, tbl)
end
function library.s.ExternalBufferPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalBufferPropertiesKHR(v)
	end
	return ffi.new("struct VkExternalBufferPropertiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineCoverageModulationStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCoverageModulationStateCreateInfoNV(v)
	end
	return ffi.new("struct VkPipelineCoverageModulationStateCreateInfoNV[?]", #tbl, tbl)
end
function library.s.DebugReportCallbackEXTArray(tbl) return ffi.new("struct VkDebugReportCallbackEXT_T *[?]", #tbl, tbl) end
function library.s.BufferArray(tbl) return ffi.new("struct VkBuffer_T *[?]", #tbl, tbl) end
function library.s.PipelineCacheArray(tbl) return ffi.new("struct VkPipelineCache_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceImageFormatInfo2KHR(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end
	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceImageFormatInfo2KHR", tbl)
end
function library.s.PhysicalDeviceImageFormatInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceImageFormatInfo2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceImageFormatInfo2KHR[?]", #tbl, tbl)
end
function library.s.ImageArray(tbl) return ffi.new("struct VkImage_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceMemoryProperties(tbl, table_only)
	if type(tbl.memoryTypes) == "table" then
		tbl.memoryTypes = library.s.MemoryType(tbl.memoryTypes, true)
	end
	if type(tbl.memoryHeaps) == "table" then
		tbl.memoryHeaps = library.s.MemoryHeap(tbl.memoryHeaps, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties", tbl)
end
function library.s.PhysicalDeviceMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceMemoryProperties[?]", #tbl, tbl)
end
function library.s.ApplicationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ApplicationInfo(v)
	end
	return ffi.new("struct VkApplicationInfo[?]", #tbl, tbl)
end
function library.s.SubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubmitInfo(v)
	end
	return ffi.new("struct VkSubmitInfo[?]", #tbl, tbl)
end
function library.s.RenderPassBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassBeginInfo(v)
	end
	return ffi.new("struct VkRenderPassBeginInfo[?]", #tbl, tbl)
end
function library.s.ObjectTableCreateInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableCreateInfoNVX(v)
	end
	return ffi.new("struct VkObjectTableCreateInfoNVX[?]", #tbl, tbl)
end
function library.s.DeviceGeneratedCommandsFeaturesNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGeneratedCommandsFeaturesNVX(v)
	end
	return ffi.new("struct VkDeviceGeneratedCommandsFeaturesNVX[?]", #tbl, tbl)
end
function library.s.ComputePipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComputePipelineCreateInfo(v)
	end
	return ffi.new("struct VkComputePipelineCreateInfo[?]", #tbl, tbl)
end
function library.s.StencilOpState(tbl, table_only)
	if type(tbl.failOp) == "string" then
		tbl.failOp = library.e.stencil_op[tbl.failOp]
	end
	if type(tbl.passOp) == "string" then
		tbl.passOp = library.e.stencil_op[tbl.passOp]
	end
	if type(tbl.depthFailOp) == "string" then
		tbl.depthFailOp = library.e.stencil_op[tbl.depthFailOp]
	end
	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end
	return table_only and tbl or ffi.new("struct VkStencilOpState", tbl)
end
function library.s.StencilOpStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.StencilOpState(v)
	end
	return ffi.new("struct VkStencilOpState[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceGroupPropertiesKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceGroupPropertiesKHX(v)
	end
	return ffi.new("struct VkPhysicalDeviceGroupPropertiesKHX[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceArray(tbl) return ffi.new("struct VkPhysicalDevice_T *[?]", #tbl, tbl) end
function library.s.PresentTimesInfoGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentTimesInfoGOOGLE(v)
	end
	return ffi.new("struct VkPresentTimesInfoGOOGLE[?]", #tbl, tbl)
end
function library.s.ShaderModuleArray(tbl) return ffi.new("struct VkShaderModule_T *[?]", #tbl, tbl) end
function library.s.CmdProcessCommandsInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CmdProcessCommandsInfoNVX(v)
	end
	return ffi.new("struct VkCmdProcessCommandsInfoNVX[?]", #tbl, tbl)
end
function library.s.SharedPresentSurfaceCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SharedPresentSurfaceCapabilitiesKHR(v)
	end
	return ffi.new("struct VkSharedPresentSurfaceCapabilitiesKHR[?]", #tbl, tbl)
end
function library.s.Extent3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent3D", tbl)
end
function library.s.Extent3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent3D(v)
	end
	return ffi.new("struct VkExtent3D[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceDiscardRectanglePropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceDiscardRectanglePropertiesEXT(v)
	end
	return ffi.new("struct VkPhysicalDeviceDiscardRectanglePropertiesEXT[?]", #tbl, tbl)
end
function library.s.PipelineDepthStencilStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDepthStencilStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineDepthStencilStateCreateInfo[?]", #tbl, tbl)
end
function library.s.ExternalFencePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalFencePropertiesKHR(v)
	end
	return ffi.new("struct VkExternalFencePropertiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineViewportSwizzleStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportSwizzleStateCreateInfoNV(v)
	end
	return ffi.new("struct VkPipelineViewportSwizzleStateCreateInfoNV[?]", #tbl, tbl)
end
function library.s.AttachmentDescription(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.attachment_description.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.attachment_description[tbl.flags]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end
	if type(tbl.loadOp) == "string" then
		tbl.loadOp = library.e.attachment_load_op[tbl.loadOp]
	end
	if type(tbl.storeOp) == "string" then
		tbl.storeOp = library.e.attachment_store_op[tbl.storeOp]
	end
	if type(tbl.stencilLoadOp) == "string" then
		tbl.stencilLoadOp = library.e.attachment_load_op[tbl.stencilLoadOp]
	end
	if type(tbl.stencilStoreOp) == "string" then
		tbl.stencilStoreOp = library.e.attachment_store_op[tbl.stencilStoreOp]
	end
	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end
	if type(tbl.finalLayout) == "string" then
		tbl.finalLayout = library.e.image_layout[tbl.finalLayout]
	end
	return table_only and tbl or ffi.new("struct VkAttachmentDescription", tbl)
end
function library.s.AttachmentDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentDescription(v)
	end
	return ffi.new("struct VkAttachmentDescription[?]", #tbl, tbl)
end
function library.s.RenderPassArray(tbl) return ffi.new("struct VkRenderPass_T *[?]", #tbl, tbl) end
function library.s.AttachmentReference(tbl, table_only)
	if type(tbl.layout) == "string" then
		tbl.layout = library.e.image_layout[tbl.layout]
	end
	return table_only and tbl or ffi.new("struct VkAttachmentReference", tbl)
end
function library.s.AttachmentReferenceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentReference(v)
	end
	return ffi.new("struct VkAttachmentReference[?]", #tbl, tbl)
end
function library.s.SparseImageFormatProperties2KHR(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.SparseImageFormatProperties(tbl.properties, true)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties2KHR", tbl)
end
function library.s.SparseImageFormatProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties2KHR(v)
	end
	return ffi.new("struct VkSparseImageFormatProperties2KHR[?]", #tbl, tbl)
end
function library.s.IndirectCommandsLayoutTokenNVX(tbl, table_only)
	if type(tbl.tokenType) == "string" then
		tbl.tokenType = library.e.indirect_commands_token_type[tbl.tokenType]
	end
	return table_only and tbl or ffi.new("struct VkIndirectCommandsLayoutTokenNVX", tbl)
end
function library.s.IndirectCommandsLayoutTokenNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsLayoutTokenNVX(v)
	end
	return ffi.new("struct VkIndirectCommandsLayoutTokenNVX[?]", #tbl, tbl)
end
function library.s.FenceGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FenceGetFdInfoKHR(v)
	end
	return ffi.new("struct VkFenceGetFdInfoKHR[?]", #tbl, tbl)
end
function library.s.BufferViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferViewCreateInfo(v)
	end
	return ffi.new("struct VkBufferViewCreateInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(v)
	end
	return ffi.new("struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX[?]", #tbl, tbl)
end
function library.s.ClearValue(tbl, table_only)
	if type(tbl.color) == "table" then
		tbl.color = library.s.ClearColorValue(tbl.color, true)
	end
	if type(tbl.depthStencil) == "table" then
		tbl.depthStencil = library.s.ClearDepthStencilValue(tbl.depthStencil, true)
	end
	return table_only and tbl or ffi.new("union VkClearValue", tbl)
end
function library.s.ClearValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearValue(v)
	end
	return ffi.new("union VkClearValue[?]", #tbl, tbl)
end
function library.s.SubpassDescription(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.subpass_description.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.subpass_description[tbl.flags]
	end
	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end
	if type(tbl.pInputAttachments) == "table" then
		if not tbl.inputAttachmentCount then
			tbl.inputAttachmentCount = #tbl.pInputAttachments
		end
		tbl.pInputAttachments = library.s.AttachmentReferenceArray(tbl.pInputAttachments, false)
	end
	if type(tbl.pColorAttachments) == "table" then
		if not tbl.colorAttachmentCount then
			tbl.colorAttachmentCount = #tbl.pColorAttachments
		end
		tbl.pColorAttachments = library.s.AttachmentReferenceArray(tbl.pColorAttachments, false)
	end
	if type(tbl.pResolveAttachments) == "table" then
		tbl.pResolveAttachments = library.s.AttachmentReference(tbl.pResolveAttachments, false)
	end
	if type(tbl.pDepthStencilAttachment) == "table" then
		tbl.pDepthStencilAttachment = library.s.AttachmentReference(tbl.pDepthStencilAttachment, false)
	end
	return table_only and tbl or ffi.new("struct VkSubpassDescription", tbl)
end
function library.s.SubpassDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDescription(v)
	end
	return ffi.new("struct VkSubpassDescription[?]", #tbl, tbl)
end
function library.s.ClearAttachment(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	if type(tbl.clearValue) == "table" then
		tbl.clearValue = library.s.ClearValue(tbl.clearValue, true)
	end
	return table_only and tbl or ffi.new("struct VkClearAttachment", tbl)
end
function library.s.ClearAttachmentArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearAttachment(v)
	end
	return ffi.new("struct VkClearAttachment[?]", #tbl, tbl)
end
function library.s.DisplayPowerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPowerInfoEXT(v)
	end
	return ffi.new("struct VkDisplayPowerInfoEXT[?]", #tbl, tbl)
end
function library.s.ObjectTableEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkObjectTableEntryNVX", tbl)
end
function library.s.ObjectTableEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableEntryNVX(v)
	end
	return ffi.new("struct VkObjectTableEntryNVX[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceVariablePointerFeaturesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceVariablePointerFeaturesKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceVariablePointerFeaturesKHR[?]", #tbl, tbl)
end
function library.s.SparseImageFormatProperties(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	if type(tbl.imageGranularity) == "table" then
		tbl.imageGranularity = library.s.Extent3D(tbl.imageGranularity, true)
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_image_format.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_image_format[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties", tbl)
end
function library.s.SparseImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties(v)
	end
	return ffi.new("struct VkSparseImageFormatProperties[?]", #tbl, tbl)
end
function library.s.QueueFamilyProperties(tbl, table_only)
	if type(tbl.queueFlags) == "table" then
		tbl.queueFlags = library.e.queue.make_enums(tbl.queueFlags)
	elseif type(tbl.queueFlags) == "string" then
		tbl.queueFlags = library.e.queue[tbl.queueFlags]
	end
	if type(tbl.minImageTransferGranularity) == "table" then
		tbl.minImageTransferGranularity = library.s.Extent3D(tbl.minImageTransferGranularity, true)
	end
	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties", tbl)
end
function library.s.QueueFamilyPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties(v)
	end
	return ffi.new("struct VkQueueFamilyProperties[?]", #tbl, tbl)
end
function library.s.ClearRect(tbl, table_only)
	if type(tbl.rect) == "table" then
		tbl.rect = library.s.Rect2D(tbl.rect, true)
	end
	return table_only and tbl or ffi.new("struct VkClearRect", tbl)
end
function library.s.ClearRectArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearRect(v)
	end
	return ffi.new("struct VkClearRect[?]", #tbl, tbl)
end
function library.s.LayerProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkLayerProperties", tbl)
end
function library.s.LayerPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.LayerProperties(v)
	end
	return ffi.new("struct VkLayerProperties[?]", #tbl, tbl)
end
function library.s.IndirectCommandsLayoutCreateInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsLayoutCreateInfoNVX(v)
	end
	return ffi.new("struct VkIndirectCommandsLayoutCreateInfoNVX[?]", #tbl, tbl)
end
function library.s.DeviceGroupDeviceCreateInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupDeviceCreateInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupDeviceCreateInfoKHX[?]", #tbl, tbl)
end
function library.s.ClearColorValue(tbl, table_only)
	return table_only and tbl or ffi.new("union VkClearColorValue", tbl)
end
function library.s.ClearColorValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearColorValue(v)
	end
	return ffi.new("union VkClearColorValue[?]", #tbl, tbl)
end
function library.s.ViewportWScalingNV(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkViewportWScalingNV", tbl)
end
function library.s.ViewportWScalingNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ViewportWScalingNV(v)
	end
	return ffi.new("struct VkViewportWScalingNV[?]", #tbl, tbl)
end
function library.s.CommandBufferInheritanceInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferInheritanceInfo(v)
	end
	return ffi.new("struct VkCommandBufferInheritanceInfo[?]", #tbl, tbl)
end
function library.s.DebugMarkerObjectNameInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectNameInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerObjectNameInfoEXT[?]", #tbl, tbl)
end
function library.s.FormatProperties(tbl, table_only)
	if type(tbl.linearTilingFeatures) == "table" then
		tbl.linearTilingFeatures = library.e.format_feature.make_enums(tbl.linearTilingFeatures)
	elseif type(tbl.linearTilingFeatures) == "string" then
		tbl.linearTilingFeatures = library.e.format_feature[tbl.linearTilingFeatures]
	end
	if type(tbl.optimalTilingFeatures) == "table" then
		tbl.optimalTilingFeatures = library.e.format_feature.make_enums(tbl.optimalTilingFeatures)
	elseif type(tbl.optimalTilingFeatures) == "string" then
		tbl.optimalTilingFeatures = library.e.format_feature[tbl.optimalTilingFeatures]
	end
	if type(tbl.bufferFeatures) == "table" then
		tbl.bufferFeatures = library.e.format_feature.make_enums(tbl.bufferFeatures)
	elseif type(tbl.bufferFeatures) == "string" then
		tbl.bufferFeatures = library.e.format_feature[tbl.bufferFeatures]
	end
	return table_only and tbl or ffi.new("struct VkFormatProperties", tbl)
end
function library.s.FormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties(v)
	end
	return ffi.new("struct VkFormatProperties[?]", #tbl, tbl)
end
function library.s.CopyDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CopyDescriptorSet(v)
	end
	return ffi.new("struct VkCopyDescriptorSet[?]", #tbl, tbl)
end
function library.s.RectLayerKHR(tbl, table_only)
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset2D(tbl.offset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent2D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkRectLayerKHR", tbl)
end
function library.s.RectLayerKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RectLayerKHR(v)
	end
	return ffi.new("struct VkRectLayerKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceProperties(tbl, table_only)
	if type(tbl.deviceType) == "string" then
		tbl.deviceType = library.e.physical_device_type[tbl.deviceType]
	end
	if type(tbl.limits) == "table" then
		tbl.limits = library.s.PhysicalDeviceLimits(tbl.limits, true)
	end
	if type(tbl.sparseProperties) == "table" then
		tbl.sparseProperties = library.s.PhysicalDeviceSparseProperties(tbl.sparseProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties", tbl)
end
function library.s.PhysicalDevicePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceProperties[?]", #tbl, tbl)
end
function library.s.ObjectTableVertexBufferEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkObjectTableVertexBufferEntryNVX", tbl)
end
function library.s.ObjectTableVertexBufferEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableVertexBufferEntryNVX(v)
	end
	return ffi.new("struct VkObjectTableVertexBufferEntryNVX[?]", #tbl, tbl)
end
function library.s.PresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentInfoKHR(v)
	end
	return ffi.new("struct VkPresentInfoKHR[?]", #tbl, tbl)
end
function library.s.DeviceGroupCommandBufferBeginInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupCommandBufferBeginInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupCommandBufferBeginInfoKHX[?]", #tbl, tbl)
end
function library.s.PipelineArray(tbl) return ffi.new("struct VkPipeline_T *[?]", #tbl, tbl) end
function library.s.DisplayModeKHRArray(tbl) return ffi.new("struct VkDisplayModeKHR_T *[?]", #tbl, tbl) end
function library.s.BufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCreateInfo(v)
	end
	return ffi.new("struct VkBufferCreateInfo[?]", #tbl, tbl)
end
function library.s.ImportSemaphoreFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportSemaphoreFdInfoKHR(v)
	end
	return ffi.new("struct VkImportSemaphoreFdInfoKHR[?]", #tbl, tbl)
end
function library.s.SubpassDependency(tbl, table_only)
	if type(tbl.srcStageMask) == "table" then
		tbl.srcStageMask = library.e.pipeline_stage.make_enums(tbl.srcStageMask)
	elseif type(tbl.srcStageMask) == "string" then
		tbl.srcStageMask = library.e.pipeline_stage[tbl.srcStageMask]
	end
	if type(tbl.dstStageMask) == "table" then
		tbl.dstStageMask = library.e.pipeline_stage.make_enums(tbl.dstStageMask)
	elseif type(tbl.dstStageMask) == "string" then
		tbl.dstStageMask = library.e.pipeline_stage[tbl.dstStageMask]
	end
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	if type(tbl.dependencyFlags) == "table" then
		tbl.dependencyFlags = library.e.dependency.make_enums(tbl.dependencyFlags)
	elseif type(tbl.dependencyFlags) == "string" then
		tbl.dependencyFlags = library.e.dependency[tbl.dependencyFlags]
	end
	return table_only and tbl or ffi.new("struct VkSubpassDependency", tbl)
end
function library.s.SubpassDependencyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDependency(v)
	end
	return ffi.new("struct VkSubpassDependency[?]", #tbl, tbl)
end
function library.s.QueueFamilyProperties2KHR(tbl, table_only)
	if type(tbl.queueFamilyProperties) == "table" then
		tbl.queueFamilyProperties = library.s.QueueFamilyProperties(tbl.queueFamilyProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties2KHR", tbl)
end
function library.s.QueueFamilyProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties2KHR(v)
	end
	return ffi.new("struct VkQueueFamilyProperties2KHR[?]", #tbl, tbl)
end
function library.s.ImageCopy(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkImageCopy", tbl)
end
function library.s.ImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCopy(v)
	end
	return ffi.new("struct VkImageCopy[?]", #tbl, tbl)
end
function library.s.DescriptorSetLayoutArray(tbl) return ffi.new("struct VkDescriptorSetLayout_T *[?]", #tbl, tbl) end
function library.s.VertexInputAttributeDescription(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	return table_only and tbl or ffi.new("struct VkVertexInputAttributeDescription", tbl)
end
function library.s.VertexInputAttributeDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputAttributeDescription(v)
	end
	return ffi.new("struct VkVertexInputAttributeDescription[?]", #tbl, tbl)
end
function library.s.CommandBufferBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferBeginInfo(v)
	end
	return ffi.new("struct VkCommandBufferBeginInfo[?]", #tbl, tbl)
end
function library.s.DisplayModeCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeCreateInfoKHR(v)
	end
	return ffi.new("struct VkDisplayModeCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.SwapchainCounterCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SwapchainCounterCreateInfoEXT(v)
	end
	return ffi.new("struct VkSwapchainCounterCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.Offset3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset3D", tbl)
end
function library.s.Offset3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset3D(v)
	end
	return ffi.new("struct VkOffset3D[?]", #tbl, tbl)
end
function library.s.ViewportSwizzleNV(tbl, table_only)
	if type(tbl.x) == "string" then
		tbl.x = library.e.viewport_coordinate_swizzle[tbl.x]
	end
	if type(tbl.y) == "string" then
		tbl.y = library.e.viewport_coordinate_swizzle[tbl.y]
	end
	if type(tbl.z) == "string" then
		tbl.z = library.e.viewport_coordinate_swizzle[tbl.z]
	end
	if type(tbl.w) == "string" then
		tbl.w = library.e.viewport_coordinate_swizzle[tbl.w]
	end
	return table_only and tbl or ffi.new("struct VkViewportSwizzleNV", tbl)
end
function library.s.ViewportSwizzleNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ViewportSwizzleNV(v)
	end
	return ffi.new("struct VkViewportSwizzleNV[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceSparseImageFormatInfo2KHR(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end
	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end
	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2KHR", tbl)
end
function library.s.PhysicalDeviceSparseImageFormatInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseImageFormatInfo2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2KHR[?]", #tbl, tbl)
end
function library.s.SurfaceFormatKHR(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.colorSpace) == "string" then
		tbl.colorSpace = library.e.colorspace[tbl.colorSpace]
	end
	return table_only and tbl or ffi.new("struct VkSurfaceFormatKHR", tbl)
end
function library.s.SurfaceFormatKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceFormatKHR(v)
	end
	return ffi.new("struct VkSurfaceFormatKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDevice16BitStorageFeaturesKHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDevice16BitStorageFeaturesKHR", tbl)
end
function library.s.PhysicalDevice16BitStorageFeaturesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevice16BitStorageFeaturesKHR(v)
	end
	return ffi.new("struct VkPhysicalDevice16BitStorageFeaturesKHR[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryBind(tbl, table_only)
	if type(tbl.subresource) == "table" then
		tbl.subresource = library.s.ImageSubresource(tbl.subresource, true)
	end
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset3D(tbl.offset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBind", tbl)
end
function library.s.SparseImageMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBind(v)
	end
	return ffi.new("struct VkSparseImageMemoryBind[?]", #tbl, tbl)
end
function library.s.DeviceGeneratedCommandsLimitsNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGeneratedCommandsLimitsNVX(v)
	end
	return ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX[?]", #tbl, tbl)
end
function library.s.PipelineDynamicStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDynamicStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineDynamicStateCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageBlit(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffsets) == "table" then
		tbl.srcOffsets = library.s.Offset3D(tbl.srcOffsets, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffsets) == "table" then
		tbl.dstOffsets = library.s.Offset3D(tbl.dstOffsets, true)
	end
	return table_only and tbl or ffi.new("struct VkImageBlit", tbl)
end
function library.s.ImageBlitArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageBlit(v)
	end
	return ffi.new("struct VkImageBlit[?]", #tbl, tbl)
end
function library.s.CommandPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandPoolCreateInfo(v)
	end
	return ffi.new("struct VkCommandPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryBarrier(v)
	end
	return ffi.new("struct VkImageMemoryBarrier[?]", #tbl, tbl)
end
function library.s.DisplayModePropertiesKHR(tbl, table_only)
	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModePropertiesKHR", tbl)
end
function library.s.DisplayModePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModePropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayModePropertiesKHR[?]", #tbl, tbl)
end
function library.s.FenceArray(tbl) return ffi.new("struct VkFence_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(v)
	end
	return ffi.new("struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT[?]", #tbl, tbl)
end
function library.s.PhysicalDevicePushDescriptorPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevicePushDescriptorPropertiesKHR(v)
	end
	return ffi.new("struct VkPhysicalDevicePushDescriptorPropertiesKHR[?]", #tbl, tbl)
end
function library.s.EventArray(tbl) return ffi.new("struct VkEvent_T *[?]", #tbl, tbl) end
function library.s.ImageViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageViewCreateInfo(v)
	end
	return ffi.new("struct VkImageViewCreateInfo[?]", #tbl, tbl)
end
function library.s.Viewport(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkViewport", tbl)
end
function library.s.ViewportArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Viewport(v)
	end
	return ffi.new("struct VkViewport[?]", #tbl, tbl)
end
function library.s.PipelineTessellationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineTessellationStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineTessellationStateCreateInfo[?]", #tbl, tbl)
end
function library.s.FormatProperties2KHR(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.FormatProperties(tbl.formatProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkFormatProperties2KHR", tbl)
end
function library.s.FormatProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties2KHR(v)
	end
	return ffi.new("struct VkFormatProperties2KHR[?]", #tbl, tbl)
end
function library.s.InstanceArray(tbl) return ffi.new("struct VkInstance_T *[?]", #tbl, tbl) end
function library.s.SurfaceKHRArray(tbl) return ffi.new("struct VkSurfaceKHR_T *[?]", #tbl, tbl) end
function library.s.ImageFormatProperties2KHR(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkImageFormatProperties2KHR", tbl)
end
function library.s.ImageFormatProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties2KHR(v)
	end
	return ffi.new("struct VkImageFormatProperties2KHR[?]", #tbl, tbl)
end
function library.s.MemoryFdPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryFdPropertiesKHR(v)
	end
	return ffi.new("struct VkMemoryFdPropertiesKHR[?]", #tbl, tbl)
end
function library.s.WriteDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.WriteDescriptorSet(v)
	end
	return ffi.new("struct VkWriteDescriptorSet[?]", #tbl, tbl)
end
function library.s.PipelineDiscardRectangleStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDiscardRectangleStateCreateInfoEXT(v)
	end
	return ffi.new("struct VkPipelineDiscardRectangleStateCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.QueryPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueryPoolCreateInfo(v)
	end
	return ffi.new("struct VkQueryPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineShaderStageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineShaderStageCreateInfo(v)
	end
	return ffi.new("struct VkPipelineShaderStageCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineVertexInputStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineVertexInputStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineVertexInputStateCreateInfo[?]", #tbl, tbl)
end
function library.s.Rect2D(tbl, table_only)
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset2D(tbl.offset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent2D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkRect2D", tbl)
end
function library.s.Rect2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Rect2D(v)
	end
	return ffi.new("struct VkRect2D[?]", #tbl, tbl)
end
function library.s.SparseImageOpaqueMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageOpaqueMemoryBindInfo", tbl)
end
function library.s.SparseImageOpaqueMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageOpaqueMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseImageOpaqueMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.PipelineCoverageToColorStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCoverageToColorStateCreateInfoNV(v)
	end
	return ffi.new("struct VkPipelineCoverageToColorStateCreateInfoNV[?]", #tbl, tbl)
end
function library.s.BufferMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryBarrier(v)
	end
	return ffi.new("struct VkBufferMemoryBarrier[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXT(v)
	end
	return ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXT(v)
	end
	return ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT[?]", #tbl, tbl)
end
function library.s.SamplerReductionModeCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerReductionModeCreateInfoEXT(v)
	end
	return ffi.new("struct VkSamplerReductionModeCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.HdrMetadataEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.HdrMetadataEXT(v)
	end
	return ffi.new("struct VkHdrMetadataEXT[?]", #tbl, tbl)
end
function library.s.DisplayPlaneCapabilitiesKHR(tbl, table_only)
	if type(tbl.supportedAlpha) == "table" then
		tbl.supportedAlpha = library.e.display_plane_alpha.make_enums(tbl.supportedAlpha)
	elseif type(tbl.supportedAlpha) == "string" then
		tbl.supportedAlpha = library.e.display_plane_alpha[tbl.supportedAlpha]
	end
	if type(tbl.minSrcPosition) == "table" then
		tbl.minSrcPosition = library.s.Offset2D(tbl.minSrcPosition, true)
	end
	if type(tbl.maxSrcPosition) == "table" then
		tbl.maxSrcPosition = library.s.Offset2D(tbl.maxSrcPosition, true)
	end
	if type(tbl.minSrcExtent) == "table" then
		tbl.minSrcExtent = library.s.Extent2D(tbl.minSrcExtent, true)
	end
	if type(tbl.maxSrcExtent) == "table" then
		tbl.maxSrcExtent = library.s.Extent2D(tbl.maxSrcExtent, true)
	end
	if type(tbl.minDstPosition) == "table" then
		tbl.minDstPosition = library.s.Offset2D(tbl.minDstPosition, true)
	end
	if type(tbl.maxDstPosition) == "table" then
		tbl.maxDstPosition = library.s.Offset2D(tbl.maxDstPosition, true)
	end
	if type(tbl.minDstExtent) == "table" then
		tbl.minDstExtent = library.s.Extent2D(tbl.minDstExtent, true)
	end
	if type(tbl.maxDstExtent) == "table" then
		tbl.maxDstExtent = library.s.Extent2D(tbl.maxDstExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayPlaneCapabilitiesKHR", tbl)
end
function library.s.DisplayPlaneCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlaneCapabilitiesKHR(v)
	end
	return ffi.new("struct VkDisplayPlaneCapabilitiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineLayoutArray(tbl) return ffi.new("struct VkPipelineLayout_T *[?]", #tbl, tbl) end
function library.s.DescriptorUpdateTemplateKHRArray(tbl) return ffi.new("struct VkDescriptorUpdateTemplateKHR_T *[?]", #tbl, tbl) end
function library.s.ImageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCreateInfo(v)
	end
	return ffi.new("struct VkImageCreateInfo[?]", #tbl, tbl)
end
function library.s.PresentTimeGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPresentTimeGOOGLE", tbl)
end
function library.s.PresentTimeGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentTimeGOOGLE(v)
	end
	return ffi.new("struct VkPresentTimeGOOGLE[?]", #tbl, tbl)
end
function library.s.PastPresentationTimingGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPastPresentationTimingGOOGLE", tbl)
end
function library.s.PastPresentationTimingGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PastPresentationTimingGOOGLE(v)
	end
	return ffi.new("struct VkPastPresentationTimingGOOGLE[?]", #tbl, tbl)
end
function library.s.SparseMemoryBind(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseMemoryBind", tbl)
end
function library.s.SparseMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseMemoryBind(v)
	end
	return ffi.new("struct VkSparseMemoryBind[?]", #tbl, tbl)
end
function library.s.AllocationCallbacks(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkAllocationCallbacks", tbl)
end
function library.s.AllocationCallbacksArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AllocationCallbacks(v)
	end
	return ffi.new("struct VkAllocationCallbacks[?]", #tbl, tbl)
end
function library.s.DescriptorSetLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutCreateInfo(v)
	end
	return ffi.new("struct VkDescriptorSetLayoutCreateInfo[?]", #tbl, tbl)
end
function library.s.RefreshCycleDurationGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkRefreshCycleDurationGOOGLE", tbl)
end
function library.s.RefreshCycleDurationGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RefreshCycleDurationGOOGLE(v)
	end
	return ffi.new("struct VkRefreshCycleDurationGOOGLE[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceSparseProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSparseProperties", tbl)
end
function library.s.PhysicalDeviceSparsePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceSparseProperties[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceMultiviewFeaturesKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewFeaturesKHX(v)
	end
	return ffi.new("struct VkPhysicalDeviceMultiviewFeaturesKHX[?]", #tbl, tbl)
end
function library.s.PipelineColorBlendAttachmentState(tbl, table_only)
	tbl.blendEnable = tbl.blendEnable and 1 or 0
	if type(tbl.srcColorBlendFactor) == "string" then
		tbl.srcColorBlendFactor = library.e.blend_factor[tbl.srcColorBlendFactor]
	end
	if type(tbl.dstColorBlendFactor) == "string" then
		tbl.dstColorBlendFactor = library.e.blend_factor[tbl.dstColorBlendFactor]
	end
	if type(tbl.colorBlendOp) == "string" then
		tbl.colorBlendOp = library.e.blend_op[tbl.colorBlendOp]
	end
	if type(tbl.srcAlphaBlendFactor) == "string" then
		tbl.srcAlphaBlendFactor = library.e.blend_factor[tbl.srcAlphaBlendFactor]
	end
	if type(tbl.dstAlphaBlendFactor) == "string" then
		tbl.dstAlphaBlendFactor = library.e.blend_factor[tbl.dstAlphaBlendFactor]
	end
	if type(tbl.alphaBlendOp) == "string" then
		tbl.alphaBlendOp = library.e.blend_op[tbl.alphaBlendOp]
	end
	if type(tbl.colorWriteMask) == "table" then
		tbl.colorWriteMask = library.e.color_component.make_enums(tbl.colorWriteMask)
	elseif type(tbl.colorWriteMask) == "string" then
		tbl.colorWriteMask = library.e.color_component[tbl.colorWriteMask]
	end
	return table_only and tbl or ffi.new("struct VkPipelineColorBlendAttachmentState", tbl)
end
function library.s.PipelineColorBlendAttachmentStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendAttachmentState(v)
	end
	return ffi.new("struct VkPipelineColorBlendAttachmentState[?]", #tbl, tbl)
end
function library.s.DisplayEventInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayEventInfoEXT(v)
	end
	return ffi.new("struct VkDisplayEventInfoEXT[?]", #tbl, tbl)
end
function library.s.DeviceEventInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceEventInfoEXT(v)
	end
	return ffi.new("struct VkDeviceEventInfoEXT[?]", #tbl, tbl)
end
function library.s.Extent2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent2D", tbl)
end
function library.s.Extent2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent2D(v)
	end
	return ffi.new("struct VkExtent2D[?]", #tbl, tbl)
end
function library.s.QueueArray(tbl) return ffi.new("struct VkQueue_T *[?]", #tbl, tbl) end
function library.s.DisplayPlanePropertiesKHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDisplayPlanePropertiesKHR", tbl)
end
function library.s.DisplayPlanePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlanePropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayPlanePropertiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineViewportWScalingStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportWScalingStateCreateInfoNV(v)
	end
	return ffi.new("struct VkPipelineViewportWScalingStateCreateInfoNV[?]", #tbl, tbl)
end
function library.s.IndirectCommandsTokenNVX(tbl, table_only)
	if type(tbl.tokenType) == "string" then
		tbl.tokenType = library.e.indirect_commands_token_type[tbl.tokenType]
	end
	return table_only and tbl or ffi.new("struct VkIndirectCommandsTokenNVX", tbl)
end
function library.s.IndirectCommandsTokenNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsTokenNVX(v)
	end
	return ffi.new("struct VkIndirectCommandsTokenNVX[?]", #tbl, tbl)
end
function library.s.ImageFormatProperties(tbl, table_only)
	if type(tbl.maxExtent) == "table" then
		tbl.maxExtent = library.s.Extent3D(tbl.maxExtent, true)
	end
	if type(tbl.sampleCounts) == "table" then
		tbl.sampleCounts = library.e.sample_count.make_enums(tbl.sampleCounts)
	elseif type(tbl.sampleCounts) == "string" then
		tbl.sampleCounts = library.e.sample_count[tbl.sampleCounts]
	end
	return table_only and tbl or ffi.new("struct VkImageFormatProperties", tbl)
end
function library.s.ImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties(v)
	end
	return ffi.new("struct VkImageFormatProperties[?]", #tbl, tbl)
end
function library.s.ObjectTablePushConstantEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end
	return table_only and tbl or ffi.new("struct VkObjectTablePushConstantEntryNVX", tbl)
end
function library.s.ObjectTablePushConstantEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTablePushConstantEntryNVX(v)
	end
	return ffi.new("struct VkObjectTablePushConstantEntryNVX[?]", #tbl, tbl)
end
function library.s.ObjectTableIndexBufferEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	if type(tbl.indexType) == "string" then
		tbl.indexType = library.e.index_type[tbl.indexType]
	end
	return table_only and tbl or ffi.new("struct VkObjectTableIndexBufferEntryNVX", tbl)
end
function library.s.ObjectTableIndexBufferEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableIndexBufferEntryNVX(v)
	end
	return ffi.new("struct VkObjectTableIndexBufferEntryNVX[?]", #tbl, tbl)
end
function library.s.ObjectTableDescriptorSetEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkObjectTableDescriptorSetEntryNVX", tbl)
end
function library.s.ObjectTableDescriptorSetEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableDescriptorSetEntryNVX(v)
	end
	return ffi.new("struct VkObjectTableDescriptorSetEntryNVX[?]", #tbl, tbl)
end
function library.s.BindBufferMemoryInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindBufferMemoryInfoKHX(v)
	end
	return ffi.new("struct VkBindBufferMemoryInfoKHX[?]", #tbl, tbl)
end
function library.s.FramebufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FramebufferCreateInfo(v)
	end
	return ffi.new("struct VkFramebufferCreateInfo[?]", #tbl, tbl)
end
function library.s.DeviceGroupSubmitInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupSubmitInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupSubmitInfoKHX[?]", #tbl, tbl)
end
function library.s.DrawIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndirectCommand", tbl)
end
function library.s.DrawIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndirectCommand(v)
	end
	return ffi.new("struct VkDrawIndirectCommand[?]", #tbl, tbl)
end
function library.s.IndirectCommandsLayoutNVXArray(tbl) return ffi.new("struct VkIndirectCommandsLayoutNVX_T *[?]", #tbl, tbl) end
function library.s.DeviceGroupPresentInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupPresentInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupPresentInfoKHX[?]", #tbl, tbl)
end
function library.s.ObjectTableNVXArray(tbl) return ffi.new("struct VkObjectTableNVX_T *[?]", #tbl, tbl) end
function library.s.SparseImageMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseImageMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBindInfo", tbl)
end
function library.s.SparseImageMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseImageMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.SamplerArray(tbl) return ffi.new("struct VkSampler_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceExternalImageFormatInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalImageFormatInfoKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceExternalImageFormatInfoKHR[?]", #tbl, tbl)
end
function library.s.SemaphoreCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SemaphoreCreateInfo(v)
	end
	return ffi.new("struct VkSemaphoreCreateInfo[?]", #tbl, tbl)
end
function library.s.DebugMarkerMarkerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerMarkerInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerMarkerInfoEXT[?]", #tbl, tbl)
end
function library.s.ImageResolve(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkImageResolve", tbl)
end
function library.s.ImageResolveArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageResolve(v)
	end
	return ffi.new("struct VkImageResolve[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceMemoryProperties2KHR(tbl, table_only)
	if type(tbl.memoryProperties) == "table" then
		tbl.memoryProperties = library.s.PhysicalDeviceMemoryProperties(tbl.memoryProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties2KHR", tbl)
end
function library.s.PhysicalDeviceMemoryProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceMemoryProperties2KHR[?]", #tbl, tbl)
end
function library.s.DeviceGroupSwapchainCreateInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupSwapchainCreateInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupSwapchainCreateInfoKHX[?]", #tbl, tbl)
end
function library.s.AcquireNextImageInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AcquireNextImageInfoKHX(v)
	end
	return ffi.new("struct VkAcquireNextImageInfoKHX[?]", #tbl, tbl)
end
function library.s.DisplaySurfaceCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplaySurfaceCreateInfoKHR(v)
	end
	return ffi.new("struct VkDisplaySurfaceCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.BindImageMemorySwapchainInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemorySwapchainInfoKHX(v)
	end
	return ffi.new("struct VkBindImageMemorySwapchainInfoKHX[?]", #tbl, tbl)
end
function library.s.ImageSwapchainCreateInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSwapchainCreateInfoKHX(v)
	end
	return ffi.new("struct VkImageSwapchainCreateInfoKHX[?]", #tbl, tbl)
end
function library.s.DeviceGroupPresentCapabilitiesKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupPresentCapabilitiesKHX(v)
	end
	return ffi.new("struct VkDeviceGroupPresentCapabilitiesKHX[?]", #tbl, tbl)
end
function library.s.PipelineRasterizationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineRasterizationStateCreateInfo[?]", #tbl, tbl)
end
function library.s.DeviceGroupBindSparseInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupBindSparseInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupBindSparseInfoKHX[?]", #tbl, tbl)
end
function library.s.PipelineCacheCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCacheCreateInfo(v)
	end
	return ffi.new("struct VkPipelineCacheCreateInfo[?]", #tbl, tbl)
end
function library.s.CmdReserveSpaceForCommandsInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CmdReserveSpaceForCommandsInfoNVX(v)
	end
	return ffi.new("struct VkCmdReserveSpaceForCommandsInfoNVX[?]", #tbl, tbl)
end
function library.s.BindImageMemoryInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemoryInfoKHX(v)
	end
	return ffi.new("struct VkBindImageMemoryInfoKHX[?]", #tbl, tbl)
end
function library.s.MemoryAllocateFlagsInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateFlagsInfoKHX(v)
	end
	return ffi.new("struct VkMemoryAllocateFlagsInfoKHX[?]", #tbl, tbl)
end
function library.s.SubresourceLayout(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSubresourceLayout", tbl)
end
function library.s.SubresourceLayoutArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubresourceLayout(v)
	end
	return ffi.new("struct VkSubresourceLayout[?]", #tbl, tbl)
end
function library.s.ExportMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfoNV(v)
	end
	return ffi.new("struct VkExportMemoryAllocateInfoNV[?]", #tbl, tbl)
end
function library.s.ExternalMemoryImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfoNV(v)
	end
	return ffi.new("struct VkExternalMemoryImageCreateInfoNV[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceFeatures2KHR(tbl, table_only)
	if type(tbl.features) == "table" then
		tbl.features = library.s.PhysicalDeviceFeatures(tbl.features, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures2KHR", tbl)
end
function library.s.PhysicalDeviceFeatures2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceFeatures2KHR[?]", #tbl, tbl)
end
function library.s.BufferMemoryRequirementsInfo2KHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferMemoryRequirementsInfo2KHR", tbl)
end
function library.s.BufferMemoryRequirementsInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryRequirementsInfo2KHR(v)
	end
	return ffi.new("struct VkBufferMemoryRequirementsInfo2KHR[?]", #tbl, tbl)
end
function library.s.DeviceQueueCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceQueueCreateInfo(v)
	end
	return ffi.new("struct VkDeviceQueueCreateInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceMultiviewPropertiesKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewPropertiesKHX(v)
	end
	return ffi.new("struct VkPhysicalDeviceMultiviewPropertiesKHX[?]", #tbl, tbl)
end
function library.s.SwapchainCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SwapchainCreateInfoKHR(v)
	end
	return ffi.new("struct VkSwapchainCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.RenderPassMultiviewCreateInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassMultiviewCreateInfoKHX(v)
	end
	return ffi.new("struct VkRenderPassMultiviewCreateInfoKHX[?]", #tbl, tbl)
end
function library.s.TextureLODGatherFormatPropertiesAMD(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkTextureLODGatherFormatPropertiesAMD", tbl)
end
function library.s.TextureLODGatherFormatPropertiesAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.TextureLODGatherFormatPropertiesAMD(v)
	end
	return ffi.new("struct VkTextureLODGatherFormatPropertiesAMD[?]", #tbl, tbl)
end
function library.s.DescriptorUpdateTemplateEntryKHR(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorUpdateTemplateEntryKHR", tbl)
end
function library.s.DescriptorUpdateTemplateEntryKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateEntryKHR(v)
	end
	return ffi.new("struct VkDescriptorUpdateTemplateEntryKHR[?]", #tbl, tbl)
end
function library.s.PipelineViewportStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineViewportStateCreateInfo[?]", #tbl, tbl)
end
function library.s.DedicatedAllocationBufferCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationBufferCreateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV[?]", #tbl, tbl)
end
function library.s.XYColorEXT(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkXYColorEXT", tbl)
end
function library.s.XYColorEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.XYColorEXT(v)
	end
	return ffi.new("struct VkXYColorEXT[?]", #tbl, tbl)
end
function library.s.CommandBufferArray(tbl) return ffi.new("struct VkCommandBuffer_T *[?]", #tbl, tbl) end
function library.s.DescriptorImageInfo(tbl, table_only)
	if type(tbl.imageLayout) == "string" then
		tbl.imageLayout = library.e.image_layout[tbl.imageLayout]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorImageInfo", tbl)
end
function library.s.DescriptorImageInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorImageInfo(v)
	end
	return ffi.new("struct VkDescriptorImageInfo[?]", #tbl, tbl)
end
function library.s.GraphicsPipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.GraphicsPipelineCreateInfo(v)
	end
	return ffi.new("struct VkGraphicsPipelineCreateInfo[?]", #tbl, tbl)
end
function library.s.ObjectTablePipelineEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkObjectTablePipelineEntryNVX", tbl)
end
function library.s.ObjectTablePipelineEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTablePipelineEntryNVX(v)
	end
	return ffi.new("struct VkObjectTablePipelineEntryNVX[?]", #tbl, tbl)
end
function library.s.DebugReportCallbackCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugReportCallbackCreateInfoEXT(v)
	end
	return ffi.new("struct VkDebugReportCallbackCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.ExportSemaphoreCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportSemaphoreCreateInfoKHR(v)
	end
	return ffi.new("struct VkExportSemaphoreCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryRequirements2KHR(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.SparseImageMemoryRequirements(tbl.memoryRequirements, true)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements2KHR", tbl)
end
function library.s.SparseImageMemoryRequirements2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements2KHR(v)
	end
	return ffi.new("struct VkSparseImageMemoryRequirements2KHR[?]", #tbl, tbl)
end
function library.s.MemoryRequirements2KHR(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.MemoryRequirements(tbl.memoryRequirements, true)
	end
	return table_only and tbl or ffi.new("struct VkMemoryRequirements2KHR", tbl)
end
function library.s.MemoryRequirements2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements2KHR(v)
	end
	return ffi.new("struct VkMemoryRequirements2KHR[?]", #tbl, tbl)
end
function library.s.ImageSparseMemoryRequirementsInfo2KHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageSparseMemoryRequirementsInfo2KHR", tbl)
end
function library.s.ImageSparseMemoryRequirementsInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSparseMemoryRequirementsInfo2KHR(v)
	end
	return ffi.new("struct VkImageSparseMemoryRequirementsInfo2KHR[?]", #tbl, tbl)
end
function library.s.ImageMemoryRequirementsInfo2KHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageMemoryRequirementsInfo2KHR", tbl)
end
function library.s.ImageMemoryRequirementsInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryRequirementsInfo2KHR(v)
	end
	return ffi.new("struct VkImageMemoryRequirementsInfo2KHR[?]", #tbl, tbl)
end
function library.s.ExternalImageFormatPropertiesNV(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end
	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature[tbl.externalMemoryFeatures]
	end
	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type[tbl.exportFromImportedHandleTypes]
	end
	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type[tbl.compatibleHandleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalImageFormatPropertiesNV", tbl)
end
function library.s.ExternalImageFormatPropertiesNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatPropertiesNV(v)
	end
	return ffi.new("struct VkExternalImageFormatPropertiesNV[?]", #tbl, tbl)
end
function library.s.MemoryDedicatedAllocateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedAllocateInfoKHR(v)
	end
	return ffi.new("struct VkMemoryDedicatedAllocateInfoKHR[?]", #tbl, tbl)
end
function library.s.SurfaceFormat2KHR(tbl, table_only)
	if type(tbl.surfaceFormat) == "table" then
		tbl.surfaceFormat = library.s.SurfaceFormatKHR(tbl.surfaceFormat, true)
	end
	return table_only and tbl or ffi.new("struct VkSurfaceFormat2KHR", tbl)
end
function library.s.SurfaceFormat2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceFormat2KHR(v)
	end
	return ffi.new("struct VkSurfaceFormat2KHR[?]", #tbl, tbl)
end
function library.s.SurfaceCapabilities2KHR(tbl, table_only)
	if type(tbl.surfaceCapabilities) == "table" then
		tbl.surfaceCapabilities = library.s.SurfaceCapabilitiesKHR(tbl.surfaceCapabilities, true)
	end
	return table_only and tbl or ffi.new("struct VkSurfaceCapabilities2KHR", tbl)
end
function library.s.SurfaceCapabilities2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilities2KHR(v)
	end
	return ffi.new("struct VkSurfaceCapabilities2KHR[?]", #tbl, tbl)
end
function library.s.DescriptorUpdateTemplateCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateCreateInfoKHR(v)
	end
	return ffi.new("struct VkDescriptorUpdateTemplateCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceSurfaceInfo2KHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSurfaceInfo2KHR", tbl)
end
function library.s.PhysicalDeviceSurfaceInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSurfaceInfo2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceSurfaceInfo2KHR[?]", #tbl, tbl)
end
function library.s.DisplayModeParametersKHR(tbl, table_only)
	if type(tbl.visibleRegion) == "table" then
		tbl.visibleRegion = library.s.Extent2D(tbl.visibleRegion, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModeParametersKHR", tbl)
end
function library.s.DisplayModeParametersKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeParametersKHR(v)
	end
	return ffi.new("struct VkDisplayModeParametersKHR[?]", #tbl, tbl)
end
function library.s.ExtensionProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtensionProperties", tbl)
end
function library.s.ExtensionPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExtensionProperties(v)
	end
	return ffi.new("struct VkExtensionProperties[?]", #tbl, tbl)
end
function library.s.CommandBufferAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferAllocateInfo(v)
	end
	return ffi.new("struct VkCommandBufferAllocateInfo[?]", #tbl, tbl)
end
function library.s.ImportFenceFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportFenceFdInfoKHR(v)
	end
	return ffi.new("struct VkImportFenceFdInfoKHR[?]", #tbl, tbl)
end
function library.s.ExportFenceCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportFenceCreateInfoKHR(v)
	end
	return ffi.new("struct VkExportFenceCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceExternalFenceInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalFenceInfoKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceExternalFenceInfoKHR[?]", #tbl, tbl)
end
function library.s.ExternalMemoryImageCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfoKHR(v)
	end
	return ffi.new("struct VkExternalMemoryImageCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.EventCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.EventCreateInfo(v)
	end
	return ffi.new("struct VkEventCreateInfo[?]", #tbl, tbl)
end
function library.s.VertexInputBindingDescription(tbl, table_only)
	if type(tbl.inputRate) == "string" then
		tbl.inputRate = library.e.vertex_input_rate[tbl.inputRate]
	end
	return table_only and tbl or ffi.new("struct VkVertexInputBindingDescription", tbl)
end
function library.s.VertexInputBindingDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputBindingDescription(v)
	end
	return ffi.new("struct VkVertexInputBindingDescription[?]", #tbl, tbl)
end
function library.s.PresentRegionsKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentRegionsKHR(v)
	end
	return ffi.new("struct VkPresentRegionsKHR[?]", #tbl, tbl)
end
function library.s.BufferViewArray(tbl) return ffi.new("struct VkBufferView_T *[?]", #tbl, tbl) end
function library.s.ExternalSemaphorePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalSemaphorePropertiesKHR(v)
	end
	return ffi.new("struct VkExternalSemaphorePropertiesKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceExternalSemaphoreInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalSemaphoreInfoKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceExternalSemaphoreInfoKHR[?]", #tbl, tbl)
end
function library.s.ImportMemoryFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportMemoryFdInfoKHR(v)
	end
	return ffi.new("struct VkImportMemoryFdInfoKHR[?]", #tbl, tbl)
end
function library.s.ExportMemoryAllocateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfoKHR(v)
	end
	return ffi.new("struct VkExportMemoryAllocateInfoKHR[?]", #tbl, tbl)
end
function library.s.ExternalMemoryBufferCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryBufferCreateInfoKHR(v)
	end
	return ffi.new("struct VkExternalMemoryBufferCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.PushConstantRange(tbl, table_only)
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end
	return table_only and tbl or ffi.new("struct VkPushConstantRange", tbl)
end
function library.s.PushConstantRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PushConstantRange(v)
	end
	return ffi.new("struct VkPushConstantRange[?]", #tbl, tbl)
end
function library.s.DedicatedAllocationImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationImageCreateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationImageCreateInfoNV[?]", #tbl, tbl)
end
function library.s.SpecializationInfo(tbl, table_only)
	if type(tbl.pMapEntries) == "table" then
		if not tbl.mapEntryCount then
			tbl.mapEntryCount = #tbl.pMapEntries
		end
		tbl.pMapEntries = library.s.SpecializationMapEntryArray(tbl.pMapEntries, false)
	end
	return table_only and tbl or ffi.new("struct VkSpecializationInfo", tbl)
end
function library.s.SpecializationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationInfo(v)
	end
	return ffi.new("struct VkSpecializationInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceLimits(tbl, table_only)
	if type(tbl.framebufferColorSampleCounts) == "table" then
		tbl.framebufferColorSampleCounts = library.e.sample_count.make_enums(tbl.framebufferColorSampleCounts)
	elseif type(tbl.framebufferColorSampleCounts) == "string" then
		tbl.framebufferColorSampleCounts = library.e.sample_count[tbl.framebufferColorSampleCounts]
	end
	if type(tbl.framebufferDepthSampleCounts) == "table" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count.make_enums(tbl.framebufferDepthSampleCounts)
	elseif type(tbl.framebufferDepthSampleCounts) == "string" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count[tbl.framebufferDepthSampleCounts]
	end
	if type(tbl.framebufferStencilSampleCounts) == "table" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count.make_enums(tbl.framebufferStencilSampleCounts)
	elseif type(tbl.framebufferStencilSampleCounts) == "string" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count[tbl.framebufferStencilSampleCounts]
	end
	if type(tbl.framebufferNoAttachmentsSampleCounts) == "table" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count.make_enums(tbl.framebufferNoAttachmentsSampleCounts)
	elseif type(tbl.framebufferNoAttachmentsSampleCounts) == "string" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count[tbl.framebufferNoAttachmentsSampleCounts]
	end
	if type(tbl.sampledImageColorSampleCounts) == "table" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageColorSampleCounts)
	elseif type(tbl.sampledImageColorSampleCounts) == "string" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count[tbl.sampledImageColorSampleCounts]
	end
	if type(tbl.sampledImageIntegerSampleCounts) == "table" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageIntegerSampleCounts)
	elseif type(tbl.sampledImageIntegerSampleCounts) == "string" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count[tbl.sampledImageIntegerSampleCounts]
	end
	if type(tbl.sampledImageDepthSampleCounts) == "table" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageDepthSampleCounts)
	elseif type(tbl.sampledImageDepthSampleCounts) == "string" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count[tbl.sampledImageDepthSampleCounts]
	end
	if type(tbl.sampledImageStencilSampleCounts) == "table" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageStencilSampleCounts)
	elseif type(tbl.sampledImageStencilSampleCounts) == "string" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count[tbl.sampledImageStencilSampleCounts]
	end
	if type(tbl.storageImageSampleCounts) == "table" then
		tbl.storageImageSampleCounts = library.e.sample_count.make_enums(tbl.storageImageSampleCounts)
	elseif type(tbl.storageImageSampleCounts) == "string" then
		tbl.storageImageSampleCounts = library.e.sample_count[tbl.storageImageSampleCounts]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceLimits", tbl)
end
function library.s.PhysicalDeviceLimitsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceLimits(v)
	end
	return ffi.new("struct VkPhysicalDeviceLimits[?]", #tbl, tbl)
end
function library.s.InstanceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.InstanceCreateInfo(v)
	end
	return ffi.new("struct VkInstanceCreateInfo[?]", #tbl, tbl)
end
function library.s.DescriptorBufferInfo(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDescriptorBufferInfo", tbl)
end
function library.s.DescriptorBufferInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorBufferInfo(v)
	end
	return ffi.new("struct VkDescriptorBufferInfo[?]", #tbl, tbl)
end
function library.s.MemoryRequirements(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkMemoryRequirements", tbl)
end
function library.s.MemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements(v)
	end
	return ffi.new("struct VkMemoryRequirements[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryRequirements(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.SparseImageFormatProperties(tbl.formatProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements", tbl)
end
function library.s.SparseImageMemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements(v)
	end
	return ffi.new("struct VkSparseImageMemoryRequirements[?]", #tbl, tbl)
end
function library.s.FramebufferArray(tbl) return ffi.new("struct VkFramebuffer_T *[?]", #tbl, tbl) end
function library.s.DescriptorSetLayoutBinding(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutBinding", tbl)
end
function library.s.DescriptorSetLayoutBindingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutBinding(v)
	end
	return ffi.new("struct VkDescriptorSetLayoutBinding[?]", #tbl, tbl)
end
function library.s.MemoryDedicatedRequirementsKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedRequirementsKHR(v)
	end
	return ffi.new("struct VkMemoryDedicatedRequirementsKHR[?]", #tbl, tbl)
end
function library.s.BindSparseInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindSparseInfo(v)
	end
	return ffi.new("struct VkBindSparseInfo[?]", #tbl, tbl)
end
function library.s.DisplayPropertiesKHR(tbl, table_only)
	if type(tbl.physicalDimensions) == "table" then
		tbl.physicalDimensions = library.s.Extent2D(tbl.physicalDimensions, true)
	end
	if type(tbl.physicalResolution) == "table" then
		tbl.physicalResolution = library.s.Extent2D(tbl.physicalResolution, true)
	end
	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end
	return table_only and tbl or ffi.new("struct VkDisplayPropertiesKHR", tbl)
end
function library.s.DisplayPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayPropertiesKHR[?]", #tbl, tbl)
end
function library.s.SurfaceCapabilitiesKHR(tbl, table_only)
	if type(tbl.currentExtent) == "table" then
		tbl.currentExtent = library.s.Extent2D(tbl.currentExtent, true)
	end
	if type(tbl.minImageExtent) == "table" then
		tbl.minImageExtent = library.s.Extent2D(tbl.minImageExtent, true)
	end
	if type(tbl.maxImageExtent) == "table" then
		tbl.maxImageExtent = library.s.Extent2D(tbl.maxImageExtent, true)
	end
	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end
	if type(tbl.currentTransform) == "table" then
		tbl.currentTransform = library.e.surface_transform.make_enums(tbl.currentTransform)
	elseif type(tbl.currentTransform) == "string" then
		tbl.currentTransform = library.e.surface_transform[tbl.currentTransform]
	end
	if type(tbl.supportedCompositeAlpha) == "table" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha.make_enums(tbl.supportedCompositeAlpha)
	elseif type(tbl.supportedCompositeAlpha) == "string" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha[tbl.supportedCompositeAlpha]
	end
	if type(tbl.supportedUsageFlags) == "table" then
		tbl.supportedUsageFlags = library.e.image_usage.make_enums(tbl.supportedUsageFlags)
	elseif type(tbl.supportedUsageFlags) == "string" then
		tbl.supportedUsageFlags = library.e.image_usage[tbl.supportedUsageFlags]
	end
	return table_only and tbl or ffi.new("struct VkSurfaceCapabilitiesKHR", tbl)
end
function library.s.SurfaceCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilitiesKHR(v)
	end
	return ffi.new("struct VkSurfaceCapabilitiesKHR[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceFeatures(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures", tbl)
end
function library.s.PhysicalDeviceFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures(v)
	end
	return ffi.new("struct VkPhysicalDeviceFeatures[?]", #tbl, tbl)
end
function library.s.SemaphoreArray(tbl) return ffi.new("struct VkSemaphore_T *[?]", #tbl, tbl) end
function library.s.Offset2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset2D", tbl)
end
function library.s.Offset2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset2D(v)
	end
	return ffi.new("struct VkOffset2D[?]", #tbl, tbl)
end
function library.s.SemaphoreGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SemaphoreGetFdInfoKHR(v)
	end
	return ffi.new("struct VkSemaphoreGetFdInfoKHR[?]", #tbl, tbl)
end
function library.s.PipelineInputAssemblyStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineInputAssemblyStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineInputAssemblyStateCreateInfo[?]", #tbl, tbl)
end
function library.s.DisplayKHRArray(tbl) return ffi.new("struct VkDisplayKHR_T *[?]", #tbl, tbl) end
function library.s.DrawIndexedIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndexedIndirectCommand", tbl)
end
function library.s.DrawIndexedIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndexedIndirectCommand(v)
	end
	return ffi.new("struct VkDrawIndexedIndirectCommand[?]", #tbl, tbl)
end
function library.s.ShaderModuleCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderModuleCreateInfo(v)
	end
	return ffi.new("struct VkShaderModuleCreateInfo[?]", #tbl, tbl)
end
function library.s.PresentRegionKHR(tbl, table_only)
	if type(tbl.pRectangles) == "table" then
		if not tbl.rectangleCount then
			tbl.rectangleCount = #tbl.pRectangles
		end
		tbl.pRectangles = library.s.RectLayerKHRArray(tbl.pRectangles, false)
	end
	return table_only and tbl or ffi.new("struct VkPresentRegionKHR", tbl)
end
function library.s.PresentRegionKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentRegionKHR(v)
	end
	return ffi.new("struct VkPresentRegionKHR[?]", #tbl, tbl)
end
function library.s.PipelineColorBlendStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineColorBlendStateCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineLayoutCreateInfo(v)
	end
	return ffi.new("struct VkPipelineLayoutCreateInfo[?]", #tbl, tbl)
end
function library.s.DescriptorPoolSize(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.descriptor_type[tbl.type]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorPoolSize", tbl)
end
function library.s.DescriptorPoolSizeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolSize(v)
	end
	return ffi.new("struct VkDescriptorPoolSize[?]", #tbl, tbl)
end
function library.s.DescriptorSetAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetAllocateInfo(v)
	end
	return ffi.new("struct VkDescriptorSetAllocateInfo[?]", #tbl, tbl)
end
function library.s.DisplayPresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPresentInfoKHR(v)
	end
	return ffi.new("struct VkDisplayPresentInfoKHR[?]", #tbl, tbl)
end
function library.s.RenderPassCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassCreateInfo(v)
	end
	return ffi.new("struct VkRenderPassCreateInfo[?]", #tbl, tbl)
end
function library.s.FenceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FenceCreateInfo(v)
	end
	return ffi.new("struct VkFenceCreateInfo[?]", #tbl, tbl)
end
function library.s.MemoryAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateInfo(v)
	end
	return ffi.new("struct VkMemoryAllocateInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceProperties2KHR(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.PhysicalDeviceProperties(tbl.properties, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties2KHR", tbl)
end
function library.s.PhysicalDeviceProperties2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties2KHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceProperties2KHR[?]", #tbl, tbl)
end
function library.s.CommandPoolArray(tbl) return ffi.new("struct VkCommandPool_T *[?]", #tbl, tbl) end
function library.s.QueryPoolArray(tbl) return ffi.new("struct VkQueryPool_T *[?]", #tbl, tbl) end
function library.s.MemoryType(tbl, table_only)
	if type(tbl.propertyFlags) == "table" then
		tbl.propertyFlags = library.e.memory_property.make_enums(tbl.propertyFlags)
	elseif type(tbl.propertyFlags) == "string" then
		tbl.propertyFlags = library.e.memory_property[tbl.propertyFlags]
	end
	return table_only and tbl or ffi.new("struct VkMemoryType", tbl)
end
function library.s.MemoryTypeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryType(v)
	end
	return ffi.new("struct VkMemoryType[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceIDPropertiesKHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceIDPropertiesKHR", tbl)
end
function library.s.PhysicalDeviceIDPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceIDPropertiesKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceIDPropertiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineRasterizationStateRasterizationOrderAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateRasterizationOrderAMD(v)
	end
	return ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD[?]", #tbl, tbl)
end
function library.s.MemoryGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryGetFdInfoKHR(v)
	end
	return ffi.new("struct VkMemoryGetFdInfoKHR[?]", #tbl, tbl)
end
function library.s.DeviceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceCreateInfo(v)
	end
	return ffi.new("struct VkDeviceCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageSubresource(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresource", tbl)
end
function library.s.ImageSubresourceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresource(v)
	end
	return ffi.new("struct VkImageSubresource[?]", #tbl, tbl)
end
function library.s.BufferCopy(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferCopy", tbl)
end
function library.s.BufferCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCopy(v)
	end
	return ffi.new("struct VkBufferCopy[?]", #tbl, tbl)
end
function library.s.ExternalImageFormatPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatPropertiesKHR(v)
	end
	return ffi.new("struct VkExternalImageFormatPropertiesKHR[?]", #tbl, tbl)
end
function library.s.DeviceMemoryArray(tbl) return ffi.new("struct VkDeviceMemory_T *[?]", #tbl, tbl) end
function library.s.SpecializationMapEntry(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSpecializationMapEntry", tbl)
end
function library.s.SpecializationMapEntryArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationMapEntry(v)
	end
	return ffi.new("struct VkSpecializationMapEntry[?]", #tbl, tbl)
end
function library.s.MappedMemoryRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MappedMemoryRange(v)
	end
	return ffi.new("struct VkMappedMemoryRange[?]", #tbl, tbl)
end
function library.s.DeviceGroupRenderPassBeginInfoKHXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupRenderPassBeginInfoKHX(v)
	end
	return ffi.new("struct VkDeviceGroupRenderPassBeginInfoKHX[?]", #tbl, tbl)
end
function library.s.MemoryHeap(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.memory_heap.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.memory_heap[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkMemoryHeap", tbl)
end
function library.s.MemoryHeapArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryHeap(v)
	end
	return ffi.new("struct VkMemoryHeap[?]", #tbl, tbl)
end
function library.s.ImageSubresourceLayers(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresourceLayers", tbl)
end
function library.s.ImageSubresourceLayersArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceLayers(v)
	end
	return ffi.new("struct VkImageSubresourceLayers[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceExternalBufferInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalBufferInfoKHR(v)
	end
	return ffi.new("struct VkPhysicalDeviceExternalBufferInfoKHR[?]", #tbl, tbl)
end
function library.s.DeviceArray(tbl) return ffi.new("struct VkDevice_T *[?]", #tbl, tbl) end
function library.s.SamplerCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerCreateInfo(v)
	end
	return ffi.new("struct VkSamplerCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageSubresourceRange(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresourceRange", tbl)
end
function library.s.ImageSubresourceRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceRange(v)
	end
	return ffi.new("struct VkImageSubresourceRange[?]", #tbl, tbl)
end
function library.s.SwapchainKHRArray(tbl) return ffi.new("struct VkSwapchainKHR_T *[?]", #tbl, tbl) end
function library.s.DescriptorPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolCreateInfo(v)
	end
	return ffi.new("struct VkDescriptorPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.BufferImageCopy(tbl, table_only)
	if type(tbl.imageSubresource) == "table" then
		tbl.imageSubresource = library.s.ImageSubresourceLayers(tbl.imageSubresource, true)
	end
	if type(tbl.imageOffset) == "table" then
		tbl.imageOffset = library.s.Offset3D(tbl.imageOffset, true)
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent3D(tbl.imageExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkBufferImageCopy", tbl)
end
function library.s.BufferImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferImageCopy(v)
	end
	return ffi.new("struct VkBufferImageCopy[?]", #tbl, tbl)
end
function library.s.MemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryBarrier(v)
	end
	return ffi.new("struct VkMemoryBarrier[?]", #tbl, tbl)
end
function library.CreateBufferView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferViewCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkBufferView_T * [1]")
	local status = CLIB.vkCreateBufferView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then
			createInfoCount = #pCreateInfos
		end
		pCreateInfos = library.s.GraphicsPipelineCreateInfoArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateShaderModule(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ShaderModuleCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkShaderModule_T * [1]")
	local status = CLIB.vkCreateShaderModule(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateFramebuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FramebufferCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkFramebuffer_T * [1]")
	local status = CLIB.vkCreateFramebuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then
			createInfoCount = #pCreateInfos
		end
		pCreateInfos = library.s.ComputePipelineCreateInfoArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateQueryPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.QueryPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkQueryPool_T * [1]")
	local status = CLIB.vkCreateQueryPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDescriptorSetLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorSetLayoutCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDescriptorSetLayout_T * [1]")
	local status = CLIB.vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateCommandBuffers(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.CommandBufferAllocateInfo(pAllocateInfo, false)
	end
	local box = ffi.new("struct VkCommandBuffer_T * [1]")
	local status = CLIB.vkAllocateCommandBuffers(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDescriptorPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDescriptorPool_T * [1]")
	local status = CLIB.vkCreateDescriptorPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateEvent(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.EventCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkEvent_T * [1]")
	local status = CLIB.vkCreateEvent(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateObjectTable(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ObjectTableCreateInfoNVX(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkObjectTableNVX_T * [1]")
	local status = library.CreateObjectTableNVX(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateIndirectCommandsLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.IndirectCommandsLayoutCreateInfoNVX(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkIndirectCommandsLayoutNVX_T * [1]")
	local status = library.CreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateBuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkBuffer_T * [1]")
	local status = CLIB.vkCreateBuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSwapchain(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SwapchainCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSwapchainKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSemaphore(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SemaphoreCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSemaphore_T * [1]")
	local status = CLIB.vkCreateSemaphore(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreatePipelineCache(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineCacheCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipelineCache_T * [1]")
	local status = CLIB.vkCreatePipelineCache(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateImageView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageViewCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkImageView_T * [1]")
	local status = CLIB.vkCreateImageView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDebugReportCallback(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DebugReportCallbackCreateInfoEXT(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDebugReportCallbackEXT_T * [1]")
	local status = library.CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSampler(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SamplerCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSampler_T * [1]")
	local status = CLIB.vkCreateSampler(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDevice(physicalDevice, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DeviceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDevice_T * [1]")
	local status = CLIB.vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateInstance(pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.InstanceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkInstance_T * [1]")
	local status = CLIB.vkCreateInstance(pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSharedSwapchains(device, swapchainCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not swapchainCount then
			swapchainCount = #pCreateInfos
		end
		pCreateInfos = library.s.SwapchainCreateInfoKHRArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateDisplayPlaneSurface(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplaySurfaceCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSurfaceKHR_T * [1]")
	local status = library.CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateImage(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkImage_T * [1]")
	local status = CLIB.vkCreateImage(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateMemory(device, pAllocateInfo, pAllocator)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.MemoryAllocateInfo(pAllocateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDeviceMemory_T * [1]")
	local status = CLIB.vkAllocateMemory(device, pAllocateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDisplayMode(physicalDevice, display, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplayModeCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDisplayModeKHR_T * [1]")
	local status = library.CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateFence(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FenceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkFence_T * [1]")
	local status = CLIB.vkCreateFence(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateRenderPass(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.RenderPassCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkRenderPass_T * [1]")
	local status = CLIB.vkCreateRenderPass(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorUpdateTemplateCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDescriptorUpdateTemplateKHR_T * [1]")
	local status = library.CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateCommandPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.CommandPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkCommandPool_T * [1]")
	local status = CLIB.vkCreateCommandPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateDescriptorSets(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.DescriptorSetAllocateInfo(pAllocateInfo, false)
	end
	local box = ffi.new("struct VkDescriptorSet_T * [1]")
	local status = CLIB.vkAllocateDescriptorSets(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreatePipelineLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineLayoutCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipelineLayout_T * [1]")
	local status = CLIB.vkCreatePipelineLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.DeviceWaitIdle(device)
	return CLIB.vkDeviceWaitIdle(device)
end

function library.CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
end

function library.CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageResolveArray(pRegions, false)
	end
	return CLIB.vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
end

function library.DestroyObjectTable(device, objectTable, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroyObjectTableNVX(device, objectTable, pAllocator)
end

function library.DestroyInstance(instance, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyInstance(instance, pAllocator)
end

function library.ResetEvent(device, event)
	return CLIB.vkResetEvent(device, event)
end

function library.QueueWaitIdle(queue)
	return CLIB.vkQueueWaitIdle(queue)
end

function library.RegisterDisplayEvent(device, display, pDisplayEventInfo, pAllocator, pFence)
	if type(pDisplayEventInfo) == "table" then
		pDisplayEventInfo = library.s.DisplayEventInfoEXT(pDisplayEventInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)
end

function library.ImportFenceFd(device, pImportFenceFdInfo)
	if type(pImportFenceFdInfo) == "table" then
		pImportFenceFdInfo = library.s.ImportFenceFdInfoKHR(pImportFenceFdInfo, false)
	end
	return library.ImportFenceFdKHR(device, pImportFenceFdInfo)
end

function library.CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
	if type(pipelineStage) == "table" then
		pipelineStage = library.e.pipeline_stage.make_enums(pipelineStage)
	elseif type(pipelineStage) == "string" then
		pipelineStage = library.e.pipeline_stage[pipelineStage]
	end
	return CLIB.vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
end

function library.CmdSetViewportWScalin(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
	if type(pViewportWScalings) == "table" then
		if not viewportCount then
			viewportCount = #pViewportWScalings
		end
		pViewportWScalings = library.s.ViewportWScalingNVArray(pViewportWScalings, false)
	end
	return library.CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
end

function library.DestroySurface(instance, surface, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroySurfaceKHR(instance, surface, pAllocator)
end

function library.CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end
	return CLIB.vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
end

function library.MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
	if type(pSrcCaches) == "table" then
		if not srcCacheCount then
			srcCacheCount = #pSrcCaches
		end
		pSrcCaches = library.s.PipelineCacheArray(pSrcCaches, false)
	end
	return CLIB.vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
end

function library.CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
end

function library.CmdResetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end
	return CLIB.vkCmdResetEvent(commandBuffer, event, stageMask)
end

function library.BindBufferMemory(device, buffer, memory, memoryOffset)
	return CLIB.vkBindBufferMemory(device, buffer, memory, memoryOffset)
end

function library.CmdSetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end
	return CLIB.vkCmdSetEvent(commandBuffer, event, stageMask)
end

function library.CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end
	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then
			descriptorSetCount = #pDescriptorSets
		end
		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end
	return CLIB.vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
end

function library.CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
	return CLIB.vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
end

function library.CmdDispatchIndirect(commandBuffer, buffer, offset)
	return CLIB.vkCmdDispatchIndirect(commandBuffer, buffer, offset)
end

function library.DestroyEvent(device, event, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyEvent(device, event, pAllocator)
end

function library.CmdNextSubpass(commandBuffer, contents)
	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end
	return CLIB.vkCmdNextSubpass(commandBuffer, contents)
end

function library.CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
end

function library.RegisterObjects(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)
	if type(ppObjectTableEntries) == "table" then
		objectCount = #ppObjectTableEntries
		ppObjectTableEntries = library.util.StringList(ppObjectTableEntries)
	end
	return library.RegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)
end

function library.CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	return library.CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
end

function library.DestroyBuffer(device, buffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyBuffer(device, buffer, pAllocator)
end

function library.CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.DestroyIndirectCommandsLayout(device, indirectCommandsLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)
end

function library.ResetFences(device, fenceCount, pFences)
	if type(pFences) == "table" then
		if not fenceCount then
			fenceCount = #pFences
		end
		pFences = library.s.FenceArray(pFences, false)
	end
	return CLIB.vkResetFences(device, fenceCount, pFences)
end

function library.DestroyQueryPool(device, queryPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyQueryPool(device, queryPool, pAllocator)
end

function library.CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
	return CLIB.vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
end

function library.CmdSetStencilReference(commandBuffer, faceMask, reference)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilReference(commandBuffer, faceMask, reference)
end

function library.DisplayPowerControl(device, display, pDisplayPowerInfo)
	if type(pDisplayPowerInfo) == "table" then
		pDisplayPowerInfo = library.s.DisplayPowerInfoEXT(pDisplayPowerInfo, false)
	end
	return library.DisplayPowerControlEXT(device, display, pDisplayPowerInfo)
end

function library.EndCommandBuffer(commandBuffer)
	return CLIB.vkEndCommandBuffer(commandBuffer)
end

function library.UnregisterObjects(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)
	if type(pObjectEntryTypes) == "string" then
		pObjectEntryTypes = library.e.object_entry_type[pObjectEntryTypes]
	end
	return library.UnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)
end

function library.FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then
			commandBufferCount = #pCommandBuffers
		end
		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end
	return CLIB.vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
end

function library.CmdReserveSpaceForCommands(commandBuffer, pReserveSpaceInfo)
	if type(pReserveSpaceInfo) == "table" then
		pReserveSpaceInfo = library.s.CmdReserveSpaceForCommandsInfoNVX(pReserveSpaceInfo, false)
	end
	return library.CmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)
end

function library.CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
	return library.CmdDispatchBaseKHX(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
end

function library.DestroyDebugReportCallback(instance, callback, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroyDebugReportCallbackEXT(instance, callback, pAllocator)
end

function library.CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
	if type(pViewports) == "table" then
		if not viewportCount then
			viewportCount = #pViewports
		end
		pViewports = library.s.ViewportArray(pViewports, false)
	end
	return CLIB.vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
end

function library.CmdBeginQuery(commandBuffer, queryPool, query, flags)
	if type(flags) == "table" then
		flags = library.e.query_control.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_control[flags]
	end
	return CLIB.vkCmdBeginQuery(commandBuffer, queryPool, query, flags)
end

function library.CmdProcessCommands(commandBuffer, pProcessCommandsInfo)
	if type(pProcessCommandsInfo) == "table" then
		pProcessCommandsInfo = library.s.CmdProcessCommandsInfoNVX(pProcessCommandsInfo, false)
	end
	return library.CmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)
end

function library.DestroyPipeline(device, pipeline, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipeline(device, pipeline, pAllocator)
end

function library.QueueSubmit(queue, submitCount, pSubmits, fence)
	if type(pSubmits) == "table" then
		if not submitCount then
			submitCount = #pSubmits
		end
		pSubmits = library.s.SubmitInfoArray(pSubmits, false)
	end
	return CLIB.vkQueueSubmit(queue, submitCount, pSubmits, fence)
end

function library.CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageBlitArray(pRegions, false)
	end
	if type(filter) == "string" then
		filter = library.e.filter[filter]
	end
	return CLIB.vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
end

function library.BindImageMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then
			bindInfoCount = #pBindInfos
		end
		pBindInfos = library.s.BindImageMemoryInfoKHXArray(pBindInfos, false)
	end
	return library.BindImageMemory2KHX(device, bindInfoCount, pBindInfos)
end

function library.CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.TrimCommandPool(device, commandPool, flags)
	return library.TrimCommandPoolKHR(device, commandPool, flags)
end

function library.CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	return CLIB.vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
end

function library.CmdSetDeviceMask(commandBuffer, deviceMask)
	return library.CmdSetDeviceMaskKHX(commandBuffer, deviceMask)
end

function library.DestroyShaderModule(device, shaderModule, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyShaderModule(device, shaderModule, pAllocator)
end

function library.DestroyPipelineLayout(device, pipelineLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)
end

function library.DestroySampler(device, sampler, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroySampler(device, sampler, pAllocator)
end

function library.FreeMemory(device, memory, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkFreeMemory(device, memory, pAllocator)
end

function library.DestroySwapchain(device, swapchain, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroySwapchainKHR(device, swapchain, pAllocator)
end

function library.DestroyFramebuffer(device, framebuffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyFramebuffer(device, framebuffer, pAllocator)
end

function library.CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
	if type(pBuffers) == "table" then
		if not bindingCount then
			bindingCount = #pBuffers
		end
		pBuffers = library.s.BufferArray(pBuffers, false)
	end
	return CLIB.vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
end

function library.CmdDebugMarkerEnd(commandBuffer)
	return library.CmdDebugMarkerEndEXT(commandBuffer)
end

function library.CmdDebugMarkerBegin(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end
	return library.CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)
end

function library.CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
	return CLIB.vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
end

function library.DebugMarkerSetObjectTag(device, pTagInfo)
	if type(pTagInfo) == "table" then
		pTagInfo = library.s.DebugMarkerObjectTagInfoEXT(pTagInfo, false)
	end
	return library.DebugMarkerSetObjectTagEXT(device, pTagInfo)
end

function library.DestroyCommandPool(device, commandPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyCommandPool(device, commandPool, pAllocator)
end

function library.DebugReportMessage(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)
	if type(flags) == "table" then
		flags = library.e.debug_report.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.debug_report[flags]
	end
	if type(objectType) == "string" then
		objectType = library.e.debug_report_object_type[objectType]
	end
	return library.DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)
end

function library.CmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
	return library.CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
end

function library.DestroyDescriptorPool(device, descriptorPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDescriptorPool(device, descriptorPool, pAllocator)
end

function library.InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then
			memoryRangeCount = #pMemoryRanges
		end
		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end
	return CLIB.vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end
	return CLIB.vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
end

function library.DestroyBufferView(device, bufferView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyBufferView(device, bufferView, pAllocator)
end

function library.DestroyImageView(device, imageView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyImageView(device, imageView, pAllocator)
end

function library.ResetCommandBuffer(commandBuffer, flags)
	if type(flags) == "table" then
		flags = library.e.command_buffer_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_buffer_reset[flags]
	end
	return CLIB.vkResetCommandBuffer(commandBuffer, flags)
end

function library.CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.DestroySemaphore(device, semaphore, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroySemaphore(device, semaphore, pAllocator)
end

function library.BindBufferMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then
			bindInfoCount = #pBindInfos
		end
		pBindInfos = library.s.BindBufferMemoryInfoKHXArray(pBindInfos, false)
	end
	return library.BindBufferMemory2KHX(device, bindInfoCount, pBindInfos)
end

function library.DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)
end

function library.DestroyPipelineCache(device, pipelineCache, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipelineCache(device, pipelineCache, pAllocator)
end

function library.GetInstanceProcAddr(instance, pName)
	return CLIB.vkGetInstanceProcAddr(instance, pName)
end

function library.CmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end
	if type(pDescriptorWrites) == "table" then
		if not descriptorWriteCount then
			descriptorWriteCount = #pDescriptorWrites
		end
		pDescriptorWrites = library.s.WriteDescriptorSetArray(pDescriptorWrites, false)
	end
	return library.CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
end

function library.SetEvent(device, event)
	return CLIB.vkSetEvent(device, event)
end

function library.ImportSemaphoreFd(device, pImportSemaphoreFdInfo)
	if type(pImportSemaphoreFdInfo) == "table" then
		pImportSemaphoreFdInfo = library.s.ImportSemaphoreFdInfoKHR(pImportSemaphoreFdInfo, false)
	end
	return library.ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)
end

function library.CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end
	if type(pDepthStencil) == "table" then
		pDepthStencil = library.s.ClearDepthStencilValue(pDepthStencil, false)
	end
	if type(pRanges) == "table" then
		if not rangeCount then
			rangeCount = #pRanges
		end
		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end
	return CLIB.vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
end

function library.CmdEndRenderPass(commandBuffer)
	return CLIB.vkCmdEndRenderPass(commandBuffer)
end

function library.BeginCommandBuffer(commandBuffer, pBeginInfo)
	if type(pBeginInfo) == "table" then
		pBeginInfo = library.s.CommandBufferBeginInfo(pBeginInfo, false)
	end
	return CLIB.vkBeginCommandBuffer(commandBuffer, pBeginInfo)
end

function library.CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	return CLIB.vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
end

function library.CmdDebugMarkerInsert(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end
	return library.CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)
end

function library.CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
	return CLIB.vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
end

function library.CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	if type(pEvents) == "table" then
		if not eventCount then
			eventCount = #pEvents
		end
		pEvents = library.s.EventArray(pEvents, false)
	end
	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end
	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end
	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then
			memoryBarrierCount = #pMemoryBarriers
		end
		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end
	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end
		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end
	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end
		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end
	return CLIB.vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
end

function library.CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	return library.CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
end

function library.QueuePresent(queue, pPresentInfo)
	if type(pPresentInfo) == "table" then
		pPresentInfo = library.s.PresentInfoKHR(pPresentInfo, false)
	end
	return library.QueuePresentKHR(queue, pPresentInfo)
end

function library.DestroyFence(device, fence, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyFence(device, fence, pAllocator)
end

function library.CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end
	if type(pColor) == "table" then
		pColor = library.s.ClearColorValue(pColor, false)
	end
	if type(pRanges) == "table" then
		if not rangeCount then
			rangeCount = #pRanges
		end
		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end
	return CLIB.vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
end

function library.CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then
			commandBufferCount = #pCommandBuffers
		end
		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end
	return CLIB.vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
end

function library.CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
	if type(pRenderPassBegin) == "table" then
		pRenderPassBegin = library.s.RenderPassBeginInfo(pRenderPassBegin, false)
	end
	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end
	return CLIB.vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
end

function library.CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
	if type(pAttachments) == "table" then
		if not attachmentCount then
			attachmentCount = #pAttachments
		end
		pAttachments = library.s.ClearAttachmentArray(pAttachments, false)
	end
	if type(pRects) == "table" then
		if not rectCount then
			rectCount = #pRects
		end
		pRects = library.s.ClearRectArray(pRects, false)
	end
	return CLIB.vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
end

function library.CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
	if type(stageFlags) == "table" then
		stageFlags = library.e.shader_stage.make_enums(stageFlags)
	elseif type(stageFlags) == "string" then
		stageFlags = library.e.shader_stage[stageFlags]
	end
	return CLIB.vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
end

function library.DebugMarkerSetObjectName(device, pNameInfo)
	if type(pNameInfo) == "table" then
		pNameInfo = library.s.DebugMarkerObjectNameInfoEXT(pNameInfo, false)
	end
	return library.DebugMarkerSetObjectNameEXT(device, pNameInfo)
end

function library.CmdEndQuery(commandBuffer, queryPool, query)
	return CLIB.vkCmdEndQuery(commandBuffer, queryPool, query)
end

function library.CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
	if type(indexType) == "string" then
		indexType = library.e.index_type[indexType]
	end
	return CLIB.vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
end

function library.ReleaseDisplay(physicalDevice, display)
	return library.ReleaseDisplayEXT(physicalDevice, display)
end

function library.DestroyImage(device, image, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyImage(device, image, pAllocator)
end

function library.CmdSetBlendConstants(commandBuffer, unknown_2)
	return CLIB.vkCmdSetBlendConstants(commandBuffer, unknown_2)
end

function library.GetDeviceProcAddr(device, pName)
	return CLIB.vkGetDeviceProcAddr(device, pName)
end

function library.BindImageMemory(device, image, memory, memoryOffset)
	return CLIB.vkBindImageMemory(device, image, memory, memoryOffset)
end

function library.DestroyRenderPass(device, renderPass, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyRenderPass(device, renderPass, pAllocator)
end

function library.UnmapMemory(device, memory)
	return CLIB.vkUnmapMemory(device, memory)
end

function library.SetHdrMetadata(device, swapchainCount, pSwapchains, pMetadata)
	if type(pSwapchains) == "table" then
		if not swapchainCount then
			swapchainCount = #pSwapchains
		end
		pSwapchains = library.s.SwapchainKHRArray(pSwapchains, false)
	end
	if type(pMetadata) == "table" then
		pMetadata = library.s.HdrMetadataEXT(pMetadata, false)
	end
	return library.SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)
end

function library.CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)
	return CLIB.vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)
end

function library.ResetDescriptorPool(device, descriptorPool, flags)
	return CLIB.vkResetDescriptorPool(device, descriptorPool, flags)
end

function library.WaitForFences(device, fenceCount, pFences, waitAll, timeout)
	if type(pFences) == "table" then
		if not fenceCount then
			fenceCount = #pFences
		end
		pFences = library.s.FenceArray(pFences, false)
	end
	tbl.waitAll = waitAll and 1 or 0
	return CLIB.vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)
end

function library.CmdSetLineWidth(commandBuffer, lineWidth)
	return CLIB.vkCmdSetLineWidth(commandBuffer, lineWidth)
end

function library.CmdSetDiscardRectangle(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
	if type(pDiscardRectangles) == "table" then
		if not discardRectangleCount then
			discardRectangleCount = #pDiscardRectangles
		end
		pDiscardRectangles = library.s.Rect2DArray(pDiscardRectangles, false)
	end
	return library.CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
end

function library.UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData)
	return library.UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData)
end

function library.DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
end

function library.FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then
			memoryRangeCount = #pMemoryRanges
		end
		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end
	return CLIB.vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.DestroyDevice(device, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDevice(device, pAllocator)
end

function library.FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then
			descriptorSetCount = #pDescriptorSets
		end
		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end
	return CLIB.vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
end

function library.CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
	return CLIB.vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
end

function library.RegisterDeviceEvent(device, pDeviceEventInfo, pAllocator, pFence)
	if type(pDeviceEventInfo) == "table" then
		pDeviceEventInfo = library.s.DeviceEventInfoEXT(pDeviceEventInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)
end

function library.CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
	if type(pScissors) == "table" then
		if not scissorCount then
			scissorCount = #pScissors
		end
		pScissors = library.s.Rect2DArray(pScissors, false)
	end
	return CLIB.vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
end

function library.QueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
	if type(pBindInfo) == "table" then
		if not bindInfoCount then
			bindInfoCount = #pBindInfo
		end
		pBindInfo = library.s.BindSparseInfoArray(pBindInfo, false)
	end
	return CLIB.vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
end

function library.UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
	if type(pDescriptorWrites) == "table" then
		if not descriptorWriteCount then
			descriptorWriteCount = #pDescriptorWrites
		end
		pDescriptorWrites = library.s.WriteDescriptorSetArray(pDescriptorWrites, false)
	end
	if type(pDescriptorCopies) == "table" then
		if not descriptorCopyCount then
			descriptorCopyCount = #pDescriptorCopies
		end
		pDescriptorCopies = library.s.CopyDescriptorSetArray(pDescriptorCopies, false)
	end
	return CLIB.vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
end

function library.GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end
	return CLIB.vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
end

function library.CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end
	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end
	if type(dependencyFlags) == "table" then
		dependencyFlags = library.e.dependency.make_enums(dependencyFlags)
	elseif type(dependencyFlags) == "string" then
		dependencyFlags = library.e.dependency[dependencyFlags]
	end
	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then
			memoryBarrierCount = #pMemoryBarriers
		end
		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end
	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end
		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end
	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end
		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end
	return CLIB.vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
end

function library.ResetCommandPool(device, commandPool, flags)
	if type(flags) == "table" then
		flags = library.e.command_pool_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_pool_reset[flags]
	end
	return CLIB.vkResetCommandPool(device, commandPool, flags)
end

do
	local META = {
		Present = library.QueuePresent,
		WaitIdle = library.QueueWaitIdle,
		BindSparse = library.QueueBindSparse,
		Submit = library.QueueSubmit,
	}
	META.__index = META
	ffi.metatype("struct VkQueue_T", META)
end
do
	local META = {
		CreateBufferView = library.CreateBufferView,
		DestroySemaphore = library.DestroySemaphore,
		CreateFramebuffer = library.CreateFramebuffer,
		DestroyPipelineLayout = library.DestroyPipelineLayout,
		GetEventStatus = library.GetEventStatus,
		DebugMarkerSetObjectName = library.DebugMarkerSetObjectName,
		RegisterDisplayEvent = library.RegisterDisplayEvent,
		DestroySwapchain = library.DestroySwapchain,
		RegisterObjects = library.RegisterObjects,
		CreateComputePipelines = library.CreateComputePipelines,
		UpdateDescriptorSetWithTemplate = library.UpdateDescriptorSetWithTemplate,
		GetPipelineCacheData = library.GetPipelineCacheData,
		DestroyObjectTable = library.DestroyObjectTable,
		CreateDescriptorUpdateTemplate = library.CreateDescriptorUpdateTemplate,
		DestroyImageView = library.DestroyImageView,
		WaitIdle = library.DeviceWaitIdle,
		LoadProcAddr = library.util.LoadDeviceProcAddr,
		CreateDescriptorSetLayout = library.CreateDescriptorSetLayout,
		GetSwapchainStatus = library.GetSwapchainStatus,
		DestroyDescriptorUpdateTemplate = library.DestroyDescriptorUpdateTemplate,
		CreateFence = library.CreateFence,
		ResetEvent = library.ResetEvent,
		DestroyFence = library.DestroyFence,
		GetFenceStatus = library.GetFenceStatus,
		CreateGraphicsPipelines = library.CreateGraphicsPipelines,
		GetBufferMemoryRequirements2 = library.GetBufferMemoryRequirements2,
		CreateObjectTable = library.CreateObjectTable,
		SetHdrMetadata = library.SetHdrMetadata,
		GetQueryPoolResults = library.GetQueryPoolResults,
		UpdateDescriptorSets = library.UpdateDescriptorSets,
		TrimCommandPool = library.TrimCommandPool,
		GetMemoryFd = library.GetMemoryFd,
		CreateIndirectCommandsLayout = library.CreateIndirectCommandsLayout,
		CreateImage = library.CreateImage,
		AllocateDescriptorSets = library.AllocateDescriptorSets,
		GetBufferMemoryRequirements = library.GetBufferMemoryRequirements,
		CreatePipelineLayout = library.CreatePipelineLayout,
		BindImageMemory = library.BindImageMemory,
		UnmapMemory = library.UnmapMemory,
		Destroy = library.DestroyDevice,
		GetMemoryFdProperties = library.GetMemoryFdProperties,
		DestroyShaderModule = library.DestroyShaderModule,
		CreateSwapchain = library.CreateSwapchain,
		GetImageSparseMemoryRequirements2 = library.GetImageSparseMemoryRequirements2,
		DestroyPipeline = library.DestroyPipeline,
		GetRenderAreaGranularity = library.GetRenderAreaGranularity,
		ImportFenceFd = library.ImportFenceFd,
		FreeDescriptorSets = library.FreeDescriptorSets,
		FlushMappedMemoryRanges = library.FlushMappedMemoryRanges,
		GetGroupPeerMemoryFeatures = library.GetDeviceGroupPeerMemoryFeatures,
		CreateQueryPool = library.CreateQueryPool,
		DestroySampler = library.DestroySampler,
		CreateCommandPool = library.CreateCommandPool,
		ResetCommandPool = library.ResetCommandPool,
		GetPastPresentationTimingGOO = library.GetPastPresentationTimingGOO,
		GetImageMemoryRequirements = library.GetImageMemoryRequirements,
		WaitForFences = library.WaitForFences,
		FreeCommandBuffers = library.FreeCommandBuffers,
		CreateSampler = library.CreateSampler,
		ResetDescriptorPool = library.ResetDescriptorPool,
		DestroyImage = library.DestroyImage,
		RegisterEvent = library.RegisterDeviceEvent,
		CreateImageView = library.CreateImageView,
		DestroyPipelineCache = library.DestroyPipelineCache,
		DebugMarkerSetObjectTag = library.DebugMarkerSetObjectTag,
		CreateDescriptorPool = library.CreateDescriptorPool,
		DestroyFramebuffer = library.DestroyFramebuffer,
		DestroyDescriptorSetLayout = library.DestroyDescriptorSetLayout,
		AllocateMemory = library.AllocateMemory,
		GetImageMemoryRequirements2 = library.GetImageMemoryRequirements2,
		AllocateCommandBuffers = library.AllocateCommandBuffers,
		GetSwapchainCounter = library.GetSwapchainCounter,
		BindImageMemory2 = library.BindImageMemory2,
		ImportSemaphoreFd = library.ImportSemaphoreFd,
		GetImageSparseMemoryRequirements = library.GetImageSparseMemoryRequirements,
		GetSemaphoreFd = library.GetSemaphoreFd,
		DestroyRenderPass = library.DestroyRenderPass,
		GetImageSubresourceLayout = library.GetImageSubresourceLayout,
		GetFenceFd = library.GetFenceFd,
		FreeMemory = library.FreeMemory,
		DestroyQueryPool = library.DestroyQueryPool,
		ResetFences = library.ResetFences,
		AcquireNextImage2 = library.AcquireNextImage2,
		CreateBuffer = library.CreateBuffer,
		GetSwapchainImages = library.GetSwapchainImages,
		DestroyIndirectCommandsLayout = library.DestroyIndirectCommandsLayout,
		AcquireNextImage = library.AcquireNextImage,
		GetMemoryCommitment = library.GetDeviceMemoryCommitment,
		SetEvent = library.SetEvent,
		BindBufferMemory = library.BindBufferMemory,
		DestroyBufferView = library.DestroyBufferView,
		DestroyBuffer = library.DestroyBuffer,
		DisplayPowerControl = library.DisplayPowerControl,
		CreatePipelineCache = library.CreatePipelineCache,
		BindBufferMemory2 = library.BindBufferMemory2,
		GetProcAddr = library.GetDeviceProcAddr,
		CreateEvent = library.CreateEvent,
		UnregisterObjects = library.UnregisterObjects,
		InvalidateMappedMemoryRanges = library.InvalidateMappedMemoryRanges,
		GetRefreshCycleDurationGOO = library.GetRefreshCycleDurationGOO,
		CreateSemaphore = library.CreateSemaphore,
		GetGroupPresentCapabilities = library.GetDeviceGroupPresentCapabilities,
		DestroyEvent = library.DestroyEvent,
		GetGroupSurfacePresentModes = library.GetDeviceGroupSurfacePresentModes,
		CreateRenderPass = library.CreateRenderPass,
		DestroyCommandPool = library.DestroyCommandPool,
		MapMemory = library.MapMemory,
		MergePipelineCaches = library.MergePipelineCaches,
		GetQueue = library.GetDeviceQueue,
		CreateSharedSwapchains = library.CreateSharedSwapchains,
		CreateShaderModule = library.CreateShaderModule,
		DestroyDescriptorPool = library.DestroyDescriptorPool,
	}
	META.__index = META
	ffi.metatype("struct VkDevice_T", META)
end
do
	local META = {
		GetDisplayPlaneProperties = library.GetPhysicalDeviceDisplayPlaneProperties,
		GetQueueFamilyProperties = library.GetPhysicalDeviceQueueFamilyProperties,
		GetFeatures2 = library.GetPhysicalDeviceFeatures2,
		GetExternalSemaphoreProperties = library.GetPhysicalDeviceExternalSemaphoreProperties,
		GetSurfaceFormats2 = library.GetPhysicalDeviceSurfaceFormats2,
		GetSurfaceCapabilities = library.GetPhysicalDeviceSurfaceCapabilities,
		GetSurfacePresentModes = library.GetPhysicalDeviceSurfacePresentModes,
		GetImageFormatProperties = library.GetPhysicalDeviceImageFormatProperties,
		GetMemoryProperties2 = library.GetPhysicalDeviceMemoryProperties2,
		CreateDevice = library.CreateDevice,
		GetFeatures = library.GetPhysicalDeviceFeatures,
		GetSurfaceSupport = library.GetPhysicalDeviceSurfaceSupport,
		GetDisplayPlaneCapabilities = library.GetDisplayPlaneCapabilities,
		GetExternalBufferProperties = library.GetPhysicalDeviceExternalBufferProperties,
		GetProperties2 = library.GetPhysicalDeviceProperties2,
		GetDeviceExtensionProperties = library.GetDeviceExtensionProperties,
		GetDisplayPlaneSupportedDisplays = library.GetDisplayPlaneSupportedDisplays,
		GetMemoryProperties = library.GetPhysicalDeviceMemoryProperties,
		GetPresentRectangles = library.GetPhysicalDevicePresentRectangles,
		GetDisplayProperties = library.GetPhysicalDeviceDisplayProperties,
		GetSparseImageFormatProperties2 = library.GetPhysicalDeviceSparseImageFormatProperties2,
		GetSurfaceCapabilities2 = library.GetPhysicalDeviceSurfaceCapabilities2,
		GetDisplayModeProperties = library.GetDisplayModeProperties,
		GetQueueFamilyProperties2 = library.GetPhysicalDeviceQueueFamilyProperties2,
		GetExternalFenceProperties = library.GetPhysicalDeviceExternalFenceProperties,
		GetDeviceLayerProperties = library.GetDeviceLayerProperties,
		GetSparseImageFormatProperties = library.GetPhysicalDeviceSparseImageFormatProperties,
		GetSurfaceFormats = library.GetPhysicalDeviceSurfaceFormats,
		CreateDisplayMode = library.CreateDisplayMode,
		GetFormatProperties = library.GetPhysicalDeviceFormatProperties,
		GetImageFormatProperties2 = library.GetPhysicalDeviceImageFormatProperties2,
		ReleaseDisplay = library.ReleaseDisplay,
		GetProperties = library.GetPhysicalDeviceProperties,
		GetGeneratedCommandsProperties = library.GetPhysicalDeviceGeneratedCommandsProperties,
		GetExternalImageFormatPropertie = library.GetPhysicalDeviceExternalImageFormatPropertie,
		GetFormatProperties2 = library.GetPhysicalDeviceFormatProperties2,
	}
	META.__index = META
	ffi.metatype("struct VkPhysicalDevice_T", META)
end
do
	local META = {
		DestroySurface = library.DestroySurface,
		CreateDisplayPlaneSurface = library.CreateDisplayPlaneSurface,
		GetPhysicalDeviceGroups = library.GetPhysicalDeviceGroups,
		Destroy = library.DestroyInstance,
		GetPhysicalDevices = library.GetPhysicalDevices,
		LoadProcAddr = library.util.LoadInstanceProcAddr,
		DestroyDebugReportCallback = library.DestroyDebugReportCallback,
		GetProcAddr = library.GetInstanceProcAddr,
		CreateDebugReportCallback = library.CreateDebugReportCallback,
		DebugReportMessage = library.DebugReportMessage,
	}
	META.__index = META
	ffi.metatype("struct VkInstance_T", META)
end
do
	local META = {
		BindIndexBuffer = library.CmdBindIndexBuffer,
		CopyBufferToImage = library.CmdCopyBufferToImage,
		DrawIndirectCount = library.CmdDrawIndirectCount,
		DrawIndexedIndirect = library.CmdDrawIndexedIndirect,
		SetBlendConstants = library.CmdSetBlendConstants,
		CopyBuffer = library.CmdCopyBuffer,
		BindPipeline = library.CmdBindPipeline,
		SetDepthBounds = library.CmdSetDepthBounds,
		DebugMarkerEnd = library.CmdDebugMarkerEnd,
		PushConstants = library.CmdPushConstants,
		DispatchIndirect = library.CmdDispatchIndirect,
		SetScissor = library.CmdSetScissor,
		FillBuffer = library.CmdFillBuffer,
		ClearColorImage = library.CmdClearColorImage,
		PushDescriptorSet = library.CmdPushDescriptorSet,
		DebugMarkerInsert = library.CmdDebugMarkerInsert,
		BindDescriptorSets = library.CmdBindDescriptorSets,
		ResolveImage = library.CmdResolveImage,
		SetViewportWScalin = library.CmdSetViewportWScalin,
		WriteTimestamp = library.CmdWriteTimestamp,
		EndQuery = library.CmdEndQuery,
		BindVertexBuffers = library.CmdBindVertexBuffers,
		SetStencilReference = library.CmdSetStencilReference,
		ProcessCommands = library.CmdProcessCommands,
		DrawIndirect = library.CmdDrawIndirect,
		SetViewport = library.CmdSetViewport,
		End = library.EndCommandBuffer,
		ClearAttachments = library.CmdClearAttachments,
		SetDepthBias = library.CmdSetDepthBias,
		BeginRenderPass = library.CmdBeginRenderPass,
		WaitEvents = library.CmdWaitEvents,
		DrawIndexedIndirectCount = library.CmdDrawIndexedIndirectCount,
		ResetEvent = library.CmdResetEvent,
		PushDescriptorSetWithTemplate = library.CmdPushDescriptorSetWithTemplate,
		ReserveSpaceForCommands = library.CmdReserveSpaceForCommands,
		CopyQueryPoolResults = library.CmdCopyQueryPoolResults,
		SetEvent = library.CmdSetEvent,
		Draw = library.CmdDraw,
		SetStencilWriteMask = library.CmdSetStencilWriteMask,
		BlitImage = library.CmdBlitImage,
		CopyImageToBuffer = library.CmdCopyImageToBuffer,
		Dispatch = library.CmdDispatch,
		SetDiscardRectangle = library.CmdSetDiscardRectangle,
		SetDeviceMask = library.CmdSetDeviceMask,
		SetLineWidth = library.CmdSetLineWidth,
		UpdateBuffer = library.CmdUpdateBuffer,
		ClearDepthStencilImage = library.CmdClearDepthStencilImage,
		DispatchBase = library.CmdDispatchBase,
		Reset = library.ResetCommandBuffer,
		DrawIndexed = library.CmdDrawIndexed,
		SetStencilCompareMask = library.CmdSetStencilCompareMask,
		ExecuteCommands = library.CmdExecuteCommands,
		EndRenderPass = library.CmdEndRenderPass,
		ResetQueryPool = library.CmdResetQueryPool,
		CopyImage = library.CmdCopyImage,
		NextSubpass = library.CmdNextSubpass,
		DebugMarkerBegin = library.CmdDebugMarkerBegin,
		BeginQuery = library.CmdBeginQuery,
		PipelineBarrier = library.CmdPipelineBarrier,
		Begin = library.BeginCommandBuffer,
	}
	META.__index = META
	ffi.metatype("struct VkCommandBuffer_T", META)
end
library.clib = CLIB
return library
