local ffi = require("ffi")
local CLIB = assert(ffi.load("vulkan"))
ffi.cdef([[typedef enum VkDynamicState{VK_DYNAMIC_STATE_VIEWPORT=0,VK_DYNAMIC_STATE_SCISSOR=1,VK_DYNAMIC_STATE_LINE_WIDTH=2,VK_DYNAMIC_STATE_DEPTH_BIAS=3,VK_DYNAMIC_STATE_BLEND_CONSTANTS=4,VK_DYNAMIC_STATE_DEPTH_BOUNDS=5,VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK=6,VK_DYNAMIC_STATE_STENCIL_WRITE_MASK=7,VK_DYNAMIC_STATE_STENCIL_REFERENCE=8,VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV=1000087000,VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT=1000099000,VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT=1000143000,VK_DYNAMIC_STATE_BEGIN_RANGE=0,VK_DYNAMIC_STATE_END_RANGE=8,VK_DYNAMIC_STATE_RANGE_SIZE=9,VK_DYNAMIC_STATE_MAX_ENUM=2147483647};
typedef enum VkObjectType{VK_OBJECT_TYPE_UNKNOWN=0,VK_OBJECT_TYPE_INSTANCE=1,VK_OBJECT_TYPE_PHYSICAL_DEVICE=2,VK_OBJECT_TYPE_DEVICE=3,VK_OBJECT_TYPE_QUEUE=4,VK_OBJECT_TYPE_SEMAPHORE=5,VK_OBJECT_TYPE_COMMAND_BUFFER=6,VK_OBJECT_TYPE_FENCE=7,VK_OBJECT_TYPE_DEVICE_MEMORY=8,VK_OBJECT_TYPE_BUFFER=9,VK_OBJECT_TYPE_IMAGE=10,VK_OBJECT_TYPE_EVENT=11,VK_OBJECT_TYPE_QUERY_POOL=12,VK_OBJECT_TYPE_BUFFER_VIEW=13,VK_OBJECT_TYPE_IMAGE_VIEW=14,VK_OBJECT_TYPE_SHADER_MODULE=15,VK_OBJECT_TYPE_PIPELINE_CACHE=16,VK_OBJECT_TYPE_PIPELINE_LAYOUT=17,VK_OBJECT_TYPE_RENDER_PASS=18,VK_OBJECT_TYPE_PIPELINE=19,VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT=20,VK_OBJECT_TYPE_SAMPLER=21,VK_OBJECT_TYPE_DESCRIPTOR_POOL=22,VK_OBJECT_TYPE_DESCRIPTOR_SET=23,VK_OBJECT_TYPE_FRAMEBUFFER=24,VK_OBJECT_TYPE_COMMAND_POOL=25,VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION=1000156000,VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE=1000085000,VK_OBJECT_TYPE_SURFACE_KHR=1000000000,VK_OBJECT_TYPE_SWAPCHAIN_KHR=1000001000,VK_OBJECT_TYPE_DISPLAY_KHR=1000002000,VK_OBJECT_TYPE_DISPLAY_MODE_KHR=1000002001,VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT=1000011000,VK_OBJECT_TYPE_OBJECT_TABLE_NVX=1000086000,VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX=1000086001,VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT=1000128000,VK_OBJECT_TYPE_VALIDATION_CACHE_EXT=1000160000,VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR=1000085000,VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR=1000156000,VK_OBJECT_TYPE_BEGIN_RANGE=0,VK_OBJECT_TYPE_END_RANGE=25,VK_OBJECT_TYPE_RANGE_SIZE=26,VK_OBJECT_TYPE_MAX_ENUM=2147483647};
typedef enum VkImageLayout{VK_IMAGE_LAYOUT_UNDEFINED=0,VK_IMAGE_LAYOUT_GENERAL=1,VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL=2,VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL=3,VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL=4,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL=5,VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL=6,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL=7,VK_IMAGE_LAYOUT_PREINITIALIZED=8,VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL=1000117000,VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL=1000117001,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR=1000001002,VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR=1000111000,VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR=1000117000,VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR=1000117001,VK_IMAGE_LAYOUT_BEGIN_RANGE=0,VK_IMAGE_LAYOUT_END_RANGE=8,VK_IMAGE_LAYOUT_RANGE_SIZE=9,VK_IMAGE_LAYOUT_MAX_ENUM=2147483647};
typedef enum VkSamplerMipmapMode{VK_SAMPLER_MIPMAP_MODE_NEAREST=0,VK_SAMPLER_MIPMAP_MODE_LINEAR=1,VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE=0,VK_SAMPLER_MIPMAP_MODE_END_RANGE=1,VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE=2,VK_SAMPLER_MIPMAP_MODE_MAX_ENUM=2147483647};
typedef enum VkIndexType{VK_INDEX_TYPE_UINT16=0,VK_INDEX_TYPE_UINT32=1,VK_INDEX_TYPE_BEGIN_RANGE=0,VK_INDEX_TYPE_END_RANGE=1,VK_INDEX_TYPE_RANGE_SIZE=2,VK_INDEX_TYPE_MAX_ENUM=2147483647};
typedef enum VkCullModeFlagBits{VK_CULL_MODE_NONE=0,VK_CULL_MODE_FRONT_BIT=1,VK_CULL_MODE_BACK_BIT=2,VK_CULL_MODE_FRONT_AND_BACK=3,VK_CULL_MODE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkObjectEntryTypeNVX{VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX=0,VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX=1,VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX=2,VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX=3,VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX=4,VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX=0,VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX=4,VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX=5,VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX=2147483647};
typedef enum VkPipelineStageFlagBits{VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT=1,VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT=2,VK_PIPELINE_STAGE_VERTEX_INPUT_BIT=4,VK_PIPELINE_STAGE_VERTEX_SHADER_BIT=8,VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT=16,VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT=32,VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT=64,VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT=128,VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT=256,VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT=512,VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT=1024,VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT=2048,VK_PIPELINE_STAGE_TRANSFER_BIT=4096,VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT=8192,VK_PIPELINE_STAGE_HOST_BIT=16384,VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT=32768,VK_PIPELINE_STAGE_ALL_COMMANDS_BIT=65536,VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX=131072,VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageUsageFlagBits{VK_IMAGE_USAGE_TRANSFER_SRC_BIT=1,VK_IMAGE_USAGE_TRANSFER_DST_BIT=2,VK_IMAGE_USAGE_SAMPLED_BIT=4,VK_IMAGE_USAGE_STORAGE_BIT=8,VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT=16,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT=32,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT=64,VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT=128,VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolCreateFlagBits{VK_COMMAND_POOL_CREATE_TRANSIENT_BIT=1,VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT=2,VK_COMMAND_POOL_CREATE_PROTECTED_BIT=4,VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkTessellationDomainOrigin{VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT=0,VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT=1,VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR=0,VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR=1,VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE=0,VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE=1,VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE=2,VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM=2147483647};
typedef enum VkQueueGlobalPriorityEXT{VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT=128,VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT=256,VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT=512,VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT=1024,VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT=128,VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT=1024,VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT=897,VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT=2147483647};
typedef enum VkDeviceGroupPresentModeFlagBitsKHR{VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR=1,VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR=2,VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR=4,VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR=8,VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkDependencyFlagBits{VK_DEPENDENCY_BY_REGION_BIT=1,VK_DEPENDENCY_DEVICE_GROUP_BIT=4,VK_DEPENDENCY_VIEW_LOCAL_BIT=2,VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR=2,VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR=4,VK_DEPENDENCY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSystemAllocationScope{VK_SYSTEM_ALLOCATION_SCOPE_COMMAND=0,VK_SYSTEM_ALLOCATION_SCOPE_OBJECT=1,VK_SYSTEM_ALLOCATION_SCOPE_CACHE=2,VK_SYSTEM_ALLOCATION_SCOPE_DEVICE=3,VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE=4,VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE=0,VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE=4,VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE=5,VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM=2147483647};
typedef enum VkSurfaceCounterFlagBitsEXT{VK_SURFACE_COUNTER_VBLANK_EXT=1,VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkFilter{VK_FILTER_NEAREST=0,VK_FILTER_LINEAR=1,VK_FILTER_CUBIC_IMG=1000015000,VK_FILTER_BEGIN_RANGE=0,VK_FILTER_END_RANGE=1,VK_FILTER_RANGE_SIZE=2,VK_FILTER_MAX_ENUM=2147483647};
typedef enum VkDescriptorUpdateTemplateType{VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR=1,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE=0,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE=1,VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM=2147483647};
typedef enum VkBufferUsageFlagBits{VK_BUFFER_USAGE_TRANSFER_SRC_BIT=1,VK_BUFFER_USAGE_TRANSFER_DST_BIT=2,VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT=4,VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT=8,VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT=16,VK_BUFFER_USAGE_STORAGE_BUFFER_BIT=32,VK_BUFFER_USAGE_INDEX_BUFFER_BIT=64,VK_BUFFER_USAGE_VERTEX_BUFFER_BIT=128,VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT=256,VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkFenceImportFlagBits{VK_FENCE_IMPORT_TEMPORARY_BIT=1,VK_FENCE_IMPORT_TEMPORARY_BIT_KHR=1,VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDisplayPlaneAlphaFlagBitsKHR{VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR=1,VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR=2,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR=4,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR=8,VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkPipelineCreateFlagBits{VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT=1,VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT=2,VK_PIPELINE_CREATE_DERIVATIVE_BIT=4,VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT=8,VK_PIPELINE_CREATE_DISPATCH_BASE=16,VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR=8,VK_PIPELINE_CREATE_DISPATCH_BASE_KHR=16,VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCoverageModulationModeNV{VK_COVERAGE_MODULATION_MODE_NONE_NV=0,VK_COVERAGE_MODULATION_MODE_RGB_NV=1,VK_COVERAGE_MODULATION_MODE_ALPHA_NV=2,VK_COVERAGE_MODULATION_MODE_RGBA_NV=3,VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV=0,VK_COVERAGE_MODULATION_MODE_END_RANGE_NV=3,VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV=4,VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV=2147483647};
typedef enum VkExternalFenceHandleTypeFlagBits{VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT=1,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT=2,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT=4,VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT=8,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR=8,VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageViewType{VK_IMAGE_VIEW_TYPE_1D=0,VK_IMAGE_VIEW_TYPE_2D=1,VK_IMAGE_VIEW_TYPE_3D=2,VK_IMAGE_VIEW_TYPE_CUBE=3,VK_IMAGE_VIEW_TYPE_1D_ARRAY=4,VK_IMAGE_VIEW_TYPE_2D_ARRAY=5,VK_IMAGE_VIEW_TYPE_CUBE_ARRAY=6,VK_IMAGE_VIEW_TYPE_BEGIN_RANGE=0,VK_IMAGE_VIEW_TYPE_END_RANGE=6,VK_IMAGE_VIEW_TYPE_RANGE_SIZE=7,VK_IMAGE_VIEW_TYPE_MAX_ENUM=2147483647};
typedef enum VkQueryControlFlagBits{VK_QUERY_CONTROL_PRECISE_BIT=1,VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkAttachmentDescriptionFlagBits{VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT=1,VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPipelineCacheHeaderVersion{VK_PIPELINE_CACHE_HEADER_VERSION_ONE=1,VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE=1,VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM=2147483647};
typedef enum VkDebugReportFlagBitsEXT{VK_DEBUG_REPORT_INFORMATION_BIT_EXT=1,VK_DEBUG_REPORT_WARNING_BIT_EXT=2,VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT=4,VK_DEBUG_REPORT_ERROR_BIT_EXT=8,VK_DEBUG_REPORT_DEBUG_BIT_EXT=16,VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkPrimitiveTopology{VK_PRIMITIVE_TOPOLOGY_POINT_LIST=0,VK_PRIMITIVE_TOPOLOGY_LINE_LIST=1,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP=2,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST=3,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP=4,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN=5,VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY=6,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY=7,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY=8,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY=9,VK_PRIMITIVE_TOPOLOGY_PATCH_LIST=10,VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE=0,VK_PRIMITIVE_TOPOLOGY_END_RANGE=10,VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE=11,VK_PRIMITIVE_TOPOLOGY_MAX_ENUM=2147483647};
typedef enum VkDescriptorBindingFlagBitsEXT{VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT=1,VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT=2,VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT=4,VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT=8,VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkValidationCacheHeaderVersionEXT{VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT=1,VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT=1,VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT=1,VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT=1,VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT=2147483647};
typedef enum VkDescriptorSetLayoutCreateFlagBits{VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR=1,VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT=2,VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkConservativeRasterizationModeEXT{VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT=0,VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT=1,VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT=2,VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT=0,VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT=2,VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT=3,VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT=2147483647};
typedef enum VkDisplayPowerStateEXT{VK_DISPLAY_POWER_STATE_OFF_EXT=0,VK_DISPLAY_POWER_STATE_SUSPEND_EXT=1,VK_DISPLAY_POWER_STATE_ON_EXT=2,VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT=0,VK_DISPLAY_POWER_STATE_END_RANGE_EXT=2,VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT=3,VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT=2147483647};
typedef enum VkSamplerYcbcrRange{VK_SAMPLER_YCBCR_RANGE_ITU_FULL=0,VK_SAMPLER_YCBCR_RANGE_ITU_NARROW=1,VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR=0,VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR=1,VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE=0,VK_SAMPLER_YCBCR_RANGE_END_RANGE=1,VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE=2,VK_SAMPLER_YCBCR_RANGE_MAX_ENUM=2147483647};
typedef enum VkDescriptorPoolCreateFlagBits{VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT=1,VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT=2,VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSurfaceTransformFlagBitsKHR{VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR=1,VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR=2,VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR=4,VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR=8,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR=16,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR=32,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR=64,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR=128,VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR=256,VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkDebugUtilsMessageTypeFlagBitsEXT{VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT=1,VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT=2,VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT=4,VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkDebugUtilsMessageSeverityFlagBitsEXT{VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT=1,VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT=16,VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT=256,VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT=4096,VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkCompareOp{VK_COMPARE_OP_NEVER=0,VK_COMPARE_OP_LESS=1,VK_COMPARE_OP_EQUAL=2,VK_COMPARE_OP_LESS_OR_EQUAL=3,VK_COMPARE_OP_GREATER=4,VK_COMPARE_OP_NOT_EQUAL=5,VK_COMPARE_OP_GREATER_OR_EQUAL=6,VK_COMPARE_OP_ALWAYS=7,VK_COMPARE_OP_BEGIN_RANGE=0,VK_COMPARE_OP_END_RANGE=7,VK_COMPARE_OP_RANGE_SIZE=8,VK_COMPARE_OP_MAX_ENUM=2147483647};
typedef enum VkShaderStageFlagBits{VK_SHADER_STAGE_VERTEX_BIT=1,VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT=2,VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT=4,VK_SHADER_STAGE_GEOMETRY_BIT=8,VK_SHADER_STAGE_FRAGMENT_BIT=16,VK_SHADER_STAGE_COMPUTE_BIT=32,VK_SHADER_STAGE_ALL_GRAPHICS=31,VK_SHADER_STAGE_ALL=2147483647,VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSubpassDescriptionFlagBits{VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX=1,VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX=2,VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSubgroupFeatureFlagBits{VK_SUBGROUP_FEATURE_BASIC_BIT=1,VK_SUBGROUP_FEATURE_VOTE_BIT=2,VK_SUBGROUP_FEATURE_ARITHMETIC_BIT=4,VK_SUBGROUP_FEATURE_BALLOT_BIT=8,VK_SUBGROUP_FEATURE_SHUFFLE_BIT=16,VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT=32,VK_SUBGROUP_FEATURE_CLUSTERED_BIT=64,VK_SUBGROUP_FEATURE_QUAD_BIT=128,VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV=256,VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkResult{VK_SUCCESS=0,VK_NOT_READY=1,VK_TIMEOUT=2,VK_EVENT_SET=3,VK_EVENT_RESET=4,VK_INCOMPLETE=5,VK_ERROR_OUT_OF_HOST_MEMORY=-1,VK_ERROR_OUT_OF_DEVICE_MEMORY=-2,VK_ERROR_INITIALIZATION_FAILED=-3,VK_ERROR_DEVICE_LOST=-4,VK_ERROR_MEMORY_MAP_FAILED=-5,VK_ERROR_LAYER_NOT_PRESENT=-6,VK_ERROR_EXTENSION_NOT_PRESENT=-7,VK_ERROR_FEATURE_NOT_PRESENT=-8,VK_ERROR_INCOMPATIBLE_DRIVER=-9,VK_ERROR_TOO_MANY_OBJECTS=-10,VK_ERROR_FORMAT_NOT_SUPPORTED=-11,VK_ERROR_FRAGMENTED_POOL=-12,VK_ERROR_OUT_OF_POOL_MEMORY=-1000069000,VK_ERROR_INVALID_EXTERNAL_HANDLE=-1000072003,VK_ERROR_SURFACE_LOST_KHR=-1000000000,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR=-1000000001,VK_SUBOPTIMAL_KHR=1000001003,VK_ERROR_OUT_OF_DATE_KHR=-1000001004,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR=-1000003001,VK_ERROR_VALIDATION_FAILED_EXT=-1000011001,VK_ERROR_INVALID_SHADER_NV=-1000012000,VK_ERROR_FRAGMENTATION_EXT=-1000161000,VK_ERROR_NOT_PERMITTED_EXT=-1000174001,VK_ERROR_OUT_OF_POOL_MEMORY_KHR=-1000069000,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR=-1000072003,VK_RESULT_BEGIN_RANGE=-12,VK_RESULT_END_RANGE=5,VK_RESULT_RANGE_SIZE=18,VK_RESULT_MAX_ENUM=2147483647};
typedef enum VkPeerMemoryFeatureFlagBits{VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT=1,VK_PEER_MEMORY_FEATURE_COPY_DST_BIT=2,VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT=4,VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT=8,VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR=1,VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR=2,VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR=4,VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR=8,VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkFenceCreateFlagBits{VK_FENCE_CREATE_SIGNALED_BIT=1,VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageCreateFlagBits{VK_IMAGE_CREATE_SPARSE_BINDING_BIT=1,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT=2,VK_IMAGE_CREATE_SPARSE_ALIASED_BIT=4,VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT=8,VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT=16,VK_IMAGE_CREATE_ALIAS_BIT=1024,VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT=64,VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT=32,VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT=128,VK_IMAGE_CREATE_EXTENDED_USAGE_BIT=256,VK_IMAGE_CREATE_PROTECTED_BIT=2048,VK_IMAGE_CREATE_DISJOINT_BIT=512,VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT=4096,VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR=64,VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR=32,VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR=128,VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR=256,VK_IMAGE_CREATE_DISJOINT_BIT_KHR=512,VK_IMAGE_CREATE_ALIAS_BIT_KHR=1024,VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSampleCountFlagBits{VK_SAMPLE_COUNT_1_BIT=1,VK_SAMPLE_COUNT_2_BIT=2,VK_SAMPLE_COUNT_4_BIT=4,VK_SAMPLE_COUNT_8_BIT=8,VK_SAMPLE_COUNT_16_BIT=16,VK_SAMPLE_COUNT_32_BIT=32,VK_SAMPLE_COUNT_64_BIT=64,VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalFenceFeatureFlagBits{VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT=1,VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT=2,VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR=1,VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR=2,VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkQueryResultFlagBits{VK_QUERY_RESULT_64_BIT=1,VK_QUERY_RESULT_WAIT_BIT=2,VK_QUERY_RESULT_WITH_AVAILABILITY_BIT=4,VK_QUERY_RESULT_PARTIAL_BIT=8,VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkQueryType{VK_QUERY_TYPE_OCCLUSION=0,VK_QUERY_TYPE_PIPELINE_STATISTICS=1,VK_QUERY_TYPE_TIMESTAMP=2,VK_QUERY_TYPE_BEGIN_RANGE=0,VK_QUERY_TYPE_END_RANGE=2,VK_QUERY_TYPE_RANGE_SIZE=3,VK_QUERY_TYPE_MAX_ENUM=2147483647};
typedef enum VkDisplayEventTypeEXT{VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT=0,VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT=0,VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT=0,VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT=1,VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkPresentModeKHR{VK_PRESENT_MODE_IMMEDIATE_KHR=0,VK_PRESENT_MODE_MAILBOX_KHR=1,VK_PRESENT_MODE_FIFO_KHR=2,VK_PRESENT_MODE_FIFO_RELAXED_KHR=3,VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR=1000111000,VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR=1000111001,VK_PRESENT_MODE_BEGIN_RANGE_KHR=0,VK_PRESENT_MODE_END_RANGE_KHR=3,VK_PRESENT_MODE_RANGE_SIZE_KHR=4,VK_PRESENT_MODE_MAX_ENUM_KHR=2147483647};
typedef enum VkBufferCreateFlagBits{VK_BUFFER_CREATE_SPARSE_BINDING_BIT=1,VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT=2,VK_BUFFER_CREATE_SPARSE_ALIASED_BIT=4,VK_BUFFER_CREATE_PROTECTED_BIT=8,VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkAccessFlagBits{VK_ACCESS_INDIRECT_COMMAND_READ_BIT=1,VK_ACCESS_INDEX_READ_BIT=2,VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT=4,VK_ACCESS_UNIFORM_READ_BIT=8,VK_ACCESS_INPUT_ATTACHMENT_READ_BIT=16,VK_ACCESS_SHADER_READ_BIT=32,VK_ACCESS_SHADER_WRITE_BIT=64,VK_ACCESS_COLOR_ATTACHMENT_READ_BIT=128,VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT=256,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT=512,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT=1024,VK_ACCESS_TRANSFER_READ_BIT=2048,VK_ACCESS_TRANSFER_WRITE_BIT=4096,VK_ACCESS_HOST_READ_BIT=8192,VK_ACCESS_HOST_WRITE_BIT=16384,VK_ACCESS_MEMORY_READ_BIT=32768,VK_ACCESS_MEMORY_WRITE_BIT=65536,VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX=131072,VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX=262144,VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT=524288,VK_ACCESS_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalSemaphoreFeatureFlagBits{VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT=1,VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT=2,VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR=1,VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR=2,VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkIndirectCommandsLayoutUsageFlagBitsNVX{VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX=1,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX=2,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX=4,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX=8,VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX=2147483647};
typedef enum VkFormatFeatureFlagBits{VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT=1,VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT=2,VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT=4,VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT=8,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT=16,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT=32,VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT=64,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT=128,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT=256,VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT=512,VK_FORMAT_FEATURE_BLIT_SRC_BIT=1024,VK_FORMAT_FEATURE_BLIT_DST_BIT=2048,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT=4096,VK_FORMAT_FEATURE_TRANSFER_SRC_BIT=16384,VK_FORMAT_FEATURE_TRANSFER_DST_BIT=32768,VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT=131072,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT=262144,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT=524288,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT=1048576,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT=2097152,VK_FORMAT_FEATURE_DISJOINT_BIT=4194304,VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT=8388608,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG=8192,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT=65536,VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR=16384,VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR=32768,VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR=131072,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR=262144,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR=524288,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR=1048576,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR=2097152,VK_FORMAT_FEATURE_DISJOINT_BIT_KHR=4194304,VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR=8388608,VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryHandleTypeFlagBits{VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT=16,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT=32,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT=64,VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT=512,VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID=1024,VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT=128,VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT=256,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR=16,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR=32,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR=64,VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolResetFlagBits{VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkMemoryHeapFlagBits{VK_MEMORY_HEAP_DEVICE_LOCAL_BIT=1,VK_MEMORY_HEAP_MULTI_INSTANCE_BIT=2,VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR=2,VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkObjectEntryUsageFlagBitsNVX{VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX=1,VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX=2,VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX=2147483647};
typedef enum VkIndirectCommandsTokenTypeNVX{VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX=0,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX=1,VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX=2,VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX=3,VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX=4,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX=5,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX=6,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX=7,VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX=0,VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX=7,VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX=8,VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX=2147483647};
typedef enum VkSamplerYcbcrModelConversion{VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY=0,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY=1,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709=2,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601=3,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020=4,VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR=0,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR=1,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR=2,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR=3,VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR=4,VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE=0,VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE=4,VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE=5,VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM=2147483647};
typedef enum VkDeviceQueueCreateFlagBits{VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT=1,VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkStructureType{VK_STRUCTURE_TYPE_APPLICATION_INFO=0,VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO=1,VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO=2,VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO=3,VK_STRUCTURE_TYPE_SUBMIT_INFO=4,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO=5,VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE=6,VK_STRUCTURE_TYPE_BIND_SPARSE_INFO=7,VK_STRUCTURE_TYPE_FENCE_CREATE_INFO=8,VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO=9,VK_STRUCTURE_TYPE_EVENT_CREATE_INFO=10,VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO=11,VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO=12,VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO=13,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO=14,VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO=15,VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO=16,VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO=17,VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO=18,VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO=19,VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO=20,VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO=21,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO=22,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO=23,VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO=24,VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO=25,VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO=26,VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO=27,VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO=28,VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO=29,VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO=30,VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO=31,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO=32,VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO=33,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO=34,VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET=35,VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET=36,VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO=37,VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO=38,VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO=39,VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO=40,VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO=41,VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO=42,VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO=43,VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER=44,VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER=45,VK_STRUCTURE_TYPE_MEMORY_BARRIER=46,VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO=47,VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO=48,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES=1000094000,VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO=1000157000,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO=1000157001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES=1000083000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS=1000127000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO=1000127001,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO=1000060000,VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO=1000060003,VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO=1000060004,VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO=1000060005,VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO=1000060006,VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO=1000060013,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO=1000060014,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES=1000070000,VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO=1000070001,VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2=1000146000,VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2=1000146001,VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2=1000146002,VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2=1000146003,VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2=1000146004,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2=1000059000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2=1000059001,VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2=1000059002,VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2=1000059003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2=1000059004,VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2=1000059005,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2=1000059006,VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2=1000059007,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2=1000059008,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES=1000117000,VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO=1000117001,VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO=1000117002,VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO=1000117003,VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO=1000053000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES=1000053001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES=1000053002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES=1000120000,VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO=1000145000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES=1000145001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES=1000145002,VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2=1000145003,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO=1000156000,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO=1000156001,VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO=1000156002,VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO=1000156003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES=1000156004,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES=1000156005,VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO=1000085000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO=1000071000,VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES=1000071001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO=1000071002,VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES=1000071003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES=1000071004,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO=1000072000,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO=1000072001,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO=1000072002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO=1000112000,VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES=1000112001,VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO=1000113000,VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO=1000077000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO=1000076000,VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES=1000076001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES=1000168000,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT=1000168001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES=1000063000,VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR=1000001000,VK_STRUCTURE_TYPE_PRESENT_INFO_KHR=1000001001,VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR=1000060007,VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR=1000060008,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR=1000060009,VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR=1000060010,VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR=1000060011,VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR=1000060012,VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR=1000002000,VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR=1000002001,VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR=1000003000,VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR=1000004000,VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR=1000005000,VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR=1000006000,VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR=1000007000,VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR=1000008000,VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR=1000009000,VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT=1000011000,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD=1000018000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT=1000022000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT=1000022001,VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT=1000022002,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV=1000026000,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV=1000026001,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV=1000026002,VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD=1000041000,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV=1000056000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV=1000056001,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057001,VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV=1000058000,VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT=1000061000,VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN=1000062000,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR=1000073000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR=1000073001,VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR=1000073002,VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR=1000073003,VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR=1000074000,VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR=1000074001,VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR=1000074002,VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR=1000075000,VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR=1000078000,VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR=1000078001,VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR=1000078002,VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR=1000078003,VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR=1000079000,VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR=1000079001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR=1000080000,VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR=1000084000,VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX=1000086000,VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX=1000086001,VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX=1000086002,VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX=1000086003,VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX=1000086004,VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX=1000086005,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV=1000087000,VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT=1000090000,VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT=1000091000,VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT=1000091001,VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT=1000091002,VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT=1000091003,VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE=1000092000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX=1000097000,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV=1000098000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT=1000099000,VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT=1000099001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT=1000101000,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT=1000101001,VK_STRUCTURE_TYPE_HDR_METADATA_EXT=1000105000,VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR=1000111000,VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR=1000114000,VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR=1000114001,VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR=1000114002,VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR=1000115000,VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR=1000115001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR=1000119000,VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR=1000119001,VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR=1000119002,VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK=1000122000,VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK=1000123000,VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT=1000128000,VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT=1000128001,VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT=1000128002,VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT=1000128003,VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT=1000128004,VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID=1000129000,VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID=1000129001,VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID=1000129002,VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID=1000129003,VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID=1000129004,VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID=1000129005,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT=1000130000,VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT=1000130001,VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT=1000143000,VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT=1000143001,VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT=1000143002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT=1000143003,VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT=1000143004,VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR=1000147000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT=1000148000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT=1000148001,VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT=1000148002,VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV=1000149000,VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV=1000152000,VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT=1000160000,VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT=1000160001,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT=1000161000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT=1000161001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT=1000161002,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT=1000161003,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT=1000161004,VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT=1000174000,VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT=1000178000,VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT=1000178001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT=1000178002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD=1000185000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT=1000190000,VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT=1000190001,VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR=1000053000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR=1000053001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR=1000053002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR=1000059000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR=1000059001,VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR=1000059002,VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR=1000059003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR=1000059004,VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR=1000059005,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR=1000059006,VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR=1000059007,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR=1000059008,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR=1000060000,VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR=1000060003,VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR=1000060004,VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR=1000060005,VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR=1000060006,VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR=1000060013,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR=1000060014,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR=1000070000,VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR=1000070001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR=1000071000,VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR=1000071001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR=1000071002,VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR=1000071003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR=1000071004,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR=1000072000,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR=1000072001,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR=1000072002,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR=1000076000,VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR=1000076001,VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR=1000077000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR=1000083000,VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR=1000085000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR=1000112000,VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR=1000112001,VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR=1000113000,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR=1000117000,VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR=1000117001,VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR=1000117002,VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR=1000117003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR=1000120000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR=1000127000,VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR=1000127001,VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146000,VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146001,VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR=1000146002,VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR=1000146003,VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR=1000146004,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR=1000156000,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR=1000156001,VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR=1000156002,VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR=1000156003,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR=1000156004,VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR=1000156005,VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR=1000157000,VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR=1000157001,VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR=1000168000,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR=1000168001,VK_STRUCTURE_TYPE_BEGIN_RANGE=0,VK_STRUCTURE_TYPE_END_RANGE=48,VK_STRUCTURE_TYPE_RANGE_SIZE=49,VK_STRUCTURE_TYPE_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryFeatureFlagBitsNV{VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV=4,VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkVertexInputRate{VK_VERTEX_INPUT_RATE_VERTEX=0,VK_VERTEX_INPUT_RATE_INSTANCE=1,VK_VERTEX_INPUT_RATE_BEGIN_RANGE=0,VK_VERTEX_INPUT_RATE_END_RANGE=1,VK_VERTEX_INPUT_RATE_RANGE_SIZE=2,VK_VERTEX_INPUT_RATE_MAX_ENUM=2147483647};
typedef enum VkChromaLocation{VK_CHROMA_LOCATION_COSITED_EVEN=0,VK_CHROMA_LOCATION_MIDPOINT=1,VK_CHROMA_LOCATION_COSITED_EVEN_KHR=0,VK_CHROMA_LOCATION_MIDPOINT_KHR=1,VK_CHROMA_LOCATION_BEGIN_RANGE=0,VK_CHROMA_LOCATION_END_RANGE=1,VK_CHROMA_LOCATION_RANGE_SIZE=2,VK_CHROMA_LOCATION_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryHandleTypeFlagBitsNV{VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkShaderInfoTypeAMD{VK_SHADER_INFO_TYPE_STATISTICS_AMD=0,VK_SHADER_INFO_TYPE_BINARY_AMD=1,VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD=2,VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD=0,VK_SHADER_INFO_TYPE_END_RANGE_AMD=2,VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD=3,VK_SHADER_INFO_TYPE_MAX_ENUM_AMD=2147483647};
typedef enum VkRasterizationOrderAMD{VK_RASTERIZATION_ORDER_STRICT_AMD=0,VK_RASTERIZATION_ORDER_RELAXED_AMD=1,VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD=0,VK_RASTERIZATION_ORDER_END_RANGE_AMD=1,VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD=2,VK_RASTERIZATION_ORDER_MAX_ENUM_AMD=2147483647};
typedef enum VkImageTiling{VK_IMAGE_TILING_OPTIMAL=0,VK_IMAGE_TILING_LINEAR=1,VK_IMAGE_TILING_BEGIN_RANGE=0,VK_IMAGE_TILING_END_RANGE=1,VK_IMAGE_TILING_RANGE_SIZE=2,VK_IMAGE_TILING_MAX_ENUM=2147483647};
typedef enum VkDebugReportObjectTypeEXT{VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT=1,VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT=2,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT=3,VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT=4,VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT=5,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT=6,VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT=7,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT=8,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT=9,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT=10,VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT=11,VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT=12,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT=13,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT=14,VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT=15,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT=16,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT=17,VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT=18,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT=19,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT=20,VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT=21,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT=22,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT=23,VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT=24,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT=25,VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT=26,VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT=27,VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT=28,VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT=29,VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT=30,VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT=31,VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT=32,VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT=33,VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT=1000156000,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT=1000085000,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT=1000085000,VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT=1000156000,VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT=33,VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT=34,VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkFormat{VK_FORMAT_UNDEFINED=0,VK_FORMAT_R4G4_UNORM_PACK8=1,VK_FORMAT_R4G4B4A4_UNORM_PACK16=2,VK_FORMAT_B4G4R4A4_UNORM_PACK16=3,VK_FORMAT_R5G6B5_UNORM_PACK16=4,VK_FORMAT_B5G6R5_UNORM_PACK16=5,VK_FORMAT_R5G5B5A1_UNORM_PACK16=6,VK_FORMAT_B5G5R5A1_UNORM_PACK16=7,VK_FORMAT_A1R5G5B5_UNORM_PACK16=8,VK_FORMAT_R8_UNORM=9,VK_FORMAT_R8_SNORM=10,VK_FORMAT_R8_USCALED=11,VK_FORMAT_R8_SSCALED=12,VK_FORMAT_R8_UINT=13,VK_FORMAT_R8_SINT=14,VK_FORMAT_R8_SRGB=15,VK_FORMAT_R8G8_UNORM=16,VK_FORMAT_R8G8_SNORM=17,VK_FORMAT_R8G8_USCALED=18,VK_FORMAT_R8G8_SSCALED=19,VK_FORMAT_R8G8_UINT=20,VK_FORMAT_R8G8_SINT=21,VK_FORMAT_R8G8_SRGB=22,VK_FORMAT_R8G8B8_UNORM=23,VK_FORMAT_R8G8B8_SNORM=24,VK_FORMAT_R8G8B8_USCALED=25,VK_FORMAT_R8G8B8_SSCALED=26,VK_FORMAT_R8G8B8_UINT=27,VK_FORMAT_R8G8B8_SINT=28,VK_FORMAT_R8G8B8_SRGB=29,VK_FORMAT_B8G8R8_UNORM=30,VK_FORMAT_B8G8R8_SNORM=31,VK_FORMAT_B8G8R8_USCALED=32,VK_FORMAT_B8G8R8_SSCALED=33,VK_FORMAT_B8G8R8_UINT=34,VK_FORMAT_B8G8R8_SINT=35,VK_FORMAT_B8G8R8_SRGB=36,VK_FORMAT_R8G8B8A8_UNORM=37,VK_FORMAT_R8G8B8A8_SNORM=38,VK_FORMAT_R8G8B8A8_USCALED=39,VK_FORMAT_R8G8B8A8_SSCALED=40,VK_FORMAT_R8G8B8A8_UINT=41,VK_FORMAT_R8G8B8A8_SINT=42,VK_FORMAT_R8G8B8A8_SRGB=43,VK_FORMAT_B8G8R8A8_UNORM=44,VK_FORMAT_B8G8R8A8_SNORM=45,VK_FORMAT_B8G8R8A8_USCALED=46,VK_FORMAT_B8G8R8A8_SSCALED=47,VK_FORMAT_B8G8R8A8_UINT=48,VK_FORMAT_B8G8R8A8_SINT=49,VK_FORMAT_B8G8R8A8_SRGB=50,VK_FORMAT_A8B8G8R8_UNORM_PACK32=51,VK_FORMAT_A8B8G8R8_SNORM_PACK32=52,VK_FORMAT_A8B8G8R8_USCALED_PACK32=53,VK_FORMAT_A8B8G8R8_SSCALED_PACK32=54,VK_FORMAT_A8B8G8R8_UINT_PACK32=55,VK_FORMAT_A8B8G8R8_SINT_PACK32=56,VK_FORMAT_A8B8G8R8_SRGB_PACK32=57,VK_FORMAT_A2R10G10B10_UNORM_PACK32=58,VK_FORMAT_A2R10G10B10_SNORM_PACK32=59,VK_FORMAT_A2R10G10B10_USCALED_PACK32=60,VK_FORMAT_A2R10G10B10_SSCALED_PACK32=61,VK_FORMAT_A2R10G10B10_UINT_PACK32=62,VK_FORMAT_A2R10G10B10_SINT_PACK32=63,VK_FORMAT_A2B10G10R10_UNORM_PACK32=64,VK_FORMAT_A2B10G10R10_SNORM_PACK32=65,VK_FORMAT_A2B10G10R10_USCALED_PACK32=66,VK_FORMAT_A2B10G10R10_SSCALED_PACK32=67,VK_FORMAT_A2B10G10R10_UINT_PACK32=68,VK_FORMAT_A2B10G10R10_SINT_PACK32=69,VK_FORMAT_R16_UNORM=70,VK_FORMAT_R16_SNORM=71,VK_FORMAT_R16_USCALED=72,VK_FORMAT_R16_SSCALED=73,VK_FORMAT_R16_UINT=74,VK_FORMAT_R16_SINT=75,VK_FORMAT_R16_SFLOAT=76,VK_FORMAT_R16G16_UNORM=77,VK_FORMAT_R16G16_SNORM=78,VK_FORMAT_R16G16_USCALED=79,VK_FORMAT_R16G16_SSCALED=80,VK_FORMAT_R16G16_UINT=81,VK_FORMAT_R16G16_SINT=82,VK_FORMAT_R16G16_SFLOAT=83,VK_FORMAT_R16G16B16_UNORM=84,VK_FORMAT_R16G16B16_SNORM=85,VK_FORMAT_R16G16B16_USCALED=86,VK_FORMAT_R16G16B16_SSCALED=87,VK_FORMAT_R16G16B16_UINT=88,VK_FORMAT_R16G16B16_SINT=89,VK_FORMAT_R16G16B16_SFLOAT=90,VK_FORMAT_R16G16B16A16_UNORM=91,VK_FORMAT_R16G16B16A16_SNORM=92,VK_FORMAT_R16G16B16A16_USCALED=93,VK_FORMAT_R16G16B16A16_SSCALED=94,VK_FORMAT_R16G16B16A16_UINT=95,VK_FORMAT_R16G16B16A16_SINT=96,VK_FORMAT_R16G16B16A16_SFLOAT=97,VK_FORMAT_R32_UINT=98,VK_FORMAT_R32_SINT=99,VK_FORMAT_R32_SFLOAT=100,VK_FORMAT_R32G32_UINT=101,VK_FORMAT_R32G32_SINT=102,VK_FORMAT_R32G32_SFLOAT=103,VK_FORMAT_R32G32B32_UINT=104,VK_FORMAT_R32G32B32_SINT=105,VK_FORMAT_R32G32B32_SFLOAT=106,VK_FORMAT_R32G32B32A32_UINT=107,VK_FORMAT_R32G32B32A32_SINT=108,VK_FORMAT_R32G32B32A32_SFLOAT=109,VK_FORMAT_R64_UINT=110,VK_FORMAT_R64_SINT=111,VK_FORMAT_R64_SFLOAT=112,VK_FORMAT_R64G64_UINT=113,VK_FORMAT_R64G64_SINT=114,VK_FORMAT_R64G64_SFLOAT=115,VK_FORMAT_R64G64B64_UINT=116,VK_FORMAT_R64G64B64_SINT=117,VK_FORMAT_R64G64B64_SFLOAT=118,VK_FORMAT_R64G64B64A64_UINT=119,VK_FORMAT_R64G64B64A64_SINT=120,VK_FORMAT_R64G64B64A64_SFLOAT=121,VK_FORMAT_B10G11R11_UFLOAT_PACK32=122,VK_FORMAT_E5B9G9R9_UFLOAT_PACK32=123,VK_FORMAT_D16_UNORM=124,VK_FORMAT_X8_D24_UNORM_PACK32=125,VK_FORMAT_D32_SFLOAT=126,VK_FORMAT_S8_UINT=127,VK_FORMAT_D16_UNORM_S8_UINT=128,VK_FORMAT_D24_UNORM_S8_UINT=129,VK_FORMAT_D32_SFLOAT_S8_UINT=130,VK_FORMAT_BC1_RGB_UNORM_BLOCK=131,VK_FORMAT_BC1_RGB_SRGB_BLOCK=132,VK_FORMAT_BC1_RGBA_UNORM_BLOCK=133,VK_FORMAT_BC1_RGBA_SRGB_BLOCK=134,VK_FORMAT_BC2_UNORM_BLOCK=135,VK_FORMAT_BC2_SRGB_BLOCK=136,VK_FORMAT_BC3_UNORM_BLOCK=137,VK_FORMAT_BC3_SRGB_BLOCK=138,VK_FORMAT_BC4_UNORM_BLOCK=139,VK_FORMAT_BC4_SNORM_BLOCK=140,VK_FORMAT_BC5_UNORM_BLOCK=141,VK_FORMAT_BC5_SNORM_BLOCK=142,VK_FORMAT_BC6H_UFLOAT_BLOCK=143,VK_FORMAT_BC6H_SFLOAT_BLOCK=144,VK_FORMAT_BC7_UNORM_BLOCK=145,VK_FORMAT_BC7_SRGB_BLOCK=146,VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK=147,VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK=148,VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK=149,VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK=150,VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK=151,VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK=152,VK_FORMAT_EAC_R11_UNORM_BLOCK=153,VK_FORMAT_EAC_R11_SNORM_BLOCK=154,VK_FORMAT_EAC_R11G11_UNORM_BLOCK=155,VK_FORMAT_EAC_R11G11_SNORM_BLOCK=156,VK_FORMAT_ASTC_4x4_UNORM_BLOCK=157,VK_FORMAT_ASTC_4x4_SRGB_BLOCK=158,VK_FORMAT_ASTC_5x4_UNORM_BLOCK=159,VK_FORMAT_ASTC_5x4_SRGB_BLOCK=160,VK_FORMAT_ASTC_5x5_UNORM_BLOCK=161,VK_FORMAT_ASTC_5x5_SRGB_BLOCK=162,VK_FORMAT_ASTC_6x5_UNORM_BLOCK=163,VK_FORMAT_ASTC_6x5_SRGB_BLOCK=164,VK_FORMAT_ASTC_6x6_UNORM_BLOCK=165,VK_FORMAT_ASTC_6x6_SRGB_BLOCK=166,VK_FORMAT_ASTC_8x5_UNORM_BLOCK=167,VK_FORMAT_ASTC_8x5_SRGB_BLOCK=168,VK_FORMAT_ASTC_8x6_UNORM_BLOCK=169,VK_FORMAT_ASTC_8x6_SRGB_BLOCK=170,VK_FORMAT_ASTC_8x8_UNORM_BLOCK=171,VK_FORMAT_ASTC_8x8_SRGB_BLOCK=172,VK_FORMAT_ASTC_10x5_UNORM_BLOCK=173,VK_FORMAT_ASTC_10x5_SRGB_BLOCK=174,VK_FORMAT_ASTC_10x6_UNORM_BLOCK=175,VK_FORMAT_ASTC_10x6_SRGB_BLOCK=176,VK_FORMAT_ASTC_10x8_UNORM_BLOCK=177,VK_FORMAT_ASTC_10x8_SRGB_BLOCK=178,VK_FORMAT_ASTC_10x10_UNORM_BLOCK=179,VK_FORMAT_ASTC_10x10_SRGB_BLOCK=180,VK_FORMAT_ASTC_12x10_UNORM_BLOCK=181,VK_FORMAT_ASTC_12x10_SRGB_BLOCK=182,VK_FORMAT_ASTC_12x12_UNORM_BLOCK=183,VK_FORMAT_ASTC_12x12_SRGB_BLOCK=184,VK_FORMAT_G8B8G8R8_422_UNORM=1000156000,VK_FORMAT_B8G8R8G8_422_UNORM=1000156001,VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM=1000156002,VK_FORMAT_G8_B8R8_2PLANE_420_UNORM=1000156003,VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM=1000156004,VK_FORMAT_G8_B8R8_2PLANE_422_UNORM=1000156005,VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM=1000156006,VK_FORMAT_R10X6_UNORM_PACK16=1000156007,VK_FORMAT_R10X6G10X6_UNORM_2PACK16=1000156008,VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16=1000156009,VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16=1000156010,VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16=1000156011,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16=1000156012,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16=1000156013,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16=1000156014,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16=1000156015,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16=1000156016,VK_FORMAT_R12X4_UNORM_PACK16=1000156017,VK_FORMAT_R12X4G12X4_UNORM_2PACK16=1000156018,VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16=1000156019,VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16=1000156020,VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16=1000156021,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16=1000156022,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16=1000156023,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16=1000156024,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16=1000156025,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16=1000156026,VK_FORMAT_G16B16G16R16_422_UNORM=1000156027,VK_FORMAT_B16G16R16G16_422_UNORM=1000156028,VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM=1000156029,VK_FORMAT_G16_B16R16_2PLANE_420_UNORM=1000156030,VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM=1000156031,VK_FORMAT_G16_B16R16_2PLANE_422_UNORM=1000156032,VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM=1000156033,VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG=1000054000,VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG=1000054001,VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG=1000054002,VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG=1000054003,VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG=1000054004,VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG=1000054005,VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG=1000054006,VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG=1000054007,VK_FORMAT_G8B8G8R8_422_UNORM_KHR=1000156000,VK_FORMAT_B8G8R8G8_422_UNORM_KHR=1000156001,VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR=1000156002,VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR=1000156003,VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR=1000156004,VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR=1000156005,VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR=1000156006,VK_FORMAT_R10X6_UNORM_PACK16_KHR=1000156007,VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR=1000156008,VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR=1000156009,VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR=1000156010,VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR=1000156011,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR=1000156012,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR=1000156013,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR=1000156014,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR=1000156015,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR=1000156016,VK_FORMAT_R12X4_UNORM_PACK16_KHR=1000156017,VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR=1000156018,VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR=1000156019,VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR=1000156020,VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR=1000156021,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR=1000156022,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR=1000156023,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR=1000156024,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR=1000156025,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR=1000156026,VK_FORMAT_G16B16G16R16_422_UNORM_KHR=1000156027,VK_FORMAT_B16G16R16G16_422_UNORM_KHR=1000156028,VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR=1000156029,VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR=1000156030,VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR=1000156031,VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR=1000156032,VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR=1000156033,VK_FORMAT_BEGIN_RANGE=0,VK_FORMAT_END_RANGE=184,VK_FORMAT_RANGE_SIZE=185,VK_FORMAT_MAX_ENUM=2147483647};
typedef enum VkAttachmentStoreOp{VK_ATTACHMENT_STORE_OP_STORE=0,VK_ATTACHMENT_STORE_OP_DONT_CARE=1,VK_ATTACHMENT_STORE_OP_BEGIN_RANGE=0,VK_ATTACHMENT_STORE_OP_END_RANGE=1,VK_ATTACHMENT_STORE_OP_RANGE_SIZE=2,VK_ATTACHMENT_STORE_OP_MAX_ENUM=2147483647};
typedef enum VkLogicOp{VK_LOGIC_OP_CLEAR=0,VK_LOGIC_OP_AND=1,VK_LOGIC_OP_AND_REVERSE=2,VK_LOGIC_OP_COPY=3,VK_LOGIC_OP_AND_INVERTED=4,VK_LOGIC_OP_NO_OP=5,VK_LOGIC_OP_XOR=6,VK_LOGIC_OP_OR=7,VK_LOGIC_OP_NOR=8,VK_LOGIC_OP_EQUIVALENT=9,VK_LOGIC_OP_INVERT=10,VK_LOGIC_OP_OR_REVERSE=11,VK_LOGIC_OP_COPY_INVERTED=12,VK_LOGIC_OP_OR_INVERTED=13,VK_LOGIC_OP_NAND=14,VK_LOGIC_OP_SET=15,VK_LOGIC_OP_BEGIN_RANGE=0,VK_LOGIC_OP_END_RANGE=15,VK_LOGIC_OP_RANGE_SIZE=16,VK_LOGIC_OP_MAX_ENUM=2147483647};
typedef enum VkAttachmentLoadOp{VK_ATTACHMENT_LOAD_OP_LOAD=0,VK_ATTACHMENT_LOAD_OP_CLEAR=1,VK_ATTACHMENT_LOAD_OP_DONT_CARE=2,VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE=0,VK_ATTACHMENT_LOAD_OP_END_RANGE=2,VK_ATTACHMENT_LOAD_OP_RANGE_SIZE=3,VK_ATTACHMENT_LOAD_OP_MAX_ENUM=2147483647};
typedef enum VkSwapchainCreateFlagBitsKHR{VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR=1,VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR=2,VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkCompositeAlphaFlagBitsKHR{VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR=1,VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR=2,VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR=4,VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR=8,VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkImageAspectFlagBits{VK_IMAGE_ASPECT_COLOR_BIT=1,VK_IMAGE_ASPECT_DEPTH_BIT=2,VK_IMAGE_ASPECT_STENCIL_BIT=4,VK_IMAGE_ASPECT_METADATA_BIT=8,VK_IMAGE_ASPECT_PLANE_0_BIT=16,VK_IMAGE_ASPECT_PLANE_1_BIT=32,VK_IMAGE_ASPECT_PLANE_2_BIT=64,VK_IMAGE_ASPECT_PLANE_0_BIT_KHR=16,VK_IMAGE_ASPECT_PLANE_1_BIT_KHR=32,VK_IMAGE_ASPECT_PLANE_2_BIT_KHR=64,VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPointClippingBehavior{VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES=0,VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY=1,VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR=0,VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR=1,VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE=0,VK_POINT_CLIPPING_BEHAVIOR_END_RANGE=1,VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE=2,VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM=2147483647};
typedef enum VkExternalSemaphoreHandleTypeFlagBits{VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT=1,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT=2,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT=4,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT=8,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT=16,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR=1,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR=2,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR=4,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR=8,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR=16,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPolygonMode{VK_POLYGON_MODE_FILL=0,VK_POLYGON_MODE_LINE=1,VK_POLYGON_MODE_POINT=2,VK_POLYGON_MODE_FILL_RECTANGLE_NV=1000153000,VK_POLYGON_MODE_BEGIN_RANGE=0,VK_POLYGON_MODE_END_RANGE=2,VK_POLYGON_MODE_RANGE_SIZE=3,VK_POLYGON_MODE_MAX_ENUM=2147483647};
typedef enum VkColorSpaceKHR{VK_COLOR_SPACE_SRGB_NONLINEAR_KHR=0,VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT=1000104001,VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT=1000104002,VK_COLOR_SPACE_DCI_P3_LINEAR_EXT=1000104003,VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT=1000104004,VK_COLOR_SPACE_BT709_LINEAR_EXT=1000104005,VK_COLOR_SPACE_BT709_NONLINEAR_EXT=1000104006,VK_COLOR_SPACE_BT2020_LINEAR_EXT=1000104007,VK_COLOR_SPACE_HDR10_ST2084_EXT=1000104008,VK_COLOR_SPACE_DOLBYVISION_EXT=1000104009,VK_COLOR_SPACE_HDR10_HLG_EXT=1000104010,VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT=1000104011,VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT=1000104012,VK_COLOR_SPACE_PASS_THROUGH_EXT=1000104013,VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT=1000104014,VK_COLOR_SPACE_BEGIN_RANGE_KHR=0,VK_COLOR_SPACE_END_RANGE_KHR=0,VK_COLOR_SPACE_RANGE_SIZE_KHR=1,VK_COLOR_SPACE_MAX_ENUM_KHR=2147483647};
typedef enum VkImageType{VK_IMAGE_TYPE_1D=0,VK_IMAGE_TYPE_2D=1,VK_IMAGE_TYPE_3D=2,VK_IMAGE_TYPE_BEGIN_RANGE=0,VK_IMAGE_TYPE_END_RANGE=2,VK_IMAGE_TYPE_RANGE_SIZE=3,VK_IMAGE_TYPE_MAX_ENUM=2147483647};
typedef enum VkSparseImageFormatFlagBits{VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT=1,VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT=2,VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT=4,VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkBorderColor{VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK=0,VK_BORDER_COLOR_INT_TRANSPARENT_BLACK=1,VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK=2,VK_BORDER_COLOR_INT_OPAQUE_BLACK=3,VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE=4,VK_BORDER_COLOR_INT_OPAQUE_WHITE=5,VK_BORDER_COLOR_BEGIN_RANGE=0,VK_BORDER_COLOR_END_RANGE=5,VK_BORDER_COLOR_RANGE_SIZE=6,VK_BORDER_COLOR_MAX_ENUM=2147483647};
typedef enum VkSemaphoreImportFlagBits{VK_SEMAPHORE_IMPORT_TEMPORARY_BIT=1,VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR=1,VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkMemoryAllocateFlagBits{VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT=1,VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR=1,VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkInternalAllocationType{VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE=0,VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_END_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE=1,VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryFeatureFlagBits{VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT=4,VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR=4,VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkBlendOverlapEXT{VK_BLEND_OVERLAP_UNCORRELATED_EXT=0,VK_BLEND_OVERLAP_DISJOINT_EXT=1,VK_BLEND_OVERLAP_CONJOINT_EXT=2,VK_BLEND_OVERLAP_BEGIN_RANGE_EXT=0,VK_BLEND_OVERLAP_END_RANGE_EXT=2,VK_BLEND_OVERLAP_RANGE_SIZE_EXT=3,VK_BLEND_OVERLAP_MAX_ENUM_EXT=2147483647};
typedef enum VkValidationCheckEXT{VK_VALIDATION_CHECK_ALL_EXT=0,VK_VALIDATION_CHECK_SHADERS_EXT=1,VK_VALIDATION_CHECK_BEGIN_RANGE_EXT=0,VK_VALIDATION_CHECK_END_RANGE_EXT=1,VK_VALIDATION_CHECK_RANGE_SIZE_EXT=2,VK_VALIDATION_CHECK_MAX_ENUM_EXT=2147483647};
typedef enum VkDeviceEventTypeEXT{VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT=0,VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT=0,VK_DEVICE_EVENT_TYPE_END_RANGE_EXT=0,VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT=1,VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkQueryPipelineStatisticFlagBits{VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT=1,VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT=2,VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT=4,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT=8,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT=16,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT=32,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT=64,VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT=128,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT=256,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT=512,VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT=1024,VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandBufferResetFlagBits{VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkFrontFace{VK_FRONT_FACE_COUNTER_CLOCKWISE=0,VK_FRONT_FACE_CLOCKWISE=1,VK_FRONT_FACE_BEGIN_RANGE=0,VK_FRONT_FACE_END_RANGE=1,VK_FRONT_FACE_RANGE_SIZE=2,VK_FRONT_FACE_MAX_ENUM=2147483647};
typedef enum VkDescriptorType{VK_DESCRIPTOR_TYPE_SAMPLER=0,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER=1,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE=2,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE=3,VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER=4,VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER=5,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER=6,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER=7,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC=8,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC=9,VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT=10,VK_DESCRIPTOR_TYPE_BEGIN_RANGE=0,VK_DESCRIPTOR_TYPE_END_RANGE=10,VK_DESCRIPTOR_TYPE_RANGE_SIZE=11,VK_DESCRIPTOR_TYPE_MAX_ENUM=2147483647};
typedef enum VkBlendOp{VK_BLEND_OP_ADD=0,VK_BLEND_OP_SUBTRACT=1,VK_BLEND_OP_REVERSE_SUBTRACT=2,VK_BLEND_OP_MIN=3,VK_BLEND_OP_MAX=4,VK_BLEND_OP_ZERO_EXT=1000148000,VK_BLEND_OP_SRC_EXT=1000148001,VK_BLEND_OP_DST_EXT=1000148002,VK_BLEND_OP_SRC_OVER_EXT=1000148003,VK_BLEND_OP_DST_OVER_EXT=1000148004,VK_BLEND_OP_SRC_IN_EXT=1000148005,VK_BLEND_OP_DST_IN_EXT=1000148006,VK_BLEND_OP_SRC_OUT_EXT=1000148007,VK_BLEND_OP_DST_OUT_EXT=1000148008,VK_BLEND_OP_SRC_ATOP_EXT=1000148009,VK_BLEND_OP_DST_ATOP_EXT=1000148010,VK_BLEND_OP_XOR_EXT=1000148011,VK_BLEND_OP_MULTIPLY_EXT=1000148012,VK_BLEND_OP_SCREEN_EXT=1000148013,VK_BLEND_OP_OVERLAY_EXT=1000148014,VK_BLEND_OP_DARKEN_EXT=1000148015,VK_BLEND_OP_LIGHTEN_EXT=1000148016,VK_BLEND_OP_COLORDODGE_EXT=1000148017,VK_BLEND_OP_COLORBURN_EXT=1000148018,VK_BLEND_OP_HARDLIGHT_EXT=1000148019,VK_BLEND_OP_SOFTLIGHT_EXT=1000148020,VK_BLEND_OP_DIFFERENCE_EXT=1000148021,VK_BLEND_OP_EXCLUSION_EXT=1000148022,VK_BLEND_OP_INVERT_EXT=1000148023,VK_BLEND_OP_INVERT_RGB_EXT=1000148024,VK_BLEND_OP_LINEARDODGE_EXT=1000148025,VK_BLEND_OP_LINEARBURN_EXT=1000148026,VK_BLEND_OP_VIVIDLIGHT_EXT=1000148027,VK_BLEND_OP_LINEARLIGHT_EXT=1000148028,VK_BLEND_OP_PINLIGHT_EXT=1000148029,VK_BLEND_OP_HARDMIX_EXT=1000148030,VK_BLEND_OP_HSL_HUE_EXT=1000148031,VK_BLEND_OP_HSL_SATURATION_EXT=1000148032,VK_BLEND_OP_HSL_COLOR_EXT=1000148033,VK_BLEND_OP_HSL_LUMINOSITY_EXT=1000148034,VK_BLEND_OP_PLUS_EXT=1000148035,VK_BLEND_OP_PLUS_CLAMPED_EXT=1000148036,VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT=1000148037,VK_BLEND_OP_PLUS_DARKER_EXT=1000148038,VK_BLEND_OP_MINUS_EXT=1000148039,VK_BLEND_OP_MINUS_CLAMPED_EXT=1000148040,VK_BLEND_OP_CONTRAST_EXT=1000148041,VK_BLEND_OP_INVERT_OVG_EXT=1000148042,VK_BLEND_OP_RED_EXT=1000148043,VK_BLEND_OP_GREEN_EXT=1000148044,VK_BLEND_OP_BLUE_EXT=1000148045,VK_BLEND_OP_BEGIN_RANGE=0,VK_BLEND_OP_END_RANGE=4,VK_BLEND_OP_RANGE_SIZE=5,VK_BLEND_OP_MAX_ENUM=2147483647};
typedef enum VkBlendFactor{VK_BLEND_FACTOR_ZERO=0,VK_BLEND_FACTOR_ONE=1,VK_BLEND_FACTOR_SRC_COLOR=2,VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR=3,VK_BLEND_FACTOR_DST_COLOR=4,VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR=5,VK_BLEND_FACTOR_SRC_ALPHA=6,VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA=7,VK_BLEND_FACTOR_DST_ALPHA=8,VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA=9,VK_BLEND_FACTOR_CONSTANT_COLOR=10,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR=11,VK_BLEND_FACTOR_CONSTANT_ALPHA=12,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA=13,VK_BLEND_FACTOR_SRC_ALPHA_SATURATE=14,VK_BLEND_FACTOR_SRC1_COLOR=15,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR=16,VK_BLEND_FACTOR_SRC1_ALPHA=17,VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA=18,VK_BLEND_FACTOR_BEGIN_RANGE=0,VK_BLEND_FACTOR_END_RANGE=18,VK_BLEND_FACTOR_RANGE_SIZE=19,VK_BLEND_FACTOR_MAX_ENUM=2147483647};
typedef enum VkPipelineBindPoint{VK_PIPELINE_BIND_POINT_GRAPHICS=0,VK_PIPELINE_BIND_POINT_COMPUTE=1,VK_PIPELINE_BIND_POINT_BEGIN_RANGE=0,VK_PIPELINE_BIND_POINT_END_RANGE=1,VK_PIPELINE_BIND_POINT_RANGE_SIZE=2,VK_PIPELINE_BIND_POINT_MAX_ENUM=2147483647};
typedef enum VkSharingMode{VK_SHARING_MODE_EXCLUSIVE=0,VK_SHARING_MODE_CONCURRENT=1,VK_SHARING_MODE_BEGIN_RANGE=0,VK_SHARING_MODE_END_RANGE=1,VK_SHARING_MODE_RANGE_SIZE=2,VK_SHARING_MODE_MAX_ENUM=2147483647};
typedef enum VkSamplerAddressMode{VK_SAMPLER_ADDRESS_MODE_REPEAT=0,VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT=1,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE=2,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER=3,VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE=4,VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE=0,VK_SAMPLER_ADDRESS_MODE_END_RANGE=3,VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE=4,VK_SAMPLER_ADDRESS_MODE_MAX_ENUM=2147483647};
typedef enum VkSparseMemoryBindFlagBits{VK_SPARSE_MEMORY_BIND_METADATA_BIT=1,VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPhysicalDeviceType{VK_PHYSICAL_DEVICE_TYPE_OTHER=0,VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU=1,VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU=2,VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU=3,VK_PHYSICAL_DEVICE_TYPE_CPU=4,VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE=0,VK_PHYSICAL_DEVICE_TYPE_END_RANGE=4,VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE=5,VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM=2147483647};
typedef enum VkViewportCoordinateSwizzleNV{VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV=0,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV=1,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV=2,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV=3,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV=4,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV=5,VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV=6,VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV=7,VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV=0,VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV=7,VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV=8,VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV=2147483647};
typedef enum VkMemoryPropertyFlagBits{VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT=1,VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT=2,VK_MEMORY_PROPERTY_HOST_COHERENT_BIT=4,VK_MEMORY_PROPERTY_HOST_CACHED_BIT=8,VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT=16,VK_MEMORY_PROPERTY_PROTECTED_BIT=32,VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSubpassContents{VK_SUBPASS_CONTENTS_INLINE=0,VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS=1,VK_SUBPASS_CONTENTS_BEGIN_RANGE=0,VK_SUBPASS_CONTENTS_END_RANGE=1,VK_SUBPASS_CONTENTS_RANGE_SIZE=2,VK_SUBPASS_CONTENTS_MAX_ENUM=2147483647};
typedef enum VkQueueFlagBits{VK_QUEUE_GRAPHICS_BIT=1,VK_QUEUE_COMPUTE_BIT=2,VK_QUEUE_TRANSFER_BIT=4,VK_QUEUE_SPARSE_BINDING_BIT=8,VK_QUEUE_PROTECTED_BIT=16,VK_QUEUE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkColorComponentFlagBits{VK_COLOR_COMPONENT_R_BIT=1,VK_COLOR_COMPONENT_G_BIT=2,VK_COLOR_COMPONENT_B_BIT=4,VK_COLOR_COMPONENT_A_BIT=8,VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkComponentSwizzle{VK_COMPONENT_SWIZZLE_IDENTITY=0,VK_COMPONENT_SWIZZLE_ZERO=1,VK_COMPONENT_SWIZZLE_ONE=2,VK_COMPONENT_SWIZZLE_R=3,VK_COMPONENT_SWIZZLE_G=4,VK_COMPONENT_SWIZZLE_B=5,VK_COMPONENT_SWIZZLE_A=6,VK_COMPONENT_SWIZZLE_BEGIN_RANGE=0,VK_COMPONENT_SWIZZLE_END_RANGE=6,VK_COMPONENT_SWIZZLE_RANGE_SIZE=7,VK_COMPONENT_SWIZZLE_MAX_ENUM=2147483647};
typedef enum VkCommandBufferUsageFlagBits{VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT=1,VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT=2,VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT=4,VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkStencilOp{VK_STENCIL_OP_KEEP=0,VK_STENCIL_OP_ZERO=1,VK_STENCIL_OP_REPLACE=2,VK_STENCIL_OP_INCREMENT_AND_CLAMP=3,VK_STENCIL_OP_DECREMENT_AND_CLAMP=4,VK_STENCIL_OP_INVERT=5,VK_STENCIL_OP_INCREMENT_AND_WRAP=6,VK_STENCIL_OP_DECREMENT_AND_WRAP=7,VK_STENCIL_OP_BEGIN_RANGE=0,VK_STENCIL_OP_END_RANGE=7,VK_STENCIL_OP_RANGE_SIZE=8,VK_STENCIL_OP_MAX_ENUM=2147483647};
typedef enum VkStencilFaceFlagBits{VK_STENCIL_FACE_FRONT_BIT=1,VK_STENCIL_FACE_BACK_BIT=2,VK_STENCIL_FRONT_AND_BACK=3,VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandBufferLevel{VK_COMMAND_BUFFER_LEVEL_PRIMARY=0,VK_COMMAND_BUFFER_LEVEL_SECONDARY=1,VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE=0,VK_COMMAND_BUFFER_LEVEL_END_RANGE=1,VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE=2,VK_COMMAND_BUFFER_LEVEL_MAX_ENUM=2147483647};
typedef enum VkDiscardRectangleModeEXT{VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT=0,VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT=1,VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT=0,VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT=1,VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT=2,VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT=2147483647};
typedef enum VkSamplerReductionModeEXT{VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT=0,VK_SAMPLER_REDUCTION_MODE_MIN_EXT=1,VK_SAMPLER_REDUCTION_MODE_MAX_EXT=2,VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT=0,VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT=2,VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT=3,VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT=2147483647};
struct VkInstance_T {};
struct VkPhysicalDevice_T {};
struct VkDevice_T {};
struct VkQueue_T {};
struct VkSemaphore_T {};
struct VkCommandBuffer_T {};
struct VkFence_T {};
struct VkDeviceMemory_T {};
struct VkBuffer_T {};
struct VkImage_T {};
struct VkEvent_T {};
struct VkQueryPool_T {};
struct VkBufferView_T {};
struct VkImageView_T {};
struct VkShaderModule_T {};
struct VkPipelineCache_T {};
struct VkPipelineLayout_T {};
struct VkRenderPass_T {};
struct VkPipeline_T {};
struct VkDescriptorSetLayout_T {};
struct VkSampler_T {};
struct VkDescriptorPool_T {};
struct VkDescriptorSet_T {};
struct VkFramebuffer_T {};
struct VkCommandPool_T {};
struct VkApplicationInfo {enum VkStructureType sType;const void*pNext;const char*pApplicationName;unsigned int applicationVersion;const char*pEngineName;unsigned int engineVersion;unsigned int apiVersion;};
struct VkInstanceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkApplicationInfo*pApplicationInfo;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;};
struct VkAllocationCallbacks {void*pUserData;void*(*pfnAllocation)(void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void*(*pfnReallocation)(void*,void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void(*pfnFree)(void*,void*);void(*pfnInternalAllocation)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);void(*pfnInternalFree)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);};
struct VkPhysicalDeviceFeatures {unsigned int robustBufferAccess;unsigned int fullDrawIndexUint32;unsigned int imageCubeArray;unsigned int independentBlend;unsigned int geometryShader;unsigned int tessellationShader;unsigned int sampleRateShading;unsigned int dualSrcBlend;unsigned int logicOp;unsigned int multiDrawIndirect;unsigned int drawIndirectFirstInstance;unsigned int depthClamp;unsigned int depthBiasClamp;unsigned int fillModeNonSolid;unsigned int depthBounds;unsigned int wideLines;unsigned int largePoints;unsigned int alphaToOne;unsigned int multiViewport;unsigned int samplerAnisotropy;unsigned int textureCompressionETC2;unsigned int textureCompressionASTC_LDR;unsigned int textureCompressionBC;unsigned int occlusionQueryPrecise;unsigned int pipelineStatisticsQuery;unsigned int vertexPipelineStoresAndAtomics;unsigned int fragmentStoresAndAtomics;unsigned int shaderTessellationAndGeometryPointSize;unsigned int shaderImageGatherExtended;unsigned int shaderStorageImageExtendedFormats;unsigned int shaderStorageImageMultisample;unsigned int shaderStorageImageReadWithoutFormat;unsigned int shaderStorageImageWriteWithoutFormat;unsigned int shaderUniformBufferArrayDynamicIndexing;unsigned int shaderSampledImageArrayDynamicIndexing;unsigned int shaderStorageBufferArrayDynamicIndexing;unsigned int shaderStorageImageArrayDynamicIndexing;unsigned int shaderClipDistance;unsigned int shaderCullDistance;unsigned int shaderFloat64;unsigned int shaderInt64;unsigned int shaderInt16;unsigned int shaderResourceResidency;unsigned int shaderResourceMinLod;unsigned int sparseBinding;unsigned int sparseResidencyBuffer;unsigned int sparseResidencyImage2D;unsigned int sparseResidencyImage3D;unsigned int sparseResidency2Samples;unsigned int sparseResidency4Samples;unsigned int sparseResidency8Samples;unsigned int sparseResidency16Samples;unsigned int sparseResidencyAliased;unsigned int variableMultisampleRate;unsigned int inheritedQueries;};
struct VkFormatProperties {unsigned int linearTilingFeatures;unsigned int optimalTilingFeatures;unsigned int bufferFeatures;};
struct VkExtent3D {unsigned int width;unsigned int height;unsigned int depth;};
struct VkImageFormatProperties {struct VkExtent3D maxExtent;unsigned int maxMipLevels;unsigned int maxArrayLayers;unsigned int sampleCounts;unsigned long maxResourceSize;};
struct VkPhysicalDeviceLimits {unsigned int maxImageDimension1D;unsigned int maxImageDimension2D;unsigned int maxImageDimension3D;unsigned int maxImageDimensionCube;unsigned int maxImageArrayLayers;unsigned int maxTexelBufferElements;unsigned int maxUniformBufferRange;unsigned int maxStorageBufferRange;unsigned int maxPushConstantsSize;unsigned int maxMemoryAllocationCount;unsigned int maxSamplerAllocationCount;unsigned long bufferImageGranularity;unsigned long sparseAddressSpaceSize;unsigned int maxBoundDescriptorSets;unsigned int maxPerStageDescriptorSamplers;unsigned int maxPerStageDescriptorUniformBuffers;unsigned int maxPerStageDescriptorStorageBuffers;unsigned int maxPerStageDescriptorSampledImages;unsigned int maxPerStageDescriptorStorageImages;unsigned int maxPerStageDescriptorInputAttachments;unsigned int maxPerStageResources;unsigned int maxDescriptorSetSamplers;unsigned int maxDescriptorSetUniformBuffers;unsigned int maxDescriptorSetUniformBuffersDynamic;unsigned int maxDescriptorSetStorageBuffers;unsigned int maxDescriptorSetStorageBuffersDynamic;unsigned int maxDescriptorSetSampledImages;unsigned int maxDescriptorSetStorageImages;unsigned int maxDescriptorSetInputAttachments;unsigned int maxVertexInputAttributes;unsigned int maxVertexInputBindings;unsigned int maxVertexInputAttributeOffset;unsigned int maxVertexInputBindingStride;unsigned int maxVertexOutputComponents;unsigned int maxTessellationGenerationLevel;unsigned int maxTessellationPatchSize;unsigned int maxTessellationControlPerVertexInputComponents;unsigned int maxTessellationControlPerVertexOutputComponents;unsigned int maxTessellationControlPerPatchOutputComponents;unsigned int maxTessellationControlTotalOutputComponents;unsigned int maxTessellationEvaluationInputComponents;unsigned int maxTessellationEvaluationOutputComponents;unsigned int maxGeometryShaderInvocations;unsigned int maxGeometryInputComponents;unsigned int maxGeometryOutputComponents;unsigned int maxGeometryOutputVertices;unsigned int maxGeometryTotalOutputComponents;unsigned int maxFragmentInputComponents;unsigned int maxFragmentOutputAttachments;unsigned int maxFragmentDualSrcAttachments;unsigned int maxFragmentCombinedOutputResources;unsigned int maxComputeSharedMemorySize;unsigned int maxComputeWorkGroupCount[3];unsigned int maxComputeWorkGroupInvocations;unsigned int maxComputeWorkGroupSize[3];unsigned int subPixelPrecisionBits;unsigned int subTexelPrecisionBits;unsigned int mipmapPrecisionBits;unsigned int maxDrawIndexedIndexValue;unsigned int maxDrawIndirectCount;float maxSamplerLodBias;float maxSamplerAnisotropy;unsigned int maxViewports;unsigned int maxViewportDimensions[2];float viewportBoundsRange[2];unsigned int viewportSubPixelBits;unsigned long minMemoryMapAlignment;unsigned long minTexelBufferOffsetAlignment;unsigned long minUniformBufferOffsetAlignment;unsigned long minStorageBufferOffsetAlignment;int minTexelOffset;unsigned int maxTexelOffset;int minTexelGatherOffset;unsigned int maxTexelGatherOffset;float minInterpolationOffset;float maxInterpolationOffset;unsigned int subPixelInterpolationOffsetBits;unsigned int maxFramebufferWidth;unsigned int maxFramebufferHeight;unsigned int maxFramebufferLayers;unsigned int framebufferColorSampleCounts;unsigned int framebufferDepthSampleCounts;unsigned int framebufferStencilSampleCounts;unsigned int framebufferNoAttachmentsSampleCounts;unsigned int maxColorAttachments;unsigned int sampledImageColorSampleCounts;unsigned int sampledImageIntegerSampleCounts;unsigned int sampledImageDepthSampleCounts;unsigned int sampledImageStencilSampleCounts;unsigned int storageImageSampleCounts;unsigned int maxSampleMaskWords;unsigned int timestampComputeAndGraphics;float timestampPeriod;unsigned int maxClipDistances;unsigned int maxCullDistances;unsigned int maxCombinedClipAndCullDistances;unsigned int discreteQueuePriorities;float pointSizeRange[2];float lineWidthRange[2];float pointSizeGranularity;float lineWidthGranularity;unsigned int strictLines;unsigned int standardSampleLocations;unsigned long optimalBufferCopyOffsetAlignment;unsigned long optimalBufferCopyRowPitchAlignment;unsigned long nonCoherentAtomSize;};
struct VkPhysicalDeviceSparseProperties {unsigned int residencyStandard2DBlockShape;unsigned int residencyStandard2DMultisampleBlockShape;unsigned int residencyStandard3DBlockShape;unsigned int residencyAlignedMipSize;unsigned int residencyNonResidentStrict;};
struct VkPhysicalDeviceProperties {unsigned int apiVersion;unsigned int driverVersion;unsigned int vendorID;unsigned int deviceID;enum VkPhysicalDeviceType deviceType;char deviceName[256];unsigned char pipelineCacheUUID[16];struct VkPhysicalDeviceLimits limits;struct VkPhysicalDeviceSparseProperties sparseProperties;};
struct VkQueueFamilyProperties {unsigned int queueFlags;unsigned int queueCount;unsigned int timestampValidBits;struct VkExtent3D minImageTransferGranularity;};
struct VkMemoryType {unsigned int propertyFlags;unsigned int heapIndex;};
struct VkMemoryHeap {unsigned long size;unsigned int flags;};
struct VkPhysicalDeviceMemoryProperties {unsigned int memoryTypeCount;struct VkMemoryType memoryTypes[32];unsigned int memoryHeapCount;struct VkMemoryHeap memoryHeaps[16];};
struct VkDeviceQueueCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;unsigned int queueCount;const float*pQueuePriorities;};
struct VkDeviceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueCreateInfoCount;const struct VkDeviceQueueCreateInfo*pQueueCreateInfos;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;const struct VkPhysicalDeviceFeatures*pEnabledFeatures;};
struct VkExtensionProperties {char extensionName[256];unsigned int specVersion;};
struct VkLayerProperties {char layerName[256];unsigned int specVersion;unsigned int implementationVersion;char description[256];};
struct VkSubmitInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;const unsigned int*pWaitDstStageMask;unsigned int commandBufferCount;struct VkCommandBuffer_T*const*pCommandBuffers;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkMemoryAllocateInfo {enum VkStructureType sType;const void*pNext;unsigned long allocationSize;unsigned int memoryTypeIndex;};
struct VkMappedMemoryRange {enum VkStructureType sType;const void*pNext;struct VkDeviceMemory_T*memory;unsigned long offset;unsigned long size;};
struct VkMemoryRequirements {unsigned long size;unsigned long alignment;unsigned int memoryTypeBits;};
struct VkSparseImageFormatProperties {unsigned int aspectMask;struct VkExtent3D imageGranularity;unsigned int flags;};
struct VkSparseImageMemoryRequirements {struct VkSparseImageFormatProperties formatProperties;unsigned int imageMipTailFirstLod;unsigned long imageMipTailSize;unsigned long imageMipTailOffset;unsigned long imageMipTailStride;};
struct VkSparseMemoryBind {unsigned long resourceOffset;unsigned long size;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseBufferMemoryBindInfo {struct VkBuffer_T*buffer;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkSparseImageOpaqueMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkImageSubresource {unsigned int aspectMask;unsigned int mipLevel;unsigned int arrayLayer;};
struct VkOffset3D {int x;int y;int z;};
struct VkSparseImageMemoryBind {struct VkImageSubresource subresource;struct VkOffset3D offset;struct VkExtent3D extent;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseImageMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseImageMemoryBind*pBinds;};
struct VkBindSparseInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int bufferBindCount;const struct VkSparseBufferMemoryBindInfo*pBufferBinds;unsigned int imageOpaqueBindCount;const struct VkSparseImageOpaqueMemoryBindInfo*pImageOpaqueBinds;unsigned int imageBindCount;const struct VkSparseImageMemoryBindInfo*pImageBinds;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkFenceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkSemaphoreCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkEventCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkQueryPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkQueryType queryType;unsigned int queryCount;unsigned int pipelineStatistics;};
struct VkBufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long size;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;};
struct VkBufferViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkBuffer_T*buffer;enum VkFormat format;unsigned long offset;unsigned long range;};
struct VkImageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkImageType imageType;enum VkFormat format;struct VkExtent3D extent;unsigned int mipLevels;unsigned int arrayLayers;enum VkSampleCountFlagBits samples;enum VkImageTiling tiling;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkImageLayout initialLayout;};
struct VkSubresourceLayout {unsigned long offset;unsigned long size;unsigned long rowPitch;unsigned long arrayPitch;unsigned long depthPitch;};
struct VkComponentMapping {enum VkComponentSwizzle r;enum VkComponentSwizzle g;enum VkComponentSwizzle b;enum VkComponentSwizzle a;};
struct VkImageSubresourceRange {unsigned int aspectMask;unsigned int baseMipLevel;unsigned int levelCount;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkImage_T*image;enum VkImageViewType viewType;enum VkFormat format;struct VkComponentMapping components;struct VkImageSubresourceRange subresourceRange;};
struct VkShaderModuleCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long codeSize;const unsigned int*pCode;};
struct VkPipelineCacheCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long initialDataSize;const void*pInitialData;};
struct VkSpecializationMapEntry {unsigned int constantID;unsigned int offset;unsigned long size;};
struct VkSpecializationInfo {unsigned int mapEntryCount;const struct VkSpecializationMapEntry*pMapEntries;unsigned long dataSize;const void*pData;};
struct VkPipelineShaderStageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkShaderStageFlagBits stage;struct VkShaderModule_T*module;const char*pName;const struct VkSpecializationInfo*pSpecializationInfo;};
struct VkVertexInputBindingDescription {unsigned int binding;unsigned int stride;enum VkVertexInputRate inputRate;};
struct VkVertexInputAttributeDescription {unsigned int location;unsigned int binding;enum VkFormat format;unsigned int offset;};
struct VkPipelineVertexInputStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int vertexBindingDescriptionCount;const struct VkVertexInputBindingDescription*pVertexBindingDescriptions;unsigned int vertexAttributeDescriptionCount;const struct VkVertexInputAttributeDescription*pVertexAttributeDescriptions;};
struct VkPipelineInputAssemblyStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkPrimitiveTopology topology;unsigned int primitiveRestartEnable;};
struct VkPipelineTessellationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int patchControlPoints;};
struct VkViewport {float x;float y;float width;float height;float minDepth;float maxDepth;};
struct VkOffset2D {int x;int y;};
struct VkExtent2D {unsigned int width;unsigned int height;};
struct VkRect2D {struct VkOffset2D offset;struct VkExtent2D extent;};
struct VkPipelineViewportStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int viewportCount;const struct VkViewport*pViewports;unsigned int scissorCount;const struct VkRect2D*pScissors;};
struct VkPipelineRasterizationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthClampEnable;unsigned int rasterizerDiscardEnable;enum VkPolygonMode polygonMode;unsigned int cullMode;enum VkFrontFace frontFace;unsigned int depthBiasEnable;float depthBiasConstantFactor;float depthBiasClamp;float depthBiasSlopeFactor;float lineWidth;};
struct VkPipelineMultisampleStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkSampleCountFlagBits rasterizationSamples;unsigned int sampleShadingEnable;float minSampleShading;const unsigned int*pSampleMask;unsigned int alphaToCoverageEnable;unsigned int alphaToOneEnable;};
struct VkStencilOpState {enum VkStencilOp failOp;enum VkStencilOp passOp;enum VkStencilOp depthFailOp;enum VkCompareOp compareOp;unsigned int compareMask;unsigned int writeMask;unsigned int reference;};
struct VkPipelineDepthStencilStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthTestEnable;unsigned int depthWriteEnable;enum VkCompareOp depthCompareOp;unsigned int depthBoundsTestEnable;unsigned int stencilTestEnable;struct VkStencilOpState front;struct VkStencilOpState back;float minDepthBounds;float maxDepthBounds;};
struct VkPipelineColorBlendAttachmentState {unsigned int blendEnable;enum VkBlendFactor srcColorBlendFactor;enum VkBlendFactor dstColorBlendFactor;enum VkBlendOp colorBlendOp;enum VkBlendFactor srcAlphaBlendFactor;enum VkBlendFactor dstAlphaBlendFactor;enum VkBlendOp alphaBlendOp;unsigned int colorWriteMask;};
struct VkPipelineColorBlendStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int logicOpEnable;enum VkLogicOp logicOp;unsigned int attachmentCount;const struct VkPipelineColorBlendAttachmentState*pAttachments;float blendConstants[4];};
struct VkPipelineDynamicStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int dynamicStateCount;const enum VkDynamicState*pDynamicStates;};
struct VkGraphicsPipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int stageCount;const struct VkPipelineShaderStageCreateInfo*pStages;const struct VkPipelineVertexInputStateCreateInfo*pVertexInputState;const struct VkPipelineInputAssemblyStateCreateInfo*pInputAssemblyState;const struct VkPipelineTessellationStateCreateInfo*pTessellationState;const struct VkPipelineViewportStateCreateInfo*pViewportState;const struct VkPipelineRasterizationStateCreateInfo*pRasterizationState;const struct VkPipelineMultisampleStateCreateInfo*pMultisampleState;const struct VkPipelineDepthStencilStateCreateInfo*pDepthStencilState;const struct VkPipelineColorBlendStateCreateInfo*pColorBlendState;const struct VkPipelineDynamicStateCreateInfo*pDynamicState;struct VkPipelineLayout_T*layout;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkComputePipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkPipelineShaderStageCreateInfo stage;struct VkPipelineLayout_T*layout;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkPushConstantRange {unsigned int stageFlags;unsigned int offset;unsigned int size;};
struct VkPipelineLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int setLayoutCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;unsigned int pushConstantRangeCount;const struct VkPushConstantRange*pPushConstantRanges;};
struct VkSamplerCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkFilter magFilter;enum VkFilter minFilter;enum VkSamplerMipmapMode mipmapMode;enum VkSamplerAddressMode addressModeU;enum VkSamplerAddressMode addressModeV;enum VkSamplerAddressMode addressModeW;float mipLodBias;unsigned int anisotropyEnable;float maxAnisotropy;unsigned int compareEnable;enum VkCompareOp compareOp;float minLod;float maxLod;enum VkBorderColor borderColor;unsigned int unnormalizedCoordinates;};
struct VkDescriptorSetLayoutBinding {unsigned int binding;enum VkDescriptorType descriptorType;unsigned int descriptorCount;unsigned int stageFlags;struct VkSampler_T*const*pImmutableSamplers;};
struct VkDescriptorSetLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int bindingCount;const struct VkDescriptorSetLayoutBinding*pBindings;};
struct VkDescriptorPoolSize {enum VkDescriptorType type;unsigned int descriptorCount;};
struct VkDescriptorPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int maxSets;unsigned int poolSizeCount;const struct VkDescriptorPoolSize*pPoolSizes;};
struct VkDescriptorSetAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkDescriptorPool_T*descriptorPool;unsigned int descriptorSetCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;};
struct VkDescriptorImageInfo {struct VkSampler_T*sampler;struct VkImageView_T*imageView;enum VkImageLayout imageLayout;};
struct VkDescriptorBufferInfo {struct VkBuffer_T*buffer;unsigned long offset;unsigned long range;};
struct VkWriteDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;enum VkDescriptorType descriptorType;const struct VkDescriptorImageInfo*pImageInfo;const struct VkDescriptorBufferInfo*pBufferInfo;struct VkBufferView_T*const*pTexelBufferView;};
struct VkCopyDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*srcSet;unsigned int srcBinding;unsigned int srcArrayElement;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;};
struct VkFramebufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkRenderPass_T*renderPass;unsigned int attachmentCount;struct VkImageView_T*const*pAttachments;unsigned int width;unsigned int height;unsigned int layers;};
struct VkAttachmentDescription {unsigned int flags;enum VkFormat format;enum VkSampleCountFlagBits samples;enum VkAttachmentLoadOp loadOp;enum VkAttachmentStoreOp storeOp;enum VkAttachmentLoadOp stencilLoadOp;enum VkAttachmentStoreOp stencilStoreOp;enum VkImageLayout initialLayout;enum VkImageLayout finalLayout;};
struct VkAttachmentReference {unsigned int attachment;enum VkImageLayout layout;};
struct VkSubpassDescription {unsigned int flags;enum VkPipelineBindPoint pipelineBindPoint;unsigned int inputAttachmentCount;const struct VkAttachmentReference*pInputAttachments;unsigned int colorAttachmentCount;const struct VkAttachmentReference*pColorAttachments;const struct VkAttachmentReference*pResolveAttachments;const struct VkAttachmentReference*pDepthStencilAttachment;unsigned int preserveAttachmentCount;const unsigned int*pPreserveAttachments;};
struct VkSubpassDependency {unsigned int srcSubpass;unsigned int dstSubpass;unsigned int srcStageMask;unsigned int dstStageMask;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int dependencyFlags;};
struct VkRenderPassCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int attachmentCount;const struct VkAttachmentDescription*pAttachments;unsigned int subpassCount;const struct VkSubpassDescription*pSubpasses;unsigned int dependencyCount;const struct VkSubpassDependency*pDependencies;};
struct VkCommandPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;};
struct VkCommandBufferAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkCommandPool_T*commandPool;enum VkCommandBufferLevel level;unsigned int commandBufferCount;};
struct VkCommandBufferInheritanceInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkFramebuffer_T*framebuffer;unsigned int occlusionQueryEnable;unsigned int queryFlags;unsigned int pipelineStatistics;};
struct VkCommandBufferBeginInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkCommandBufferInheritanceInfo*pInheritanceInfo;};
struct VkBufferCopy {unsigned long srcOffset;unsigned long dstOffset;unsigned long size;};
struct VkImageSubresourceLayers {unsigned int aspectMask;unsigned int mipLevel;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageCopy {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkImageBlit {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffsets[2];struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffsets[2];};
struct VkBufferImageCopy {unsigned long bufferOffset;unsigned int bufferRowLength;unsigned int bufferImageHeight;struct VkImageSubresourceLayers imageSubresource;struct VkOffset3D imageOffset;struct VkExtent3D imageExtent;};
union VkClearColorValue {float float32[4];int int32[4];unsigned int uint32[4];};
struct VkClearDepthStencilValue {float depth;unsigned int stencil;};
union VkClearValue {union VkClearColorValue color;struct VkClearDepthStencilValue depthStencil;};
struct VkClearAttachment {unsigned int aspectMask;unsigned int colorAttachment;union VkClearValue clearValue;};
struct VkClearRect {struct VkRect2D rect;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageResolve {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;};
struct VkBufferMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkBuffer_T*buffer;unsigned long offset;unsigned long size;};
struct VkImageMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;enum VkImageLayout oldLayout;enum VkImageLayout newLayout;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkImage_T*image;struct VkImageSubresourceRange subresourceRange;};
struct VkRenderPassBeginInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;struct VkFramebuffer_T*framebuffer;struct VkRect2D renderArea;unsigned int clearValueCount;const union VkClearValue*pClearValues;};
struct VkSamplerYcbcrConversion_T {};
struct VkDescriptorUpdateTemplate_T {};
struct VkBindBufferMemoryInfo {enum VkStructureType sType;const void*pNext;struct VkBuffer_T*buffer;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;};
struct VkBindImageMemoryInfo {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;};
struct VkPhysicalDeviceGroupProperties {enum VkStructureType sType;void*pNext;unsigned int physicalDeviceCount;struct VkPhysicalDevice_T*physicalDevices[32];unsigned int subsetAllocation;};
struct VkBufferMemoryRequirementsInfo2 {enum VkStructureType sType;const void*pNext;struct VkBuffer_T*buffer;};
struct VkImageMemoryRequirementsInfo2 {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;};
struct VkImageSparseMemoryRequirementsInfo2 {enum VkStructureType sType;const void*pNext;struct VkImage_T*image;};
struct VkMemoryRequirements2 {enum VkStructureType sType;void*pNext;struct VkMemoryRequirements memoryRequirements;};
struct VkSparseImageMemoryRequirements2 {enum VkStructureType sType;void*pNext;struct VkSparseImageMemoryRequirements memoryRequirements;};
struct VkPhysicalDeviceFeatures2 {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceFeatures features;};
struct VkPhysicalDeviceProperties2 {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceProperties properties;};
struct VkFormatProperties2 {enum VkStructureType sType;void*pNext;struct VkFormatProperties formatProperties;};
struct VkImageFormatProperties2 {enum VkStructureType sType;void*pNext;struct VkImageFormatProperties imageFormatProperties;};
struct VkPhysicalDeviceImageFormatInfo2 {enum VkStructureType sType;const void*pNext;enum VkFormat format;enum VkImageType type;enum VkImageTiling tiling;unsigned int usage;unsigned int flags;};
struct VkQueueFamilyProperties2 {enum VkStructureType sType;void*pNext;struct VkQueueFamilyProperties queueFamilyProperties;};
struct VkPhysicalDeviceMemoryProperties2 {enum VkStructureType sType;void*pNext;struct VkPhysicalDeviceMemoryProperties memoryProperties;};
struct VkSparseImageFormatProperties2 {enum VkStructureType sType;void*pNext;struct VkSparseImageFormatProperties properties;};
struct VkPhysicalDeviceSparseImageFormatInfo2 {enum VkStructureType sType;const void*pNext;enum VkFormat format;enum VkImageType type;enum VkSampleCountFlagBits samples;unsigned int usage;enum VkImageTiling tiling;};
struct VkDeviceQueueInfo2 {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;unsigned int queueIndex;};
struct VkSamplerYcbcrConversionCreateInfo {enum VkStructureType sType;const void*pNext;enum VkFormat format;enum VkSamplerYcbcrModelConversion ycbcrModel;enum VkSamplerYcbcrRange ycbcrRange;struct VkComponentMapping components;enum VkChromaLocation xChromaOffset;enum VkChromaLocation yChromaOffset;enum VkFilter chromaFilter;unsigned int forceExplicitReconstruction;};
struct VkDescriptorUpdateTemplateEntry {unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;enum VkDescriptorType descriptorType;unsigned long offset;unsigned long stride;};
struct VkDescriptorUpdateTemplateCreateInfo {enum VkStructureType sType;void*pNext;unsigned int flags;unsigned int descriptorUpdateEntryCount;const struct VkDescriptorUpdateTemplateEntry*pDescriptorUpdateEntries;enum VkDescriptorUpdateTemplateType templateType;struct VkDescriptorSetLayout_T*descriptorSetLayout;enum VkPipelineBindPoint pipelineBindPoint;struct VkPipelineLayout_T*pipelineLayout;unsigned int set;};
struct VkExternalMemoryProperties {unsigned int externalMemoryFeatures;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;};
struct VkPhysicalDeviceExternalBufferInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int usage;enum VkExternalMemoryHandleTypeFlagBits handleType;};
struct VkExternalBufferProperties {enum VkStructureType sType;void*pNext;struct VkExternalMemoryProperties externalMemoryProperties;};
struct VkPhysicalDeviceExternalFenceInfo {enum VkStructureType sType;const void*pNext;enum VkExternalFenceHandleTypeFlagBits handleType;};
struct VkExternalFenceProperties {enum VkStructureType sType;void*pNext;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;unsigned int externalFenceFeatures;};
struct VkPhysicalDeviceExternalSemaphoreInfo {enum VkStructureType sType;const void*pNext;enum VkExternalSemaphoreHandleTypeFlagBits handleType;};
struct VkExternalSemaphoreProperties {enum VkStructureType sType;void*pNext;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;unsigned int externalSemaphoreFeatures;};
struct VkDescriptorSetLayoutSupport {enum VkStructureType sType;void*pNext;unsigned int supported;};
struct VkSurfaceKHR_T {};
struct VkSurfaceCapabilitiesKHR {unsigned int minImageCount;unsigned int maxImageCount;struct VkExtent2D currentExtent;struct VkExtent2D minImageExtent;struct VkExtent2D maxImageExtent;unsigned int maxImageArrayLayers;unsigned int supportedTransforms;enum VkSurfaceTransformFlagBitsKHR currentTransform;unsigned int supportedCompositeAlpha;unsigned int supportedUsageFlags;};
struct VkSurfaceFormatKHR {enum VkFormat format;enum VkColorSpaceKHR colorSpace;};
struct VkSwapchainKHR_T {};
struct VkSwapchainCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkSurfaceKHR_T*surface;unsigned int minImageCount;enum VkFormat imageFormat;enum VkColorSpaceKHR imageColorSpace;struct VkExtent2D imageExtent;unsigned int imageArrayLayers;unsigned int imageUsage;enum VkSharingMode imageSharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkSurfaceTransformFlagBitsKHR preTransform;enum VkCompositeAlphaFlagBitsKHR compositeAlpha;enum VkPresentModeKHR presentMode;unsigned int clipped;struct VkSwapchainKHR_T*oldSwapchain;};
struct VkPresentInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int swapchainCount;struct VkSwapchainKHR_T*const*pSwapchains;const unsigned int*pImageIndices;enum VkResult*pResults;};
struct VkAcquireNextImageInfoKHR {enum VkStructureType sType;const void*pNext;struct VkSwapchainKHR_T*swapchain;unsigned long timeout;struct VkSemaphore_T*semaphore;struct VkFence_T*fence;unsigned int deviceMask;};
struct VkDeviceGroupPresentCapabilitiesKHR {enum VkStructureType sType;const void*pNext;unsigned int presentMask[32];unsigned int modes;};
struct VkDisplayKHR_T {};
struct VkDisplayModeKHR_T {};
struct VkDisplayPropertiesKHR {struct VkDisplayKHR_T*display;const char*displayName;struct VkExtent2D physicalDimensions;struct VkExtent2D physicalResolution;unsigned int supportedTransforms;unsigned int planeReorderPossible;unsigned int persistentContent;};
struct VkDisplayModeParametersKHR {struct VkExtent2D visibleRegion;unsigned int refreshRate;};
struct VkDisplayModePropertiesKHR {struct VkDisplayModeKHR_T*displayMode;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayModeCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayPlaneCapabilitiesKHR {unsigned int supportedAlpha;struct VkOffset2D minSrcPosition;struct VkOffset2D maxSrcPosition;struct VkExtent2D minSrcExtent;struct VkExtent2D maxSrcExtent;struct VkOffset2D minDstPosition;struct VkOffset2D maxDstPosition;struct VkExtent2D minDstExtent;struct VkExtent2D maxDstExtent;};
struct VkDisplayPlanePropertiesKHR {struct VkDisplayKHR_T*currentDisplay;unsigned int currentStackIndex;};
struct VkDisplaySurfaceCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeKHR_T*displayMode;unsigned int planeIndex;unsigned int planeStackIndex;enum VkSurfaceTransformFlagBitsKHR transform;float globalAlpha;enum VkDisplayPlaneAlphaFlagBitsKHR alphaMode;struct VkExtent2D imageExtent;};
struct VkMemoryFdPropertiesKHR {enum VkStructureType sType;void*pNext;unsigned int memoryTypeBits;};
struct VkMemoryGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkDeviceMemory_T*memory;enum VkExternalMemoryHandleTypeFlagBits handleType;};
struct VkImportSemaphoreFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkSemaphore_T*semaphore;unsigned int flags;enum VkExternalSemaphoreHandleTypeFlagBits handleType;int fd;};
struct VkSemaphoreGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkSemaphore_T*semaphore;enum VkExternalSemaphoreHandleTypeFlagBits handleType;};
struct VkImportFenceFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkFence_T*fence;unsigned int flags;enum VkExternalFenceHandleTypeFlagBits handleType;int fd;};
struct VkFenceGetFdInfoKHR {enum VkStructureType sType;const void*pNext;struct VkFence_T*fence;enum VkExternalFenceHandleTypeFlagBits handleType;};
struct VkPhysicalDeviceSurfaceInfo2KHR {enum VkStructureType sType;const void*pNext;struct VkSurfaceKHR_T*surface;};
struct VkSurfaceCapabilities2KHR {enum VkStructureType sType;void*pNext;struct VkSurfaceCapabilitiesKHR surfaceCapabilities;};
struct VkSurfaceFormat2KHR {enum VkStructureType sType;void*pNext;struct VkSurfaceFormatKHR surfaceFormat;};
struct VkDebugReportCallbackEXT_T {};
struct VkDebugReportCallbackCreateInfoEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int(*pfnCallback)(unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*,void*);void*pUserData;};
struct VkDebugMarkerObjectNameInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;const char*pObjectName;};
struct VkDebugMarkerObjectTagInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;unsigned long tagName;unsigned long tagSize;const void*pTag;};
struct VkDebugMarkerMarkerInfoEXT {enum VkStructureType sType;const void*pNext;const char*pMarkerName;float color[4];};
struct VkExternalImageFormatPropertiesNV {struct VkImageFormatProperties imageFormatProperties;unsigned int externalMemoryFeatures;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;};
struct VkObjectTableNVX_T {};
struct VkIndirectCommandsLayoutNVX_T {};
struct VkDeviceGeneratedCommandsFeaturesNVX {enum VkStructureType sType;const void*pNext;unsigned int computeBindingPointSupport;};
struct VkDeviceGeneratedCommandsLimitsNVX {enum VkStructureType sType;const void*pNext;unsigned int maxIndirectCommandsLayoutTokenCount;unsigned int maxObjectEntryCounts;unsigned int minSequenceCountBufferOffsetAlignment;unsigned int minSequenceIndexBufferOffsetAlignment;unsigned int minCommandsTokenBufferOffsetAlignment;};
struct VkIndirectCommandsTokenNVX {enum VkIndirectCommandsTokenTypeNVX tokenType;struct VkBuffer_T*buffer;unsigned long offset;};
struct VkIndirectCommandsLayoutTokenNVX {enum VkIndirectCommandsTokenTypeNVX tokenType;unsigned int bindingUnit;unsigned int dynamicCount;unsigned int divisor;};
struct VkIndirectCommandsLayoutCreateInfoNVX {enum VkStructureType sType;const void*pNext;enum VkPipelineBindPoint pipelineBindPoint;unsigned int flags;unsigned int tokenCount;const struct VkIndirectCommandsLayoutTokenNVX*pTokens;};
struct VkCmdProcessCommandsInfoNVX {enum VkStructureType sType;const void*pNext;struct VkObjectTableNVX_T*objectTable;struct VkIndirectCommandsLayoutNVX_T*indirectCommandsLayout;unsigned int indirectCommandsTokenCount;const struct VkIndirectCommandsTokenNVX*pIndirectCommandsTokens;unsigned int maxSequencesCount;struct VkCommandBuffer_T*targetCommandBuffer;struct VkBuffer_T*sequencesCountBuffer;unsigned long sequencesCountOffset;struct VkBuffer_T*sequencesIndexBuffer;unsigned long sequencesIndexOffset;};
struct VkCmdReserveSpaceForCommandsInfoNVX {enum VkStructureType sType;const void*pNext;struct VkObjectTableNVX_T*objectTable;struct VkIndirectCommandsLayoutNVX_T*indirectCommandsLayout;unsigned int maxSequencesCount;};
struct VkObjectTableCreateInfoNVX {enum VkStructureType sType;const void*pNext;unsigned int objectCount;const enum VkObjectEntryTypeNVX*pObjectEntryTypes;const unsigned int*pObjectEntryCounts;const unsigned int*pObjectEntryUsageFlags;unsigned int maxUniformBuffersPerDescriptor;unsigned int maxStorageBuffersPerDescriptor;unsigned int maxStorageImagesPerDescriptor;unsigned int maxSampledImagesPerDescriptor;unsigned int maxPipelineLayouts;};
struct VkObjectTableEntryNVX {enum VkObjectEntryTypeNVX type;unsigned int flags;};
struct VkViewportWScalingNV {float xcoeff;float ycoeff;};
struct VkSurfaceCapabilities2EXT {enum VkStructureType sType;void*pNext;unsigned int minImageCount;unsigned int maxImageCount;struct VkExtent2D currentExtent;struct VkExtent2D minImageExtent;struct VkExtent2D maxImageExtent;unsigned int maxImageArrayLayers;unsigned int supportedTransforms;enum VkSurfaceTransformFlagBitsKHR currentTransform;unsigned int supportedCompositeAlpha;unsigned int supportedUsageFlags;unsigned int supportedSurfaceCounters;};
struct VkDisplayPowerInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDisplayPowerStateEXT powerState;};
struct VkDeviceEventInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDeviceEventTypeEXT deviceEvent;};
struct VkDisplayEventInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDisplayEventTypeEXT displayEvent;};
struct VkRefreshCycleDurationGOOGLE {unsigned long refreshDuration;};
struct VkPastPresentationTimingGOOGLE {unsigned int presentID;unsigned long desiredPresentTime;unsigned long actualPresentTime;unsigned long earliestPresentTime;unsigned long presentMargin;};
struct VkXYColorEXT {float x;float y;};
struct VkHdrMetadataEXT {enum VkStructureType sType;const void*pNext;struct VkXYColorEXT displayPrimaryRed;struct VkXYColorEXT displayPrimaryGreen;struct VkXYColorEXT displayPrimaryBlue;struct VkXYColorEXT whitePoint;float maxLuminance;float minLuminance;float maxContentLightLevel;float maxFrameAverageLightLevel;};
struct VkDebugUtilsMessengerEXT_T {};
struct VkDebugUtilsObjectNameInfoEXT {enum VkStructureType sType;const void*pNext;enum VkObjectType objectType;unsigned long objectHandle;const char*pObjectName;};
struct VkDebugUtilsObjectTagInfoEXT {enum VkStructureType sType;const void*pNext;enum VkObjectType objectType;unsigned long objectHandle;unsigned long tagName;unsigned long tagSize;const void*pTag;};
struct VkDebugUtilsLabelEXT {enum VkStructureType sType;const void*pNext;const char*pLabelName;float color[4];};
struct VkDebugUtilsMessengerCallbackDataEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;const char*pMessageIdName;int messageIdNumber;const char*pMessage;unsigned int queueLabelCount;struct VkDebugUtilsLabelEXT*pQueueLabels;unsigned int cmdBufLabelCount;struct VkDebugUtilsLabelEXT*pCmdBufLabels;unsigned int objectCount;struct VkDebugUtilsObjectNameInfoEXT*pObjects;};
struct VkDebugUtilsMessengerCreateInfoEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int messageSeverity;unsigned int messageType;unsigned int(*pfnUserCallback)(enum VkDebugUtilsMessageSeverityFlagBitsEXT,unsigned int,const struct VkDebugUtilsMessengerCallbackDataEXT*,void*);void*pUserData;};
struct VkSampleLocationEXT {float x;float y;};
struct VkSampleLocationsInfoEXT {enum VkStructureType sType;const void*pNext;enum VkSampleCountFlagBits sampleLocationsPerPixel;struct VkExtent2D sampleLocationGridSize;unsigned int sampleLocationsCount;const struct VkSampleLocationEXT*pSampleLocations;};
struct VkMultisamplePropertiesEXT {enum VkStructureType sType;void*pNext;struct VkExtent2D maxSampleLocationGridSize;};
struct VkValidationCacheEXT_T {};
struct VkValidationCacheCreateInfoEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long initialDataSize;const void*pInitialData;};
struct VkMemoryHostPointerPropertiesEXT {enum VkStructureType sType;void*pNext;unsigned int memoryTypeBits;};
enum VkResult(vkCreateBufferView)(struct VkDevice_T*,const struct VkBufferViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkBufferView_T**);
void(vkCmdCopyImageToBuffer)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkBuffer_T*,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdResolveImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageResolve*);
enum VkResult(vkCreateGraphicsPipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkGraphicsPipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
void(vkGetPhysicalDeviceMultisamplePropertiesEXT)(struct VkPhysicalDevice_T*,enum VkSampleCountFlagBits,struct VkMultisamplePropertiesEXT*);
enum VkResult(vkGetPipelineCacheData)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned long*,void*);
void(vkDestroyObjectTableNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumerateInstanceLayerProperties)(unsigned int*,struct VkLayerProperties*);
enum VkResult(vkResetEvent)(struct VkDevice_T*,struct VkEvent_T*);
enum VkResult(vkSetDebugUtilsObjectTagEXT)(struct VkDevice_T*,const struct VkDebugUtilsObjectTagInfoEXT*);
enum VkResult(vkQueueWaitIdle)(struct VkQueue_T*);
enum VkResult(vkRegisterDisplayEventEXT)(struct VkDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayEventInfoEXT*,const struct VkAllocationCallbacks*,struct VkFence_T**);
enum VkResult(vkImportFenceFdKHR)(struct VkDevice_T*,const struct VkImportFenceFdInfoKHR*);
void(vkGetPhysicalDeviceExternalSemaphoreProperties)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalSemaphoreInfo*,struct VkExternalSemaphoreProperties*);
enum VkResult(vkEnumeratePhysicalDevices)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDevice_T**);
void(vkGetPhysicalDeviceFormatProperties2KHR)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties2*);
enum VkResult(vkResetFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*);
enum VkResult(vkGetRefreshCycleDurationGOOGLE)(struct VkDevice_T*,struct VkSwapchainKHR_T*,struct VkRefreshCycleDurationGOOGLE*);
enum VkResult(vkSetDebugUtilsObjectNameEXT)(struct VkDevice_T*,const struct VkDebugUtilsObjectNameInfoEXT*);
enum VkResult(vkGetMemoryFdKHR)(struct VkDevice_T*,const struct VkMemoryGetFdInfoKHR*,int*);
enum VkResult(vkBindBufferMemory2KHR)(struct VkDevice_T*,unsigned int,const struct VkBindBufferMemoryInfo*);
enum VkResult(vkCreateFramebuffer)(struct VkDevice_T*,const struct VkFramebufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkFramebuffer_T**);
void(vkCmdResetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
enum VkResult(vkBindBufferMemory)(struct VkDevice_T*,struct VkBuffer_T*,struct VkDeviceMemory_T*,unsigned long);
void(vkGetPhysicalDeviceProperties2)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties2*);
enum VkResult(vkEndCommandBuffer)(struct VkCommandBuffer_T*);
void(vkGetPhysicalDeviceProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties*);
void(vkCmdDispatchIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long);
void(vkCmdNextSubpass)(struct VkCommandBuffer_T*,enum VkSubpassContents);
void(vkGetDescriptorSetLayoutSupportKHR)(struct VkDevice_T*,const struct VkDescriptorSetLayoutCreateInfo*,struct VkDescriptorSetLayoutSupport*);
void(vkCmdCopyBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkBuffer_T*,unsigned int,const struct VkBufferCopy*);
enum VkResult(vkRegisterObjectsNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,unsigned int,const struct VkObjectTableEntryNVX*const*,const unsigned int*);
void(vkCmdDrawIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetDisplayPlaneSupportedDisplaysKHR)(struct VkPhysicalDevice_T*,unsigned int,unsigned int*,struct VkDisplayKHR_T**);
enum VkResult(vkCreateValidationCacheEXT)(struct VkDevice_T*,const struct VkValidationCacheCreateInfoEXT*,const struct VkAllocationCallbacks*,struct VkValidationCacheEXT_T**);
enum VkResult(vkGetSwapchainStatusKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*);
enum VkResult(vkCreateDebugUtilsMessengerEXT)(struct VkInstance_T*,const struct VkDebugUtilsMessengerCreateInfoEXT*,const struct VkAllocationCallbacks*,struct VkDebugUtilsMessengerEXT_T**);
enum VkResult(vkCreateComputePipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkComputePipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
void(vkDestroyIndirectCommandsLayoutNVX)(struct VkDevice_T*,struct VkIndirectCommandsLayoutNVX_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateDescriptorSetLayout)(struct VkDevice_T*,const struct VkDescriptorSetLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorSetLayout_T**);
void(vkDestroyQueryPool)(struct VkDevice_T*,struct VkQueryPool_T*,const struct VkAllocationCallbacks*);
void(vkGetPhysicalDeviceMemoryProperties2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties2*);
void(vkCmdUpdateBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,const void*);
void(vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalSemaphoreInfo*,struct VkExternalSemaphoreProperties*);
void(vkCmdSetStencilReference)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
void(vkCmdDebugMarkerEndEXT)(struct VkCommandBuffer_T*);
enum VkResult(vkCreateQueryPool)(struct VkDevice_T*,const struct VkQueryPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkQueryPool_T**);
void(vkDestroyDebugReportCallbackEXT)(struct VkInstance_T*,struct VkDebugReportCallbackEXT_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetFenceStatus)(struct VkDevice_T*,struct VkFence_T*);
void(vkGetImageSparseMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkImageSparseMemoryRequirementsInfo2*,unsigned int*,struct VkSparseImageMemoryRequirements2*);
void(vkCmdBeginQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
void(vkCmdProcessCommandsNVX)(struct VkCommandBuffer_T*,const struct VkCmdProcessCommandsInfoNVX*);
void(vkGetPhysicalDeviceFeatures2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures2*);
enum VkResult(vkQueueSubmit)(struct VkQueue_T*,unsigned int,const struct VkSubmitInfo*,struct VkFence_T*);
void(vkCmdBlitImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageBlit*,enum VkFilter);
void(vkGetPhysicalDeviceExternalBufferPropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalBufferInfo*,struct VkExternalBufferProperties*);
void(vkCmdSetDepthBias)(struct VkCommandBuffer_T*,float,float,float);
void(vkCmdSetSampleLocationsEXT)(struct VkCommandBuffer_T*,const struct VkSampleLocationsInfoEXT*);
void(vkGetPhysicalDeviceExternalFencePropertiesKHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalFenceInfo*,struct VkExternalFenceProperties*);
enum VkResult(vkCreateObjectTableNVX)(struct VkDevice_T*,const struct VkObjectTableCreateInfoNVX*,const struct VkAllocationCallbacks*,struct VkObjectTableNVX_T**);
enum VkResult(vkGetPastPresentationTimingGOOGLE)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned int*,struct VkPastPresentationTimingGOOGLE*);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,struct VkImageFormatProperties*);
void(vkCmdPushConstants)(struct VkCommandBuffer_T*,struct VkPipelineLayout_T*,unsigned int,unsigned int,unsigned int,const void*);
void(vkCmdCopyBufferToImage)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdBindVertexBuffers)(struct VkCommandBuffer_T*,unsigned int,unsigned int,struct VkBuffer_T*const*,const unsigned long*);
void(vkGetPhysicalDeviceFormatProperties2)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties2*);
void(vkDestroyCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateSampler)(struct VkDevice_T*,const struct VkSamplerCreateInfo*,const struct VkAllocationCallbacks*,struct VkSampler_T**);
enum VkResult(vkGetDisplayPlaneCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayModeKHR_T*,unsigned int,struct VkDisplayPlaneCapabilitiesKHR*);
void(vkCmdSetBlendConstants)(struct VkCommandBuffer_T*,const float);
void(vkGetImageSparseMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,unsigned int*,struct VkSparseImageMemoryRequirements*);
void(vkDestroyImageView)(struct VkDevice_T*,struct VkImageView_T*,const struct VkAllocationCallbacks*);
void(vkQueueEndDebugUtilsLabelEXT)(struct VkQueue_T*);
enum VkResult(vkGetEventStatus)(struct VkDevice_T*,struct VkEvent_T*);
void(vkCmdSetDeviceMaskKHR)(struct VkCommandBuffer_T*,unsigned int);
void(vkCmdDebugMarkerInsertEXT)(struct VkCommandBuffer_T*,const struct VkDebugMarkerMarkerInfoEXT*);
void(vkCmdFillBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
void(vkCmdReserveSpaceForCommandsNVX)(struct VkCommandBuffer_T*,const struct VkCmdReserveSpaceForCommandsInfoNVX*);
void(vkGetPhysicalDeviceSparseImageFormatProperties2)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSparseImageFormatInfo2*,unsigned int*,struct VkSparseImageFormatProperties2*);
enum VkResult(vkCreateImage)(struct VkDevice_T*,const struct VkImageCreateInfo*,const struct VkAllocationCallbacks*,struct VkImage_T**);
enum VkResult(vkGetDisplayModePropertiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,unsigned int*,struct VkDisplayModePropertiesKHR*);
enum VkResult(vkAllocateMemory)(struct VkDevice_T*,const struct VkMemoryAllocateInfo*,const struct VkAllocationCallbacks*,struct VkDeviceMemory_T**);
void(vkCmdClearColorImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const union VkClearColorValue*,unsigned int,const struct VkImageSubresourceRange*);
enum VkResult(vkCreateDisplayModeKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayModeCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkDisplayModeKHR_T**);
void(vkCmdBeginDebugUtilsLabelEXT)(struct VkCommandBuffer_T*,const struct VkDebugUtilsLabelEXT*);
void(vkCmdDebugMarkerBeginEXT)(struct VkCommandBuffer_T*,const struct VkDebugMarkerMarkerInfoEXT*);
enum VkResult(vkDebugMarkerSetObjectNameEXT)(struct VkDevice_T*,const struct VkDebugMarkerObjectNameInfoEXT*);
void(vkDestroyImage)(struct VkDevice_T*,struct VkImage_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetFenceFdKHR)(struct VkDevice_T*,const struct VkFenceGetFdInfoKHR*,int*);
enum VkResult(vkCreateDescriptorUpdateTemplateKHR)(struct VkDevice_T*,const struct VkDescriptorUpdateTemplateCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorUpdateTemplate_T**);
enum VkResult(vkDebugMarkerSetObjectTagEXT)(struct VkDevice_T*,const struct VkDebugMarkerObjectTagInfoEXT*);
void(vkCmdDispatch)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int);
enum VkResult(vkResetDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int);
void(vkCmdPushDescriptorSetKHR)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipelineLayout_T*,unsigned int,unsigned int,const struct VkWriteDescriptorSet*);
void(vkUpdateDescriptorSetWithTemplateKHR)(struct VkDevice_T*,struct VkDescriptorSet_T*,struct VkDescriptorUpdateTemplate_T*,const void*);
void(vkDestroyDevice)(struct VkDevice_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkBindImageMemory)(struct VkDevice_T*,struct VkImage_T*,struct VkDeviceMemory_T*,unsigned long);
enum VkResult(vkCreateCommandPool)(struct VkDevice_T*,const struct VkCommandPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkCommandPool_T**);
enum VkResult(vkCreateIndirectCommandsLayoutNVX)(struct VkDevice_T*,const struct VkIndirectCommandsLayoutCreateInfoNVX*,const struct VkAllocationCallbacks*,struct VkIndirectCommandsLayoutNVX_T**);
enum VkResult(vkCreatePipelineLayout)(struct VkDevice_T*,const struct VkPipelineLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineLayout_T**);
enum VkResult(vkEnumerateInstanceVersion)(unsigned int*);
enum VkResult(vkResetCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
void(vkGetBufferMemoryRequirements)(struct VkDevice_T*,struct VkBuffer_T*,struct VkMemoryRequirements*);
enum VkResult(vkDeviceWaitIdle)(struct VkDevice_T*);
enum VkResult(vkBindImageMemory2KHR)(struct VkDevice_T*,unsigned int,const struct VkBindImageMemoryInfo*);
void(vkGetDeviceGroupPeerMemoryFeaturesKHR)(struct VkDevice_T*,unsigned int,unsigned int,unsigned int,unsigned int*);
void(vkCmdSetStencilCompareMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
void(vkDestroySamplerYcbcrConversionKHR)(struct VkDevice_T*,struct VkSamplerYcbcrConversion_T*,const struct VkAllocationCallbacks*);
void(vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)(struct VkPhysicalDevice_T*,struct VkDeviceGeneratedCommandsFeaturesNVX*,struct VkDeviceGeneratedCommandsLimitsNVX*);
void(vkGetRenderAreaGranularity)(struct VkDevice_T*,struct VkRenderPass_T*,struct VkExtent2D*);
void(vkDestroyInstance)(struct VkInstance_T*,const struct VkAllocationCallbacks*);
void(vkGetDeviceQueue2)(struct VkDevice_T*,const struct VkDeviceQueueInfo2*,struct VkQueue_T**);
enum VkResult(vkCreateSamplerYcbcrConversion)(struct VkDevice_T*,const struct VkSamplerYcbcrConversionCreateInfo*,const struct VkAllocationCallbacks*,struct VkSamplerYcbcrConversion_T**);
void(vkGetPhysicalDeviceQueueFamilyProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties*);
void(vkQueueInsertDebugUtilsLabelEXT)(struct VkQueue_T*,const struct VkDebugUtilsLabelEXT*);
void(vkCmdSetDeviceMask)(struct VkCommandBuffer_T*,unsigned int);
void(vkGetBufferMemoryRequirements2)(struct VkDevice_T*,const struct VkBufferMemoryRequirementsInfo2*,struct VkMemoryRequirements2*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilities2EXT)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,struct VkSurfaceCapabilities2EXT*);
void(vkGetPhysicalDeviceMemoryProperties2)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties2*);
void(vkCmdWriteTimestamp)(struct VkCommandBuffer_T*,enum VkPipelineStageFlagBits,struct VkQueryPool_T*,unsigned int);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceImageFormatInfo2*,struct VkImageFormatProperties2*);
void(vkCmdSetViewportWScalingNV)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkViewportWScalingNV*);
enum VkResult(vkCreateShaderModule)(struct VkDevice_T*,const struct VkShaderModuleCreateInfo*,const struct VkAllocationCallbacks*,struct VkShaderModule_T**);
void(vkDestroySurfaceKHR)(struct VkInstance_T*,struct VkSurfaceKHR_T*,const struct VkAllocationCallbacks*);
void(vkCmdCopyQueryPoolResults)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
enum VkResult(vkGetSwapchainCounterEXT)(struct VkDevice_T*,struct VkSwapchainKHR_T*,enum VkSurfaceCounterFlagBitsEXT,unsigned long*);
enum VkResult(vkMergePipelineCaches)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,struct VkPipelineCache_T*const*);
void(vkGetDeviceGroupPeerMemoryFeatures)(struct VkDevice_T*,unsigned int,unsigned int,unsigned int,unsigned int*);
void(vkGetPhysicalDeviceQueueFamilyProperties2KHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties2*);
void(vkCmdSetStencilWriteMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
void(vkDestroyDescriptorUpdateTemplateKHR)(struct VkDevice_T*,struct VkDescriptorUpdateTemplate_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkImportSemaphoreFdKHR)(struct VkDevice_T*,const struct VkImportSemaphoreFdInfoKHR*);
void(vkCmdBindDescriptorSets)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipelineLayout_T*,unsigned int,unsigned int,struct VkDescriptorSet_T*const*,unsigned int,const unsigned int*);
enum VkResult(vkEnumerateInstanceExtensionProperties)(const char*,unsigned int*,struct VkExtensionProperties*);
void(vkCmdDispatchBase)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int);
void(vkCmdSetDepthBounds)(struct VkCommandBuffer_T*,float,float);
enum VkResult(vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,unsigned int,struct VkExternalImageFormatPropertiesNV*);
void(vkDestroyEvent)(struct VkDevice_T*,struct VkEvent_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkBindBufferMemory2)(struct VkDevice_T*,unsigned int,const struct VkBindBufferMemoryInfo*);
void(vkGetPhysicalDeviceProperties2KHR)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties2*);
void(vkDestroyBuffer)(struct VkDevice_T*,struct VkBuffer_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateEvent)(struct VkDevice_T*,const struct VkEventCreateInfo*,const struct VkAllocationCallbacks*,struct VkEvent_T**);
void(vkGetPhysicalDeviceSparseImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkSampleCountFlagBits,unsigned int,enum VkImageTiling,unsigned int*,struct VkSparseImageFormatProperties*);
enum VkResult(vkGetPhysicalDeviceSurfaceFormats2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSurfaceInfo2KHR*,unsigned int*,struct VkSurfaceFormat2KHR*);
void(vkDestroyDebugUtilsMessengerEXT)(struct VkInstance_T*,struct VkDebugUtilsMessengerEXT_T*,const struct VkAllocationCallbacks*);
void(vkSubmitDebugUtilsMessageEXT)(struct VkInstance_T*,enum VkDebugUtilsMessageSeverityFlagBitsEXT,unsigned int,const struct VkDebugUtilsMessengerCallbackDataEXT*);
enum VkResult(vkAllocateCommandBuffers)(struct VkDevice_T*,const struct VkCommandBufferAllocateInfo*,struct VkCommandBuffer_T**);
enum VkResult(vkGetPhysicalDeviceSurfaceFormatsKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,struct VkSurfaceFormatKHR*);
enum VkResult(vkCreateDescriptorPool)(struct VkDevice_T*,const struct VkDescriptorPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorPool_T**);
void(vkGetImageSubresourceLayout)(struct VkDevice_T*,struct VkImage_T*,const struct VkImageSubresource*,struct VkSubresourceLayout*);
void(vkGetPhysicalDeviceExternalFenceProperties)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalFenceInfo*,struct VkExternalFenceProperties*);
void(vkTrimCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
void(vkFreeCommandBuffers)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int,struct VkCommandBuffer_T*const*);
void(vkGetPhysicalDeviceExternalBufferProperties)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceExternalBufferInfo*,struct VkExternalBufferProperties*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,struct VkSurfaceCapabilitiesKHR*);
void(vkDestroyPipeline)(struct VkDevice_T*,struct VkPipeline_T*,const struct VkAllocationCallbacks*);
void(vkCmdDrawIndexedIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
void(vkTrimCommandPoolKHR)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
enum VkResult(vkGetPhysicalDeviceSurfaceSupportKHR)(struct VkPhysicalDevice_T*,unsigned int,struct VkSurfaceKHR_T*,unsigned int*);
enum VkResult(vkCreateSemaphore)(struct VkDevice_T*,const struct VkSemaphoreCreateInfo*,const struct VkAllocationCallbacks*,struct VkSemaphore_T**);
void(vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSparseImageFormatInfo2*,unsigned int*,struct VkSparseImageFormatProperties2*);
void(vkDestroyShaderModule)(struct VkDevice_T*,struct VkShaderModule_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreatePipelineCache)(struct VkDevice_T*,const struct VkPipelineCacheCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineCache_T**);
void(vkGetPhysicalDeviceFeatures)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures*);
void(vkDestroyPipelineLayout)(struct VkDevice_T*,struct VkPipelineLayout_T*,const struct VkAllocationCallbacks*);
void(vkDestroySampler)(struct VkDevice_T*,struct VkSampler_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateDebugReportCallbackEXT)(struct VkInstance_T*,const struct VkDebugReportCallbackCreateInfoEXT*,const struct VkAllocationCallbacks*,struct VkDebugReportCallbackEXT_T**);
enum VkResult(vkGetPhysicalDevicePresentRectanglesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,struct VkRect2D*);
enum VkResult(vkMapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long,unsigned long,unsigned int,void**);
void(vkDestroyFramebuffer)(struct VkDevice_T*,struct VkFramebuffer_T*,const struct VkAllocationCallbacks*);
void(vkGetDeviceMemoryCommitment)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long*);
void(vkCmdWriteBufferMarkerAMD)(struct VkCommandBuffer_T*,enum VkPipelineStageFlagBits,struct VkBuffer_T*,unsigned long,unsigned int);
enum VkResult(vkGetMemoryHostPointerPropertiesEXT)(struct VkDevice_T*,enum VkExternalMemoryHandleTypeFlagBits,const void*,struct VkMemoryHostPointerPropertiesEXT*);
void(vkCmdPushDescriptorSetWithTemplateKHR)(struct VkCommandBuffer_T*,struct VkDescriptorUpdateTemplate_T*,struct VkPipelineLayout_T*,unsigned int,const void*);
enum VkResult(vkGetValidationCacheDataEXT)(struct VkDevice_T*,struct VkValidationCacheEXT_T*,unsigned long*,void*);
enum VkResult(vkCreateSamplerYcbcrConversionKHR)(struct VkDevice_T*,const struct VkSamplerYcbcrConversionCreateInfo*,const struct VkAllocationCallbacks*,struct VkSamplerYcbcrConversion_T**);
void(vkCmdBindIndexBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,enum VkIndexType);
void(vkDestroyValidationCacheEXT)(struct VkDevice_T*,struct VkValidationCacheEXT_T*,const struct VkAllocationCallbacks*);
void(vkCmdInsertDebugUtilsLabelEXT)(struct VkCommandBuffer_T*,const struct VkDebugUtilsLabelEXT*);
enum VkResult(vkGetSemaphoreFdKHR)(struct VkDevice_T*,const struct VkSemaphoreGetFdInfoKHR*,int*);
void(vkCmdEndDebugUtilsLabelEXT)(struct VkCommandBuffer_T*);
void(*vkGetDeviceProcAddr(struct VkDevice_T*,const char*))();
void(vkDestroyBufferView)(struct VkDevice_T*,struct VkBufferView_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumerateDeviceLayerProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkLayerProperties*);
enum VkResult(vkCreateDisplayPlaneSurfaceKHR)(struct VkInstance_T*,const struct VkDisplaySurfaceCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSurfaceKHR_T**);
enum VkResult(vkResetCommandBuffer)(struct VkCommandBuffer_T*,unsigned int);
void(vkCmdDrawIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
void(vkCmdSetViewport)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkViewport*);
void(vkCmdSetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
void(vkDestroyDescriptorUpdateTemplate)(struct VkDevice_T*,struct VkDescriptorUpdateTemplate_T*,const struct VkAllocationCallbacks*);
void(vkCmdDispatchBaseKHR)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int);
void(vkCmdResetQueryPool)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
enum VkResult(vkAcquireNextImageKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned long,struct VkSemaphore_T*,struct VkFence_T*,unsigned int*);
void(vkGetImageMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,struct VkMemoryRequirements*);
enum VkResult(vkQueueBindSparse)(struct VkQueue_T*,unsigned int,const struct VkBindSparseInfo*,struct VkFence_T*);
enum VkResult(vkSetEvent)(struct VkDevice_T*,struct VkEvent_T*);
void(vkCmdSetScissor)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkRect2D*);
void(vkCmdEndQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int);
void(vkGetPhysicalDeviceMemoryProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties*);
enum VkResult(vkCreateBuffer)(struct VkDevice_T*,const struct VkBufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkBuffer_T**);
enum VkResult(vkCreateInstance)(const struct VkInstanceCreateInfo*,const struct VkAllocationCallbacks*,struct VkInstance_T**);
void(vkCmdClearDepthStencilImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const struct VkClearDepthStencilValue*,unsigned int,const struct VkImageSubresourceRange*);
void(vkCmdDraw)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int);
void(vkDestroySwapchainKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilities2KHR)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceSurfaceInfo2KHR*,struct VkSurfaceCapabilities2KHR*);
void(vkCmdDrawIndexed)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,int,unsigned int);
enum VkResult(vkFreeDescriptorSets)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int,struct VkDescriptorSet_T*const*);
void(vkGetBufferMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkBufferMemoryRequirementsInfo2*,struct VkMemoryRequirements2*);
enum VkResult(vkCreateRenderPass)(struct VkDevice_T*,const struct VkRenderPassCreateInfo*,const struct VkAllocationCallbacks*,struct VkRenderPass_T**);
enum VkResult(vkCreateImageView)(struct VkDevice_T*,const struct VkImageViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkImageView_T**);
void(vkGetDeviceQueue)(struct VkDevice_T*,unsigned int,unsigned int,struct VkQueue_T**);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties2)(struct VkPhysicalDevice_T*,const struct VkPhysicalDeviceImageFormatInfo2*,struct VkImageFormatProperties2*);
void(vkDestroyDescriptorSetLayout)(struct VkDevice_T*,struct VkDescriptorSetLayout_T*,const struct VkAllocationCallbacks*);
void(vkCmdWaitEvents)(struct VkCommandBuffer_T*,unsigned int,struct VkEvent_T*const*,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
enum VkResult(vkGetMemoryFdPropertiesKHR)(struct VkDevice_T*,enum VkExternalMemoryHandleTypeFlagBits,int,struct VkMemoryFdPropertiesKHR*);
enum VkResult(vkGetDeviceGroupPresentCapabilitiesKHR)(struct VkDevice_T*,struct VkDeviceGroupPresentCapabilitiesKHR*);
void(vkCmdEndRenderPass)(struct VkCommandBuffer_T*);
void(vkDestroyDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,const struct VkAllocationCallbacks*);
void(vkGetPhysicalDeviceFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties*);
void(vkDestroyFence)(struct VkDevice_T*,struct VkFence_T*,const struct VkAllocationCallbacks*);
void(vkCmdBindPipeline)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipeline_T*);
enum VkResult(vkGetSwapchainImagesKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned int*,struct VkImage_T**);
enum VkResult(vkCreateDescriptorUpdateTemplate)(struct VkDevice_T*,const struct VkDescriptorUpdateTemplateCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorUpdateTemplate_T**);
enum VkResult(vkCreateSwapchainKHR)(struct VkDevice_T*,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
void(vkDestroyRenderPass)(struct VkDevice_T*,struct VkRenderPass_T*,const struct VkAllocationCallbacks*);
void(vkGetDescriptorSetLayoutSupport)(struct VkDevice_T*,const struct VkDescriptorSetLayoutCreateInfo*,struct VkDescriptorSetLayoutSupport*);
void(vkQueueBeginDebugUtilsLabelEXT)(struct VkQueue_T*,const struct VkDebugUtilsLabelEXT*);
void(vkGetPhysicalDeviceFeatures2)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures2*);
enum VkResult(vkMergeValidationCachesEXT)(struct VkDevice_T*,struct VkValidationCacheEXT_T*,unsigned int,struct VkValidationCacheEXT_T*const*);
enum VkResult(vkBindImageMemory2)(struct VkDevice_T*,unsigned int,const struct VkBindImageMemoryInfo*);
void(vkCmdClearAttachments)(struct VkCommandBuffer_T*,unsigned int,const struct VkClearAttachment*,unsigned int,const struct VkClearRect*);
enum VkResult(vkCreateFence)(struct VkDevice_T*,const struct VkFenceCreateInfo*,const struct VkAllocationCallbacks*,struct VkFence_T**);
void(vkCmdExecuteCommands)(struct VkCommandBuffer_T*,unsigned int,struct VkCommandBuffer_T*const*);
enum VkResult(vkEnumeratePhysicalDeviceGroups)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDeviceGroupProperties*);
void(vkCmdBeginRenderPass)(struct VkCommandBuffer_T*,const struct VkRenderPassBeginInfo*,enum VkSubpassContents);
void(vkGetImageMemoryRequirements2)(struct VkDevice_T*,const struct VkImageMemoryRequirementsInfo2*,struct VkMemoryRequirements2*);
enum VkResult(vkReleaseDisplayEXT)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*);
void(vkGetPhysicalDeviceQueueFamilyProperties2)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties2*);
enum VkResult(vkUnregisterObjectsNVX)(struct VkDevice_T*,struct VkObjectTableNVX_T*,unsigned int,const enum VkObjectEntryTypeNVX*,const unsigned int*);
void(vkCmdDrawIndexedIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPlanePropertiesKHR*);
enum VkResult(vkBeginCommandBuffer)(struct VkCommandBuffer_T*,const struct VkCommandBufferBeginInfo*);
enum VkResult(vkCreateDevice)(struct VkPhysicalDevice_T*,const struct VkDeviceCreateInfo*,const struct VkAllocationCallbacks*,struct VkDevice_T**);
void(vkUpdateDescriptorSetWithTemplate)(struct VkDevice_T*,struct VkDescriptorSet_T*,struct VkDescriptorUpdateTemplate_T*,const void*);
enum VkResult(vkGetPhysicalDeviceSurfacePresentModesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,enum VkPresentModeKHR*);
void(*vkGetInstanceProcAddr(struct VkInstance_T*,const char*))();
void(vkUnmapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*);
void(vkGetImageMemoryRequirements2KHR)(struct VkDevice_T*,const struct VkImageMemoryRequirementsInfo2*,struct VkMemoryRequirements2*);
enum VkResult(vkEnumerateDeviceExtensionProperties)(struct VkPhysicalDevice_T*,const char*,unsigned int*,struct VkExtensionProperties*);
enum VkResult(vkQueuePresentKHR)(struct VkQueue_T*,const struct VkPresentInfoKHR*);
void(vkSetHdrMetadataEXT)(struct VkDevice_T*,unsigned int,struct VkSwapchainKHR_T*const*,const struct VkHdrMetadataEXT*);
enum VkResult(vkInvalidateMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
enum VkResult(vkGetDeviceGroupSurfacePresentModesKHR)(struct VkDevice_T*,struct VkSurfaceKHR_T*,unsigned int*);
enum VkResult(vkAcquireNextImage2KHR)(struct VkDevice_T*,const struct VkAcquireNextImageInfoKHR*,unsigned int*);
enum VkResult(vkWaitForFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*,unsigned int,unsigned long);
void(vkCmdSetLineWidth)(struct VkCommandBuffer_T*,float);
void(vkCmdSetDiscardRectangleEXT)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkRect2D*);
enum VkResult(vkCreateSharedSwapchainsKHR)(struct VkDevice_T*,unsigned int,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
void(vkFreeMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkFlushMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
void(vkDestroySamplerYcbcrConversion)(struct VkDevice_T*,struct VkSamplerYcbcrConversion_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumeratePhysicalDeviceGroupsKHR)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDeviceGroupProperties*);
void(vkGetImageSparseMemoryRequirements2)(struct VkDevice_T*,const struct VkImageSparseMemoryRequirementsInfo2*,unsigned int*,struct VkSparseImageMemoryRequirements2*);
void(vkDestroyPipelineCache)(struct VkDevice_T*,struct VkPipelineCache_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkRegisterDeviceEventEXT)(struct VkDevice_T*,const struct VkDeviceEventInfoEXT*,const struct VkAllocationCallbacks*,struct VkFence_T**);
void(vkDestroySemaphore)(struct VkDevice_T*,struct VkSemaphore_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkAllocateDescriptorSets)(struct VkDevice_T*,const struct VkDescriptorSetAllocateInfo*,struct VkDescriptorSet_T**);
enum VkResult(vkGetPhysicalDeviceDisplayPropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPropertiesKHR*);
void(vkCmdCopyImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageCopy*);
enum VkResult(vkGetShaderInfoAMD)(struct VkDevice_T*,struct VkPipeline_T*,enum VkShaderStageFlagBits,enum VkShaderInfoTypeAMD,unsigned long*,void*);
void(vkUpdateDescriptorSets)(struct VkDevice_T*,unsigned int,const struct VkWriteDescriptorSet*,unsigned int,const struct VkCopyDescriptorSet*);
enum VkResult(vkGetQueryPoolResults)(struct VkDevice_T*,struct VkQueryPool_T*,unsigned int,unsigned int,unsigned long,void*,unsigned long,unsigned int);
void(vkCmdPipelineBarrier)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
void(vkDebugReportMessageEXT)(struct VkInstance_T*,unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*);
enum VkResult(vkDisplayPowerControlEXT)(struct VkDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayPowerInfoEXT*);
]])
local library = {}

--====helper safe_clib_index====
function SAFE_INDEX(clib)
	return setmetatable(
		{},
		{
			__index = function(_, k)
				local ok, val = pcall(function()
					return clib[k]
				end)

				if ok then
					return val
				elseif clib_index then
					return clib_index(k)
				end
			end,
		}
	)
end

CLIB = SAFE_INDEX(CLIB)
--====helper safe_clib_index====
library = {
	CreateBufferView = CLIB.vkCreateBufferView,
	CmdCopyImageToBuffer = CLIB.vkCmdCopyImageToBuffer,
	CmdResolveImage = CLIB.vkCmdResolveImage,
	CreateGraphicsPipelines = CLIB.vkCreateGraphicsPipelines,
	GetPipelineCacheData = CLIB.vkGetPipelineCacheData,
	EnumerateInstanceLayerProperties = CLIB.vkEnumerateInstanceLayerProperties,
	ResetEvent = CLIB.vkResetEvent,
	QueueWaitIdle = CLIB.vkQueueWaitIdle,
	GetPhysicalDeviceExternalSemaphoreProperties = CLIB.vkGetPhysicalDeviceExternalSemaphoreProperties,
	EnumeratePhysicalDevices = CLIB.vkEnumeratePhysicalDevices,
	ResetFences = CLIB.vkResetFences,
	CreateFramebuffer = CLIB.vkCreateFramebuffer,
	CmdResetEvent = CLIB.vkCmdResetEvent,
	BindBufferMemory = CLIB.vkBindBufferMemory,
	GetPhysicalDeviceProperties2 = CLIB.vkGetPhysicalDeviceProperties2,
	EndCommandBuffer = CLIB.vkEndCommandBuffer,
	GetPhysicalDeviceProperties = CLIB.vkGetPhysicalDeviceProperties,
	CmdDispatchIndirect = CLIB.vkCmdDispatchIndirect,
	CmdNextSubpass = CLIB.vkCmdNextSubpass,
	CmdCopyBuffer = CLIB.vkCmdCopyBuffer,
	CreateComputePipelines = CLIB.vkCreateComputePipelines,
	CreateDescriptorSetLayout = CLIB.vkCreateDescriptorSetLayout,
	DestroyQueryPool = CLIB.vkDestroyQueryPool,
	CmdUpdateBuffer = CLIB.vkCmdUpdateBuffer,
	CmdSetStencilReference = CLIB.vkCmdSetStencilReference,
	CreateQueryPool = CLIB.vkCreateQueryPool,
	GetFenceStatus = CLIB.vkGetFenceStatus,
	CmdBeginQuery = CLIB.vkCmdBeginQuery,
	QueueSubmit = CLIB.vkQueueSubmit,
	CmdBlitImage = CLIB.vkCmdBlitImage,
	CmdSetDepthBias = CLIB.vkCmdSetDepthBias,
	GetPhysicalDeviceImageFormatProperties = CLIB.vkGetPhysicalDeviceImageFormatProperties,
	CmdPushConstants = CLIB.vkCmdPushConstants,
	CmdCopyBufferToImage = CLIB.vkCmdCopyBufferToImage,
	CmdBindVertexBuffers = CLIB.vkCmdBindVertexBuffers,
	GetPhysicalDeviceFormatProperties2 = CLIB.vkGetPhysicalDeviceFormatProperties2,
	DestroyCommandPool = CLIB.vkDestroyCommandPool,
	CreateSampler = CLIB.vkCreateSampler,
	CmdSetBlendConstants = CLIB.vkCmdSetBlendConstants,
	GetImageSparseMemoryRequirements = CLIB.vkGetImageSparseMemoryRequirements,
	DestroyImageView = CLIB.vkDestroyImageView,
	GetEventStatus = CLIB.vkGetEventStatus,
	CmdFillBuffer = CLIB.vkCmdFillBuffer,
	GetPhysicalDeviceSparseImageFormatProperties2 = CLIB.vkGetPhysicalDeviceSparseImageFormatProperties2,
	CreateImage = CLIB.vkCreateImage,
	AllocateMemory = CLIB.vkAllocateMemory,
	CmdClearColorImage = CLIB.vkCmdClearColorImage,
	DestroyImage = CLIB.vkDestroyImage,
	CmdDispatch = CLIB.vkCmdDispatch,
	ResetDescriptorPool = CLIB.vkResetDescriptorPool,
	DestroyDevice = CLIB.vkDestroyDevice,
	BindImageMemory = CLIB.vkBindImageMemory,
	CreateCommandPool = CLIB.vkCreateCommandPool,
	CreatePipelineLayout = CLIB.vkCreatePipelineLayout,
	EnumerateInstanceVersion = CLIB.vkEnumerateInstanceVersion,
	ResetCommandPool = CLIB.vkResetCommandPool,
	GetBufferMemoryRequirements = CLIB.vkGetBufferMemoryRequirements,
	DeviceWaitIdle = CLIB.vkDeviceWaitIdle,
	CmdSetStencilCompareMask = CLIB.vkCmdSetStencilCompareMask,
	GetRenderAreaGranularity = CLIB.vkGetRenderAreaGranularity,
	DestroyInstance = CLIB.vkDestroyInstance,
	GetDeviceQueue2 = CLIB.vkGetDeviceQueue2,
	CreateSamplerYcbcrConversion = CLIB.vkCreateSamplerYcbcrConversion,
	GetPhysicalDeviceQueueFamilyProperties = CLIB.vkGetPhysicalDeviceQueueFamilyProperties,
	CmdSetDeviceMask = CLIB.vkCmdSetDeviceMask,
	GetBufferMemoryRequirements2 = CLIB.vkGetBufferMemoryRequirements2,
	GetPhysicalDeviceMemoryProperties2 = CLIB.vkGetPhysicalDeviceMemoryProperties2,
	CmdWriteTimestamp = CLIB.vkCmdWriteTimestamp,
	CreateShaderModule = CLIB.vkCreateShaderModule,
	CmdCopyQueryPoolResults = CLIB.vkCmdCopyQueryPoolResults,
	MergePipelineCaches = CLIB.vkMergePipelineCaches,
	GetDeviceGroupPeerMemoryFeatures = CLIB.vkGetDeviceGroupPeerMemoryFeatures,
	CmdSetStencilWriteMask = CLIB.vkCmdSetStencilWriteMask,
	CmdBindDescriptorSets = CLIB.vkCmdBindDescriptorSets,
	EnumerateInstanceExtensionProperties = CLIB.vkEnumerateInstanceExtensionProperties,
	CmdDispatchBase = CLIB.vkCmdDispatchBase,
	CmdSetDepthBounds = CLIB.vkCmdSetDepthBounds,
	DestroyEvent = CLIB.vkDestroyEvent,
	BindBufferMemory2 = CLIB.vkBindBufferMemory2,
	DestroyBuffer = CLIB.vkDestroyBuffer,
	CreateEvent = CLIB.vkCreateEvent,
	GetPhysicalDeviceSparseImageFormatProperties = CLIB.vkGetPhysicalDeviceSparseImageFormatProperties,
	AllocateCommandBuffers = CLIB.vkAllocateCommandBuffers,
	CreateDescriptorPool = CLIB.vkCreateDescriptorPool,
	GetImageSubresourceLayout = CLIB.vkGetImageSubresourceLayout,
	GetPhysicalDeviceExternalFenceProperties = CLIB.vkGetPhysicalDeviceExternalFenceProperties,
	TrimCommandPool = CLIB.vkTrimCommandPool,
	FreeCommandBuffers = CLIB.vkFreeCommandBuffers,
	GetPhysicalDeviceExternalBufferProperties = CLIB.vkGetPhysicalDeviceExternalBufferProperties,
	DestroyPipeline = CLIB.vkDestroyPipeline,
	CmdDrawIndexedIndirect = CLIB.vkCmdDrawIndexedIndirect,
	CreateSemaphore = CLIB.vkCreateSemaphore,
	DestroyShaderModule = CLIB.vkDestroyShaderModule,
	CreatePipelineCache = CLIB.vkCreatePipelineCache,
	GetPhysicalDeviceFeatures = CLIB.vkGetPhysicalDeviceFeatures,
	DestroyPipelineLayout = CLIB.vkDestroyPipelineLayout,
	DestroySampler = CLIB.vkDestroySampler,
	MapMemory = CLIB.vkMapMemory,
	DestroyFramebuffer = CLIB.vkDestroyFramebuffer,
	GetDeviceMemoryCommitment = CLIB.vkGetDeviceMemoryCommitment,
	CmdBindIndexBuffer = CLIB.vkCmdBindIndexBuffer,
	GetDeviceProcAddr = CLIB.vkGetDeviceProcAddr,
	DestroyBufferView = CLIB.vkDestroyBufferView,
	EnumerateDeviceLayerProperties = CLIB.vkEnumerateDeviceLayerProperties,
	ResetCommandBuffer = CLIB.vkResetCommandBuffer,
	CmdDrawIndirect = CLIB.vkCmdDrawIndirect,
	CmdSetViewport = CLIB.vkCmdSetViewport,
	CmdSetEvent = CLIB.vkCmdSetEvent,
	DestroyDescriptorUpdateTemplate = CLIB.vkDestroyDescriptorUpdateTemplate,
	CmdResetQueryPool = CLIB.vkCmdResetQueryPool,
	GetImageMemoryRequirements = CLIB.vkGetImageMemoryRequirements,
	QueueBindSparse = CLIB.vkQueueBindSparse,
	SetEvent = CLIB.vkSetEvent,
	CmdSetScissor = CLIB.vkCmdSetScissor,
	CmdEndQuery = CLIB.vkCmdEndQuery,
	GetPhysicalDeviceMemoryProperties = CLIB.vkGetPhysicalDeviceMemoryProperties,
	CreateBuffer = CLIB.vkCreateBuffer,
	CreateInstance = CLIB.vkCreateInstance,
	CmdClearDepthStencilImage = CLIB.vkCmdClearDepthStencilImage,
	CmdDraw = CLIB.vkCmdDraw,
	CmdDrawIndexed = CLIB.vkCmdDrawIndexed,
	FreeDescriptorSets = CLIB.vkFreeDescriptorSets,
	CreateRenderPass = CLIB.vkCreateRenderPass,
	CreateImageView = CLIB.vkCreateImageView,
	GetDeviceQueue = CLIB.vkGetDeviceQueue,
	GetPhysicalDeviceImageFormatProperties2 = CLIB.vkGetPhysicalDeviceImageFormatProperties2,
	DestroyDescriptorSetLayout = CLIB.vkDestroyDescriptorSetLayout,
	CmdWaitEvents = CLIB.vkCmdWaitEvents,
	CmdEndRenderPass = CLIB.vkCmdEndRenderPass,
	DestroyDescriptorPool = CLIB.vkDestroyDescriptorPool,
	GetPhysicalDeviceFormatProperties = CLIB.vkGetPhysicalDeviceFormatProperties,
	DestroyFence = CLIB.vkDestroyFence,
	CmdBindPipeline = CLIB.vkCmdBindPipeline,
	CreateDescriptorUpdateTemplate = CLIB.vkCreateDescriptorUpdateTemplate,
	DestroyRenderPass = CLIB.vkDestroyRenderPass,
	GetDescriptorSetLayoutSupport = CLIB.vkGetDescriptorSetLayoutSupport,
	GetPhysicalDeviceFeatures2 = CLIB.vkGetPhysicalDeviceFeatures2,
	BindImageMemory2 = CLIB.vkBindImageMemory2,
	CmdClearAttachments = CLIB.vkCmdClearAttachments,
	CreateFence = CLIB.vkCreateFence,
	CmdExecuteCommands = CLIB.vkCmdExecuteCommands,
	EnumeratePhysicalDeviceGroups = CLIB.vkEnumeratePhysicalDeviceGroups,
	CmdBeginRenderPass = CLIB.vkCmdBeginRenderPass,
	GetImageMemoryRequirements2 = CLIB.vkGetImageMemoryRequirements2,
	GetPhysicalDeviceQueueFamilyProperties2 = CLIB.vkGetPhysicalDeviceQueueFamilyProperties2,
	BeginCommandBuffer = CLIB.vkBeginCommandBuffer,
	CreateDevice = CLIB.vkCreateDevice,
	UpdateDescriptorSetWithTemplate = CLIB.vkUpdateDescriptorSetWithTemplate,
	GetInstanceProcAddr = CLIB.vkGetInstanceProcAddr,
	UnmapMemory = CLIB.vkUnmapMemory,
	EnumerateDeviceExtensionProperties = CLIB.vkEnumerateDeviceExtensionProperties,
	InvalidateMappedMemoryRanges = CLIB.vkInvalidateMappedMemoryRanges,
	WaitForFences = CLIB.vkWaitForFences,
	CmdSetLineWidth = CLIB.vkCmdSetLineWidth,
	FreeMemory = CLIB.vkFreeMemory,
	FlushMappedMemoryRanges = CLIB.vkFlushMappedMemoryRanges,
	DestroySamplerYcbcrConversion = CLIB.vkDestroySamplerYcbcrConversion,
	GetImageSparseMemoryRequirements2 = CLIB.vkGetImageSparseMemoryRequirements2,
	DestroyPipelineCache = CLIB.vkDestroyPipelineCache,
	DestroySemaphore = CLIB.vkDestroySemaphore,
	AllocateDescriptorSets = CLIB.vkAllocateDescriptorSets,
	CmdCopyImage = CLIB.vkCmdCopyImage,
	UpdateDescriptorSets = CLIB.vkUpdateDescriptorSets,
	GetQueryPoolResults = CLIB.vkGetQueryPoolResults,
	CmdPipelineBarrier = CLIB.vkCmdPipelineBarrier,
}
library.util = {}

function library.util.StringList(tbl)
	return ffi.new("const char * const [" .. #tbl .. "]", tbl), #tbl
end

function library.util.GLSLToSpirV(type, glsl)
	local glsl_name = os.tmpname() .. "." .. type
	local spirv_name = os.tmpname()
	local temp
	temp = io.open(glsl_name, "wb")
	temp:write(glsl)
	temp:close()
	local msg = io.popen("glslangValidator -V -o " .. spirv_name .. " " .. glsl_name):read("*all")
	temp = io.open(spirv_name, "rb")
	local spirv = temp:read("*all")
	temp:close()

	if msg:find("ERROR") then error(msg, 2) end

	return {pCode = ffi.cast("uint32_t *", spirv), codeSize = #spirv}
end

function library.Assert(var, res)
	if var == nil and res ~= "VK_SUCCESS" then
		for name, v in pairs(library.e.result) do
			if res == v then
				name = name:gsub("error_", "")
				name = name:gsub("_", " ")
				error("Assertion failed: " .. name, 2)

				break
			end
		end
	end

	return var
end

function library.e(str_enum)
	return ffi.cast("enum GLFWenum", str_enum)
end

library.struct_gc = setmetatable({}, {__mode = "k"})
library.macros = {}
library.macros.MAKE_VERSION = function(major, minor, patch)
	return bit.bor(bit.lshift(major, 22), bit.lshift(minor, 12), patch)
end
local extensions = {}
extensions.vkGetPhysicalDeviceMultisamplePropertiesEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , enum VkSampleCountFlagBits , struct VkMultisamplePropertiesEXT * )"
	),
}
extensions.vkDestroyObjectTableNVX = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkSetDebugUtilsObjectTagEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDebugUtilsObjectTagInfoEXT * )"
	),
}
extensions.vkRegisterDisplayEventEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayEventInfoEXT * , const struct VkAllocationCallbacks * , struct VkFence_T * * )"
	),
}
extensions.vkImportFenceFdKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkImportFenceFdInfoKHR * )"
	),
}
extensions.vkGetPhysicalDeviceFormatProperties2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , enum VkFormat , struct VkFormatProperties2 * )"
	),
}
extensions.vkGetRefreshCycleDurationGOOGLE = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , struct VkRefreshCycleDurationGOOGLE * )"
	),
}
extensions.vkSetDebugUtilsObjectNameEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDebugUtilsObjectNameInfoEXT * )"
	),
}
extensions.vkGetMemoryFdKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkMemoryGetFdInfoKHR * , int * )"
	),
}
extensions.vkBindBufferMemory2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkBindBufferMemoryInfo * )"
	),
}
extensions.vkGetDescriptorSetLayoutSupportKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , const struct VkDescriptorSetLayoutCreateInfo * , struct VkDescriptorSetLayoutSupport * )"
	),
}
extensions.vkRegisterObjectsNVX = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , unsigned int , const struct VkObjectTableEntryNVX * const * , const unsigned int * )"
	),
}
extensions.vkCmdDrawIndirectCountAMD = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )"
	),
}
extensions.vkGetDisplayPlaneSupportedDisplaysKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , unsigned int * , struct VkDisplayKHR_T * * )"
	),
}
extensions.vkCreateValidationCacheEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkValidationCacheCreateInfoEXT * , const struct VkAllocationCallbacks * , struct VkValidationCacheEXT_T * * )"
	),
}
extensions.vkGetSwapchainStatusKHR = {
	ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * )"),
}
extensions.vkCreateDebugUtilsMessengerEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkInstance_T * , const struct VkDebugUtilsMessengerCreateInfoEXT * , const struct VkAllocationCallbacks * , struct VkDebugUtilsMessengerEXT_T * * )"
	),
}
extensions.vkDestroyIndirectCommandsLayoutNVX = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkIndirectCommandsLayoutNVX_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkGetPhysicalDeviceMemoryProperties2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceMemoryProperties2 * )"
	),
}
extensions.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalSemaphoreInfo * , struct VkExternalSemaphoreProperties * )"
	),
}
extensions.vkCmdDebugMarkerEndEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * )")}
extensions.vkDestroyDebugReportCallbackEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkInstance_T * , struct VkDebugReportCallbackEXT_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkGetImageSparseMemoryRequirements2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , const struct VkImageSparseMemoryRequirementsInfo2 * , unsigned int * , struct VkSparseImageMemoryRequirements2 * )"
	),
}
extensions.vkCmdProcessCommandsNVX = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , const struct VkCmdProcessCommandsInfoNVX * )"
	),
}
extensions.vkGetPhysicalDeviceFeatures2KHR = {
	ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceFeatures2 * )"),
}
extensions.vkGetPhysicalDeviceExternalBufferPropertiesKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalBufferInfo * , struct VkExternalBufferProperties * )"
	),
}
extensions.vkCmdSetSampleLocationsEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , const struct VkSampleLocationsInfoEXT * )"
	),
}
extensions.vkGetPhysicalDeviceExternalFencePropertiesKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceExternalFenceInfo * , struct VkExternalFenceProperties * )"
	),
}
extensions.vkCreateObjectTableNVX = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkObjectTableCreateInfoNVX * , const struct VkAllocationCallbacks * , struct VkObjectTableNVX_T * * )"
	),
}
extensions.vkGetPastPresentationTimingGOOGLE = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned int * , struct VkPastPresentationTimingGOOGLE * )"
	),
}
extensions.vkGetDisplayPlaneCapabilitiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayModeKHR_T * , unsigned int , struct VkDisplayPlaneCapabilitiesKHR * )"
	),
}
extensions.vkQueueEndDebugUtilsLabelEXT = {ctype = ffi.typeof("void(* )( struct VkQueue_T * )")}
extensions.vkCmdSetDeviceMaskKHR = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , unsigned int )")}
extensions.vkCmdDebugMarkerInsertEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , const struct VkDebugMarkerMarkerInfoEXT * )"
	),
}
extensions.vkCmdReserveSpaceForCommandsNVX = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , const struct VkCmdReserveSpaceForCommandsInfoNVX * )"
	),
}
extensions.vkGetDisplayModePropertiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , unsigned int * , struct VkDisplayModePropertiesKHR * )"
	),
}
extensions.vkCreateDisplayModeKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayModeCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkDisplayModeKHR_T * * )"
	),
}
extensions.vkCmdBeginDebugUtilsLabelEXT = {
	ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkDebugUtilsLabelEXT * )"),
}
extensions.vkCmdDebugMarkerBeginEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , const struct VkDebugMarkerMarkerInfoEXT * )"
	),
}
extensions.vkDebugMarkerSetObjectNameEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDebugMarkerObjectNameInfoEXT * )"
	),
}
extensions.vkGetFenceFdKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkFenceGetFdInfoKHR * , int * )"
	),
}
extensions.vkCreateDescriptorUpdateTemplateKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDescriptorUpdateTemplateCreateInfo * , const struct VkAllocationCallbacks * , struct VkDescriptorUpdateTemplate_T * * )"
	),
}
extensions.vkDebugMarkerSetObjectTagEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDebugMarkerObjectTagInfoEXT * )"
	),
}
extensions.vkCmdPushDescriptorSetKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , enum VkPipelineBindPoint , struct VkPipelineLayout_T * , unsigned int , unsigned int , const struct VkWriteDescriptorSet * )"
	),
}
extensions.vkUpdateDescriptorSetWithTemplateKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkDescriptorSet_T * , struct VkDescriptorUpdateTemplate_T * , const void * )"
	),
}
extensions.vkCreateIndirectCommandsLayoutNVX = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkIndirectCommandsLayoutCreateInfoNVX * , const struct VkAllocationCallbacks * , struct VkIndirectCommandsLayoutNVX_T * * )"
	),
}
extensions.vkBindImageMemory2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkBindImageMemoryInfo * )"
	),
}
extensions.vkGetDeviceGroupPeerMemoryFeaturesKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , unsigned int , unsigned int , unsigned int , unsigned int * )"
	),
}
extensions.vkDestroySamplerYcbcrConversionKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkSamplerYcbcrConversion_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , struct VkDeviceGeneratedCommandsFeaturesNVX * , struct VkDeviceGeneratedCommandsLimitsNVX * )"
	),
}
extensions.vkQueueInsertDebugUtilsLabelEXT = {
	ctype = ffi.typeof("void(* )( struct VkQueue_T * , const struct VkDebugUtilsLabelEXT * )"),
}
extensions.vkGetPhysicalDeviceSurfaceCapabilities2EXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , struct VkSurfaceCapabilities2EXT * )"
	),
}
extensions.vkGetPhysicalDeviceImageFormatProperties2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceImageFormatInfo2 * , struct VkImageFormatProperties2 * )"
	),
}
extensions.vkCmdSetViewportWScalingNV = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , const struct VkViewportWScalingNV * )"
	),
}
extensions.vkDestroySurfaceKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkInstance_T * , struct VkSurfaceKHR_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkGetSwapchainCounterEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , enum VkSurfaceCounterFlagBitsEXT , unsigned long * )"
	),
}
extensions.vkGetPhysicalDeviceQueueFamilyProperties2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkQueueFamilyProperties2 * )"
	),
}
extensions.vkDestroyDescriptorUpdateTemplateKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkDescriptorUpdateTemplate_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkImportSemaphoreFdKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkImportSemaphoreFdInfoKHR * )"
	),
}
extensions.vkGetPhysicalDeviceExternalImageFormatPropertiesNV = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , enum VkFormat , enum VkImageType , enum VkImageTiling , unsigned int , unsigned int , unsigned int , struct VkExternalImageFormatPropertiesNV * )"
	),
}
extensions.vkGetPhysicalDeviceProperties2KHR = {
	ctype = ffi.typeof("void(* )( struct VkPhysicalDevice_T * , struct VkPhysicalDeviceProperties2 * )"),
}
extensions.vkGetPhysicalDeviceSurfaceFormats2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSurfaceInfo2KHR * , unsigned int * , struct VkSurfaceFormat2KHR * )"
	),
}
extensions.vkDestroyDebugUtilsMessengerEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkInstance_T * , struct VkDebugUtilsMessengerEXT_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkSubmitDebugUtilsMessageEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkInstance_T * , enum VkDebugUtilsMessageSeverityFlagBitsEXT , unsigned int , const struct VkDebugUtilsMessengerCallbackDataEXT * )"
	),
}
extensions.vkGetPhysicalDeviceSurfaceFormatsKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , struct VkSurfaceFormatKHR * )"
	),
}
extensions.vkGetPhysicalDeviceSurfaceCapabilitiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , struct VkSurfaceCapabilitiesKHR * )"
	),
}
extensions.vkTrimCommandPoolKHR = {
	ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkCommandPool_T * , unsigned int )"),
}
extensions.vkGetPhysicalDeviceSurfaceSupportKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , struct VkSurfaceKHR_T * , unsigned int * )"
	),
}
extensions.vkGetPhysicalDeviceSparseImageFormatProperties2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSparseImageFormatInfo2 * , unsigned int * , struct VkSparseImageFormatProperties2 * )"
	),
}
extensions.vkCreateDebugReportCallbackEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkInstance_T * , const struct VkDebugReportCallbackCreateInfoEXT * , const struct VkAllocationCallbacks * , struct VkDebugReportCallbackEXT_T * * )"
	),
}
extensions.vkGetPhysicalDevicePresentRectanglesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , struct VkRect2D * )"
	),
}
extensions.vkCmdWriteBufferMarkerAMD = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , enum VkPipelineStageFlagBits , struct VkBuffer_T * , unsigned long , unsigned int )"
	),
}
extensions.vkGetMemoryHostPointerPropertiesEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , enum VkExternalMemoryHandleTypeFlagBits , const void * , struct VkMemoryHostPointerPropertiesEXT * )"
	),
}
extensions.vkCmdPushDescriptorSetWithTemplateKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , struct VkDescriptorUpdateTemplate_T * , struct VkPipelineLayout_T * , unsigned int , const void * )"
	),
}
extensions.vkGetValidationCacheDataEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkValidationCacheEXT_T * , unsigned long * , void * )"
	),
}
extensions.vkCreateSamplerYcbcrConversionKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkSamplerYcbcrConversionCreateInfo * , const struct VkAllocationCallbacks * , struct VkSamplerYcbcrConversion_T * * )"
	),
}
extensions.vkDestroyValidationCacheEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkValidationCacheEXT_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkCmdInsertDebugUtilsLabelEXT = {
	ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , const struct VkDebugUtilsLabelEXT * )"),
}
extensions.vkGetSemaphoreFdKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkSemaphoreGetFdInfoKHR * , int * )"
	),
}
extensions.vkCmdEndDebugUtilsLabelEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * )")}
extensions.vkCreateDisplayPlaneSurfaceKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkInstance_T * , const struct VkDisplaySurfaceCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSurfaceKHR_T * * )"
	),
}
extensions.vkCmdDispatchBaseKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int )"
	),
}
extensions.vkAcquireNextImageKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned long , struct VkSemaphore_T * , struct VkFence_T * , unsigned int * )"
	),
}
extensions.vkDestroySwapchainKHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , const struct VkAllocationCallbacks * )"
	),
}
extensions.vkGetPhysicalDeviceSurfaceCapabilities2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , const struct VkPhysicalDeviceSurfaceInfo2KHR * , struct VkSurfaceCapabilities2KHR * )"
	),
}
extensions.vkGetBufferMemoryRequirements2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , const struct VkBufferMemoryRequirementsInfo2 * , struct VkMemoryRequirements2 * )"
	),
}
extensions.vkGetMemoryFdPropertiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , enum VkExternalMemoryHandleTypeFlagBits , int , struct VkMemoryFdPropertiesKHR * )"
	),
}
extensions.vkGetDeviceGroupPresentCapabilitiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkDeviceGroupPresentCapabilitiesKHR * )"
	),
}
extensions.vkGetSwapchainImagesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned int * , struct VkImage_T * * )"
	),
}
extensions.vkCreateSwapchainKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )"
	),
}
extensions.vkQueueBeginDebugUtilsLabelEXT = {
	ctype = ffi.typeof("void(* )( struct VkQueue_T * , const struct VkDebugUtilsLabelEXT * )"),
}
extensions.vkMergeValidationCachesEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkValidationCacheEXT_T * , unsigned int , struct VkValidationCacheEXT_T * const * )"
	),
}
extensions.vkReleaseDisplayEXT = {
	ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * )"),
}
extensions.vkUnregisterObjectsNVX = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkObjectTableNVX_T * , unsigned int , const enum VkObjectEntryTypeNVX * , const unsigned int * )"
	),
}
extensions.vkCmdDrawIndexedIndirectCountAMD = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )"
	),
}
extensions.vkGetPhysicalDeviceDisplayPlanePropertiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPlanePropertiesKHR * )"
	),
}
extensions.vkGetPhysicalDeviceSurfacePresentModesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , enum VkPresentModeKHR * )"
	),
}
extensions.vkGetImageMemoryRequirements2KHR = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , const struct VkImageMemoryRequirementsInfo2 * , struct VkMemoryRequirements2 * )"
	),
}
extensions.vkQueuePresentKHR = {
	ctype = ffi.typeof("enum VkResult(* )( struct VkQueue_T * , const struct VkPresentInfoKHR * )"),
}
extensions.vkSetHdrMetadataEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkDevice_T * , unsigned int , struct VkSwapchainKHR_T * const * , const struct VkHdrMetadataEXT * )"
	),
}
extensions.vkGetDeviceGroupSurfacePresentModesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkSurfaceKHR_T * , unsigned int * )"
	),
}
extensions.vkAcquireNextImage2KHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkAcquireNextImageInfoKHR * , unsigned int * )"
	),
}
extensions.vkCmdSetDiscardRectangleEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkCommandBuffer_T * , unsigned int , unsigned int , const struct VkRect2D * )"
	),
}
extensions.vkCreateSharedSwapchainsKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )"
	),
}
extensions.vkEnumeratePhysicalDeviceGroupsKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkInstance_T * , unsigned int * , struct VkPhysicalDeviceGroupProperties * )"
	),
}
extensions.vkRegisterDeviceEventEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , const struct VkDeviceEventInfoEXT * , const struct VkAllocationCallbacks * , struct VkFence_T * * )"
	),
}
extensions.vkGetPhysicalDeviceDisplayPropertiesKHR = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPropertiesKHR * )"
	),
}
extensions.vkGetShaderInfoAMD = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkPipeline_T * , enum VkShaderStageFlagBits , enum VkShaderInfoTypeAMD , unsigned long * , void * )"
	),
}
extensions.vkDebugReportMessageEXT = {
	ctype = ffi.typeof(
		"void(* )( struct VkInstance_T * , unsigned int , enum VkDebugReportObjectTypeEXT , unsigned long , unsigned long , int , const char * , const char * )"
	),
}
extensions.vkDisplayPowerControlEXT = {
	ctype = ffi.typeof(
		"enum VkResult(* )( struct VkDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayPowerInfoEXT * )"
	),
}

local function load(func, ptr, ext, decl, name)
	if extensions[ext] and not decl and not name then
		decl = extensions[ext].ctype
	end

	local ptr = func(ptr, ext)

	if ptr ~= nil then
		name = name or ext:match("^vk(.+)")
		local func = ffi.cast(decl, ptr)
		library[name] = func
		return func
	end
end

library.util.LoadInstanceProcAddr = function(...)
	return load(CLIB.vkGetInstanceProcAddr, ...)
end
library.util.LoadDeviceProcAddr = function(...)
	return load(CLIB.vkGetDeviceProcAddr, ...)
end
library.e = {
	LOD_CLAMP_NONE = 1000.0,
	REMAINING_MIP_LEVELS = 0xFFFFFFFF,
	REMAINING_ARRAY_LAYERS = 0xFFFFFFFF,
	WHOLE_SIZE = jit and loadstring("return 0xFFFFFFFFFFFFFFFFULL")() or 0xFFFFFFFFFFFFFFFF,
	ATTACHMENT_UNUSED = 0xFFFFFFFF,
	TRUE = 1,
	FALSE = 0,
	QUEUE_FAMILY_IGNORED = 0xFFFFFFFF,
	SUBPASS_EXTERNAL = 0xFFFFFFFF,
	MAX_PHYSICAL_DEVICE_NAME_SIZE = 256,
	UUID_SIZE = 16,
	MAX_MEMORY_TYPES = 32,
	MAX_MEMORY_HEAPS = 16,
	MAX_EXTENSION_NAME_SIZE = 256,
	MAX_DESCRIPTION_SIZE = 256,
	DYNAMIC_STATE_VIEWPORT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
	DYNAMIC_STATE_SCISSOR = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
	DYNAMIC_STATE_LINE_WIDTH = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
	DYNAMIC_STATE_DEPTH_BIAS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
	DYNAMIC_STATE_BLEND_CONSTANTS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
	DYNAMIC_STATE_DEPTH_BOUNDS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
	DYNAMIC_STATE_STENCIL_COMPARE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
	DYNAMIC_STATE_STENCIL_WRITE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
	DYNAMIC_STATE_STENCIL_REFERENCE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
	DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
	DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
	DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"),
	DYNAMIC_STATE_BEGIN_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
	DYNAMIC_STATE_END_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
	DYNAMIC_STATE_RANGE_SIZE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	DYNAMIC_STATE_MAX_ENUM = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
	OBJECT_TYPE_UNKNOWN = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_UNKNOWN"),
	OBJECT_TYPE_INSTANCE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INSTANCE"),
	OBJECT_TYPE_PHYSICAL_DEVICE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
	OBJECT_TYPE_DEVICE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE"),
	OBJECT_TYPE_QUEUE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUEUE"),
	OBJECT_TYPE_SEMAPHORE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SEMAPHORE"),
	OBJECT_TYPE_COMMAND_BUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_BUFFER"),
	OBJECT_TYPE_FENCE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FENCE"),
	OBJECT_TYPE_DEVICE_MEMORY = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE_MEMORY"),
	OBJECT_TYPE_BUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER"),
	OBJECT_TYPE_IMAGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE"),
	OBJECT_TYPE_EVENT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_EVENT"),
	OBJECT_TYPE_QUERY_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUERY_POOL"),
	OBJECT_TYPE_BUFFER_VIEW = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER_VIEW"),
	OBJECT_TYPE_IMAGE_VIEW = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE_VIEW"),
	OBJECT_TYPE_SHADER_MODULE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SHADER_MODULE"),
	OBJECT_TYPE_PIPELINE_CACHE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_CACHE"),
	OBJECT_TYPE_PIPELINE_LAYOUT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
	OBJECT_TYPE_RENDER_PASS = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RENDER_PASS"),
	OBJECT_TYPE_PIPELINE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE"),
	OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
	OBJECT_TYPE_SAMPLER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER"),
	OBJECT_TYPE_DESCRIPTOR_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
	OBJECT_TYPE_DESCRIPTOR_SET = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET"),
	OBJECT_TYPE_FRAMEBUFFER = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FRAMEBUFFER"),
	OBJECT_TYPE_COMMAND_POOL = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_POOL"),
	OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"),
	OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"),
	OBJECT_TYPE_SURFACE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SURFACE_KHR"),
	OBJECT_TYPE_SWAPCHAIN_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
	OBJECT_TYPE_DISPLAY_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_KHR"),
	OBJECT_TYPE_DISPLAY_MODE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
	OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
	OBJECT_TYPE_OBJECT_TABLE_NVX = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_OBJECT_TABLE_NVX"),
	OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX"),
	OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"),
	OBJECT_TYPE_VALIDATION_CACHE_EXT = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"),
	OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR"),
	OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR"),
	OBJECT_TYPE_BEGIN_RANGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BEGIN_RANGE"),
	OBJECT_TYPE_END_RANGE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_END_RANGE"),
	OBJECT_TYPE_RANGE_SIZE = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RANGE_SIZE"),
	OBJECT_TYPE_MAX_ENUM = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_MAX_ENUM"),
	IMAGE_LAYOUT_UNDEFINED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
	IMAGE_LAYOUT_GENERAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
	IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
	IMAGE_LAYOUT_PREINITIALIZED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
	IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = ffi.cast(
		"enum VkImageLayout",
		"VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"
	),
	IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = ffi.cast(
		"enum VkImageLayout",
		"VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"
	),
	IMAGE_LAYOUT_PRESENT_SRC_KHR = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
	IMAGE_LAYOUT_SHARED_PRESENT_KHR = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
	IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = ffi.cast(
		"enum VkImageLayout",
		"VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR"
	),
	IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = ffi.cast(
		"enum VkImageLayout",
		"VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR"
	),
	IMAGE_LAYOUT_BEGIN_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
	IMAGE_LAYOUT_END_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
	IMAGE_LAYOUT_RANGE_SIZE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
	IMAGE_LAYOUT_MAX_ENUM = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
	SAMPLER_MIPMAP_MODE_NEAREST = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
	SAMPLER_MIPMAP_MODE_LINEAR = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
	SAMPLER_MIPMAP_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
	SAMPLER_MIPMAP_MODE_END_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
	SAMPLER_MIPMAP_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	SAMPLER_MIPMAP_MODE_MAX_ENUM = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
	INDEX_TYPE_UINT16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
	INDEX_TYPE_UINT32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
	INDEX_TYPE_BEGIN_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
	INDEX_TYPE_END_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
	INDEX_TYPE_RANGE_SIZE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	INDEX_TYPE_MAX_ENUM = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
	CULL_MODE_NONE = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
	CULL_MODE_FRONT_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
	CULL_MODE_BACK_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
	CULL_MODE_FRONT_AND_BACK = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	CULL_MODE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
	OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX"),
	OBJECT_ENTRY_TYPE_PIPELINE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX"),
	OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX"),
	OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX"),
	OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX"),
	OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX"),
	OBJECT_ENTRY_TYPE_END_RANGE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX"),
	OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX"),
	OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX"),
	PIPELINE_STAGE_TOP_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
	PIPELINE_STAGE_DRAW_INDIRECT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
	PIPELINE_STAGE_VERTEX_INPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
	PIPELINE_STAGE_VERTEX_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
	PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = ffi.cast(
		"enum VkPipelineStageFlagBits",
		"VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"
	),
	PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = ffi.cast(
		"enum VkPipelineStageFlagBits",
		"VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
	),
	PIPELINE_STAGE_GEOMETRY_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
	PIPELINE_STAGE_FRAGMENT_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
	PIPELINE_STAGE_COMPUTE_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
	PIPELINE_STAGE_TRANSFER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
	PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
	PIPELINE_STAGE_HOST_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
	PIPELINE_STAGE_ALL_GRAPHICS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
	PIPELINE_STAGE_ALL_COMMANDS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
	PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"),
	PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
	IMAGE_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
	IMAGE_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
	IMAGE_USAGE_SAMPLED_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
	IMAGE_USAGE_STORAGE_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	IMAGE_USAGE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
	IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
	IMAGE_USAGE_INPUT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
	IMAGE_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
	COMMAND_POOL_CREATE_TRANSIENT_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
	COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = ffi.cast(
		"enum VkCommandPoolCreateFlagBits",
		"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"
	),
	COMMAND_POOL_CREATE_PROTECTED_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_PROTECTED_BIT"),
	COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
	TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"),
	TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"),
	TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR"),
	TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR"),
	TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE"),
	TESSELLATION_DOMAIN_ORIGIN_END_RANGE = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE"),
	TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE"),
	TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM"),
	QUEUE_GLOBAL_PRIORITY_LOW_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"),
	QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"),
	QUEUE_GLOBAL_PRIORITY_HIGH_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"),
	QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"),
	QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT"),
	QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT"),
	QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT"),
	QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT"),
	DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = ffi.cast(
		"enum VkDeviceGroupPresentModeFlagBitsKHR",
		"VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"
	),
	DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = ffi.cast(
		"enum VkDeviceGroupPresentModeFlagBitsKHR",
		"VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"
	),
	DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = ffi.cast(
		"enum VkDeviceGroupPresentModeFlagBitsKHR",
		"VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"
	),
	DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = ffi.cast(
		"enum VkDeviceGroupPresentModeFlagBitsKHR",
		"VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR"
	),
	DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast(
		"enum VkDeviceGroupPresentModeFlagBitsKHR",
		"VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR"
	),
	DEPENDENCY_BY_REGION_BIT = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	DEPENDENCY_DEVICE_GROUP_BIT = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_DEVICE_GROUP_BIT"),
	DEPENDENCY_VIEW_LOCAL_BIT = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_VIEW_LOCAL_BIT"),
	DEPENDENCY_VIEW_LOCAL_BIT_KHR = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR"),
	DEPENDENCY_DEVICE_GROUP_BIT_KHR = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR"),
	DEPENDENCY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
	SYSTEM_ALLOCATION_SCOPE_COMMAND = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
	SYSTEM_ALLOCATION_SCOPE_OBJECT = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
	SYSTEM_ALLOCATION_SCOPE_CACHE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
	SYSTEM_ALLOCATION_SCOPE_DEVICE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
	SYSTEM_ALLOCATION_SCOPE_INSTANCE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
	SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_END_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
	SURFACE_COUNTER_VBLANK_EXT = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_VBLANK_EXT"),
	SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT"),
	FILTER_NEAREST = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
	FILTER_LINEAR = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
	FILTER_CUBIC_IMG = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
	FILTER_BEGIN_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
	FILTER_END_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
	FILTER_RANGE_SIZE = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	FILTER_MAX_ENUM = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE"
	),
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = ffi.cast(
		"enum VkDescriptorUpdateTemplateType",
		"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM"
	),
	BUFFER_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
	BUFFER_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_UNIFORM_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
	BUFFER_USAGE_INDEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
	BUFFER_USAGE_VERTEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
	BUFFER_USAGE_INDIRECT_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
	BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	FENCE_IMPORT_TEMPORARY_BIT = ffi.cast("enum VkFenceImportFlagBits", "VK_FENCE_IMPORT_TEMPORARY_BIT"),
	FENCE_IMPORT_TEMPORARY_BIT_KHR = ffi.cast("enum VkFenceImportFlagBits", "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR"),
	FENCE_IMPORT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFenceImportFlagBits", "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM"),
	DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = ffi.cast(
		"enum VkDisplayPlaneAlphaFlagBitsKHR",
		"VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"
	),
	DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast(
		"enum VkDisplayPlaneAlphaFlagBitsKHR",
		"VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"
	),
	PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
	PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
	PIPELINE_CREATE_DERIVATIVE_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
	PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = ffi.cast(
		"enum VkPipelineCreateFlagBits",
		"VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"
	),
	PIPELINE_CREATE_DISPATCH_BASE = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISPATCH_BASE"),
	PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = ffi.cast(
		"enum VkPipelineCreateFlagBits",
		"VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR"
	),
	PIPELINE_CREATE_DISPATCH_BASE_KHR = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR"),
	PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
	COVERAGE_MODULATION_MODE_NONE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_NONE_NV"),
	COVERAGE_MODULATION_MODE_RGB_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGB_NV"),
	COVERAGE_MODULATION_MODE_ALPHA_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
	COVERAGE_MODULATION_MODE_RGBA_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
	COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV"),
	COVERAGE_MODULATION_MODE_END_RANGE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_END_RANGE_NV"),
	COVERAGE_MODULATION_MODE_RANGE_SIZE_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV"),
	COVERAGE_MODULATION_MODE_MAX_ENUM_NV = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV"),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR"
	),
	EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalFenceHandleTypeFlagBits",
		"VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
	),
	IMAGE_VIEW_TYPE_1D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
	IMAGE_VIEW_TYPE_2D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
	IMAGE_VIEW_TYPE_3D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
	IMAGE_VIEW_TYPE_CUBE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
	IMAGE_VIEW_TYPE_1D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	IMAGE_VIEW_TYPE_2D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
	IMAGE_VIEW_TYPE_CUBE_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
	IMAGE_VIEW_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
	IMAGE_VIEW_TYPE_END_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
	IMAGE_VIEW_TYPE_RANGE_SIZE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
	IMAGE_VIEW_TYPE_MAX_ENUM = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
	QUERY_CONTROL_PRECISE_BIT = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	QUERY_CONTROL_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
	ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkAttachmentDescriptionFlagBits",
		"VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"
	),
	PIPELINE_CACHE_HEADER_VERSION_ONE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
	PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = ffi.cast(
		"enum VkPipelineCacheHeaderVersion",
		"VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"
	),
	PIPELINE_CACHE_HEADER_VERSION_END_RANGE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
	PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = ffi.cast(
		"enum VkPipelineCacheHeaderVersion",
		"VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"
	),
	PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
	DEBUG_REPORT_INFORMATION_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	DEBUG_REPORT_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
	DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
	DEBUG_REPORT_ERROR_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
	DEBUG_REPORT_DEBUG_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
	DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
	PRIMITIVE_TOPOLOGY_POINT_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
	PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_PATCH_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	PRIMITIVE_TOPOLOGY_BEGIN_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
	PRIMITIVE_TOPOLOGY_END_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
	PRIMITIVE_TOPOLOGY_RANGE_SIZE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
	PRIMITIVE_TOPOLOGY_MAX_ENUM = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
	DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = ffi.cast(
		"enum VkDescriptorBindingFlagBitsEXT",
		"VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
	),
	DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = ffi.cast(
		"enum VkDescriptorBindingFlagBitsEXT",
		"VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT"
	),
	DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = ffi.cast(
		"enum VkDescriptorBindingFlagBitsEXT",
		"VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT"
	),
	DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = ffi.cast(
		"enum VkDescriptorBindingFlagBitsEXT",
		"VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"
	),
	DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT = ffi.cast(
		"enum VkDescriptorBindingFlagBitsEXT",
		"VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT"
	),
	VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = ffi.cast(
		"enum VkValidationCacheHeaderVersionEXT",
		"VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"
	),
	VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT = ffi.cast(
		"enum VkValidationCacheHeaderVersionEXT",
		"VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT"
	),
	VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT = ffi.cast(
		"enum VkValidationCacheHeaderVersionEXT",
		"VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT"
	),
	VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT = ffi.cast(
		"enum VkValidationCacheHeaderVersionEXT",
		"VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT"
	),
	VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = ffi.cast(
		"enum VkValidationCacheHeaderVersionEXT",
		"VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT"
	),
	DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = ffi.cast(
		"enum VkDescriptorSetLayoutCreateFlagBits",
		"VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"
	),
	DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = ffi.cast(
		"enum VkDescriptorSetLayoutCreateFlagBits",
		"VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT"
	),
	DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkDescriptorSetLayoutCreateFlagBits",
		"VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM"
	),
	CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT"
	),
	CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = ffi.cast(
		"enum VkConservativeRasterizationModeEXT",
		"VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT"
	),
	DISPLAY_POWER_STATE_OFF_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_OFF_EXT"),
	DISPLAY_POWER_STATE_SUSPEND_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
	DISPLAY_POWER_STATE_ON_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_ON_EXT"),
	DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT"),
	DISPLAY_POWER_STATE_END_RANGE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_END_RANGE_EXT"),
	DISPLAY_POWER_STATE_RANGE_SIZE_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT"),
	DISPLAY_POWER_STATE_MAX_ENUM_EXT = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT"),
	SAMPLER_YCBCR_RANGE_ITU_FULL = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_FULL"),
	SAMPLER_YCBCR_RANGE_ITU_NARROW = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"),
	SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR"),
	SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR"),
	SAMPLER_YCBCR_RANGE_BEGIN_RANGE = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE"),
	SAMPLER_YCBCR_RANGE_END_RANGE = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_END_RANGE"),
	SAMPLER_YCBCR_RANGE_RANGE_SIZE = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE"),
	SAMPLER_YCBCR_RANGE_MAX_ENUM = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_MAX_ENUM"),
	DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = ffi.cast(
		"enum VkDescriptorPoolCreateFlagBits",
		"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"
	),
	DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = ffi.cast(
		"enum VkDescriptorPoolCreateFlagBits",
		"VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT"
	),
	DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkDescriptorPoolCreateFlagBits",
		"VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"
	),
	SURFACE_TRANSFORM_IDENTITY_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = ffi.cast(
		"enum VkSurfaceTransformFlagBitsKHR",
		"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"
	),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = ffi.cast(
		"enum VkSurfaceTransformFlagBitsKHR",
		"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"
	),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = ffi.cast(
		"enum VkSurfaceTransformFlagBitsKHR",
		"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"
	),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = ffi.cast(
		"enum VkSurfaceTransformFlagBitsKHR",
		"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"
	),
	SURFACE_TRANSFORM_INHERIT_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
	SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = ffi.cast(
		"enum VkSurfaceTransformFlagBitsKHR",
		"VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"
	),
	DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageTypeFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageTypeFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageTypeFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = ffi.cast(
		"enum VkDebugUtilsMessageTypeFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT"
	),
	DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = ffi.cast(
		"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"
	),
	DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = ffi.cast(
		"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
		"VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT"
	),
	COMPARE_OP_NEVER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
	COMPARE_OP_LESS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
	COMPARE_OP_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
	COMPARE_OP_LESS_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
	COMPARE_OP_GREATER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
	COMPARE_OP_NOT_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
	COMPARE_OP_GREATER_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
	COMPARE_OP_ALWAYS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
	COMPARE_OP_BEGIN_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
	COMPARE_OP_END_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
	COMPARE_OP_RANGE_SIZE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	COMPARE_OP_MAX_ENUM = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
	SHADER_STAGE_VERTEX_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
	SHADER_STAGE_TESSELLATION_CONTROL_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
	SHADER_STAGE_TESSELLATION_EVALUATION_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
	SHADER_STAGE_GEOMETRY_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
	SHADER_STAGE_FRAGMENT_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
	SHADER_STAGE_COMPUTE_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
	SHADER_STAGE_ALL_GRAPHICS = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
	SHADER_STAGE_ALL = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
	SHADER_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
	SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = ffi.cast(
		"enum VkSubpassDescriptionFlagBits",
		"VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"
	),
	SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = ffi.cast(
		"enum VkSubpassDescriptionFlagBits",
		"VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"
	),
	SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
	SUBGROUP_FEATURE_BASIC_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_BASIC_BIT"),
	SUBGROUP_FEATURE_VOTE_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_VOTE_BIT"),
	SUBGROUP_FEATURE_ARITHMETIC_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"),
	SUBGROUP_FEATURE_BALLOT_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_BALLOT_BIT"),
	SUBGROUP_FEATURE_SHUFFLE_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_SHUFFLE_BIT"),
	SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"),
	SUBGROUP_FEATURE_CLUSTERED_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_CLUSTERED_BIT"),
	SUBGROUP_FEATURE_QUAD_BIT = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_QUAD_BIT"),
	SUBGROUP_FEATURE_PARTITIONED_BIT_NV = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"),
	SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM"),
	SUCCESS = ffi.cast("enum VkResult", "VK_SUCCESS"),
	NOT_READY = ffi.cast("enum VkResult", "VK_NOT_READY"),
	TIMEOUT = ffi.cast("enum VkResult", "VK_TIMEOUT"),
	EVENT_SET = ffi.cast("enum VkResult", "VK_EVENT_SET"),
	EVENT_RESET = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
	INCOMPLETE = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
	ERROR_OUT_OF_HOST_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
	ERROR_OUT_OF_DEVICE_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
	ERROR_INITIALIZATION_FAILED = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
	ERROR_DEVICE_LOST = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
	ERROR_MEMORY_MAP_FAILED = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
	ERROR_LAYER_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
	ERROR_EXTENSION_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
	ERROR_FEATURE_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
	ERROR_INCOMPATIBLE_DRIVER = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
	ERROR_TOO_MANY_OBJECTS = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
	ERROR_FORMAT_NOT_SUPPORTED = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
	ERROR_FRAGMENTED_POOL = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
	ERROR_OUT_OF_POOL_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_POOL_MEMORY"),
	ERROR_INVALID_EXTERNAL_HANDLE = ffi.cast("enum VkResult", "VK_ERROR_INVALID_EXTERNAL_HANDLE"),
	ERROR_SURFACE_LOST_KHR = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
	ERROR_NATIVE_WINDOW_IN_USE_KHR = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
	SUBOPTIMAL_KHR = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
	ERROR_OUT_OF_DATE_KHR = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
	ERROR_INCOMPATIBLE_DISPLAY_KHR = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
	ERROR_VALIDATION_FAILED_EXT = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
	ERROR_INVALID_SHADER_NV = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
	ERROR_FRAGMENTATION_EXT = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTATION_EXT"),
	ERROR_NOT_PERMITTED_EXT = ffi.cast("enum VkResult", "VK_ERROR_NOT_PERMITTED_EXT"),
	ERROR_OUT_OF_POOL_MEMORY_KHR = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_POOL_MEMORY_KHR"),
	ERROR_INVALID_EXTERNAL_HANDLE_KHR = ffi.cast("enum VkResult", "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR"),
	RESULT_BEGIN_RANGE = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
	RESULT_END_RANGE = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
	RESULT_RANGE_SIZE = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
	RESULT_MAX_ENUM = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
	PEER_MEMORY_FEATURE_COPY_SRC_BIT = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"),
	PEER_MEMORY_FEATURE_COPY_DST_BIT = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"),
	PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"),
	PEER_MEMORY_FEATURE_GENERIC_DST_BIT = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"),
	PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR"),
	PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR"),
	PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR"),
	PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR"),
	PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"),
	FENCE_CREATE_SIGNALED_BIT = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
	FENCE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	IMAGE_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
	IMAGE_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	IMAGE_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
	IMAGE_CREATE_MUTABLE_FORMAT_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
	IMAGE_CREATE_CUBE_COMPATIBLE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
	IMAGE_CREATE_ALIAS_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_ALIAS_BIT"),
	IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"),
	IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"),
	IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"),
	IMAGE_CREATE_EXTENDED_USAGE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"),
	IMAGE_CREATE_PROTECTED_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_PROTECTED_BIT"),
	IMAGE_CREATE_DISJOINT_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_DISJOINT_BIT"),
	IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = ffi.cast(
		"enum VkImageCreateFlagBits",
		"VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"
	),
	IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = ffi.cast(
		"enum VkImageCreateFlagBits",
		"VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"
	),
	IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR"),
	IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = ffi.cast(
		"enum VkImageCreateFlagBits",
		"VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR"
	),
	IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR"),
	IMAGE_CREATE_DISJOINT_BIT_KHR = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_DISJOINT_BIT_KHR"),
	IMAGE_CREATE_ALIAS_BIT_KHR = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_ALIAS_BIT_KHR"),
	IMAGE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
	SAMPLE_COUNT_1_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
	SAMPLE_COUNT_2_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
	SAMPLE_COUNT_4_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
	SAMPLE_COUNT_8_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
	SAMPLE_COUNT_16_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	SAMPLE_COUNT_32_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
	SAMPLE_COUNT_64_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
	SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = ffi.cast("enum VkExternalFenceFeatureFlagBits", "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"),
	EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = ffi.cast("enum VkExternalFenceFeatureFlagBits", "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"),
	EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalFenceFeatureFlagBits",
		"VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR"
	),
	EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalFenceFeatureFlagBits",
		"VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR"
	),
	EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalFenceFeatureFlagBits",
		"VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM"
	),
	QUERY_RESULT_64_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
	QUERY_RESULT_WAIT_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	QUERY_RESULT_WITH_AVAILABILITY_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
	QUERY_RESULT_PARTIAL_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
	QUERY_RESULT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
	QUERY_TYPE_OCCLUSION = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
	QUERY_TYPE_PIPELINE_STATISTICS = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
	QUERY_TYPE_TIMESTAMP = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
	QUERY_TYPE_BEGIN_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
	QUERY_TYPE_END_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
	QUERY_TYPE_RANGE_SIZE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	QUERY_TYPE_MAX_ENUM = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
	DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
	DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT"),
	DISPLAY_EVENT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT"),
	DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT"),
	DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT"),
	PRESENT_MODE_IMMEDIATE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
	PRESENT_MODE_MAILBOX_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
	PRESENT_MODE_FIFO_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
	PRESENT_MODE_FIFO_RELAXED_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
	PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
	PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
	PRESENT_MODE_BEGIN_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
	PRESENT_MODE_END_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
	PRESENT_MODE_RANGE_SIZE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	PRESENT_MODE_MAX_ENUM_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
	BUFFER_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
	BUFFER_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	BUFFER_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
	BUFFER_CREATE_PROTECTED_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_PROTECTED_BIT"),
	BUFFER_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
	ACCESS_INDIRECT_COMMAND_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
	ACCESS_INDEX_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
	ACCESS_VERTEX_ATTRIBUTE_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
	ACCESS_UNIFORM_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
	ACCESS_INPUT_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
	ACCESS_SHADER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
	ACCESS_SHADER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
	ACCESS_COLOR_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
	ACCESS_COLOR_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
	ACCESS_TRANSFER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	ACCESS_TRANSFER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
	ACCESS_HOST_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
	ACCESS_HOST_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
	ACCESS_MEMORY_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
	ACCESS_MEMORY_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
	ACCESS_COMMAND_PROCESS_READ_BIT_NVX = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"),
	ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"),
	ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
	ACCESS_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = ffi.cast(
		"enum VkExternalSemaphoreFeatureFlagBits",
		"VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"
	),
	EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = ffi.cast(
		"enum VkExternalSemaphoreFeatureFlagBits",
		"VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"
	),
	EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreFeatureFlagBits",
		"VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreFeatureFlagBits",
		"VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalSemaphoreFeatureFlagBits",
		"VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM"
	),
	INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = ffi.cast(
		"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
		"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"
	),
	INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = ffi.cast(
		"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
		"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"
	),
	INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = ffi.cast(
		"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
		"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"
	),
	INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = ffi.cast(
		"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
		"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"
	),
	INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = ffi.cast(
		"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
		"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
	FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"
	),
	FORMAT_FEATURE_VERTEX_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
	FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	FORMAT_FEATURE_BLIT_SRC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
	FORMAT_FEATURE_BLIT_DST_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"
	),
	FORMAT_FEATURE_TRANSFER_SRC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"),
	FORMAT_FEATURE_TRANSFER_DST_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_DST_BIT"),
	FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"
	),
	FORMAT_FEATURE_DISJOINT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DISJOINT_BIT"),
	FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT"
	),
	FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR"),
	FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR"),
	FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR"
	),
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR"
	),
	FORMAT_FEATURE_DISJOINT_BIT_KHR = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR"),
	FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = ffi.cast(
		"enum VkFormatFeatureFlagBits",
		"VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR"
	),
	FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBits",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
	),
	COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
	MEMORY_HEAP_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
	MEMORY_HEAP_MULTI_INSTANCE_BIT = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"),
	MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR"),
	MEMORY_HEAP_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
	OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"),
	OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"),
	OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = ffi.cast(
		"enum VkObjectEntryUsageFlagBitsNVX",
		"VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX"),
	INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX"
	),
	INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = ffi.cast(
		"enum VkIndirectCommandsTokenTypeNVX",
		"VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE"
	),
	SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = ffi.cast(
		"enum VkSamplerYcbcrModelConversion",
		"VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM"
	),
	DEVICE_QUEUE_CREATE_PROTECTED_BIT = ffi.cast("enum VkDeviceQueueCreateFlagBits", "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT"),
	DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDeviceQueueCreateFlagBits", "VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM"),
	STRUCTURE_TYPE_APPLICATION_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
	STRUCTURE_TYPE_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_SUBMIT_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
	STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
	STRUCTURE_TYPE_BIND_SPARSE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
	STRUCTURE_TYPE_FENCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
	STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
	STRUCTURE_TYPE_EVENT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
	STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_SAMPLER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
	STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
	STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
	STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"
	),
	STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"),
	STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"),
	STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"),
	STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"
	),
	STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"),
	STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"),
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"),
	STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"),
	STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"),
	STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"
	),
	STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"),
	STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"),
	STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"),
	STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"),
	STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"),
	STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"
	),
	STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"
	),
	STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"
	),
	STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"
	),
	STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"),
	STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"),
	STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"
	),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"
	),
	STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"
	),
	STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"),
	STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"),
	STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"),
	STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"),
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"
	),
	STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"
	),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES"
	),
	STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
	STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
	STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"
	),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"
	),
	STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"
	),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"
	),
	STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
	STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
	STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
	STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"
	),
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"
	),
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"
	),
	STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
	STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
	STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"
	),
	STRUCTURE_TYPE_PRESENT_REGIONS_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
	STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"),
	STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"
	),
	STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"),
	STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"
	),
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"),
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"
	),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"),
	STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
	STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
	STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
	STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"
	),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_HDR_METADATA_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
	STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"
	),
	STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
	STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
	STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
	STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
	STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
	STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
	STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
	STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"),
	STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"
	),
	STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"
	),
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"
	),
	STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"
	),
	STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"
	),
	STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"),
	STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"),
	STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"
	),
	STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"
	),
	STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"
	),
	STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
	STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"
	),
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"
	),
	STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR"
	),
	STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR"
	),
	STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR"
	),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR"
	),
	STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR"
	),
	STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR"),
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR"
	),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR"),
	STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"
	),
	STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"
	),
	STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"
	),
	STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR"
	),
	STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"
	),
	STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"),
	STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR"
	),
	STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"
	),
	STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"),
	STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"),
	STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR"),
	STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
	STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR"
	),
	STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR"),
	STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR"
	),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR"
	),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR"),
	STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR"),
	STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR"
	),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR"
	),
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR"
	),
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR"),
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR"),
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = ffi.cast(
		"enum VkStructureType",
		"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR"
	),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR"),
	STRUCTURE_TYPE_BEGIN_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
	STRUCTURE_TYPE_END_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
	STRUCTURE_TYPE_RANGE_SIZE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
	STRUCTURE_TYPE_MAX_ENUM = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBitsNV",
		"VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"
	),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBitsNV",
		"VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"
	),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBitsNV",
		"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"
	),
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBitsNV",
		"VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"
	),
	VERTEX_INPUT_RATE_VERTEX = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
	VERTEX_INPUT_RATE_INSTANCE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
	VERTEX_INPUT_RATE_BEGIN_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
	VERTEX_INPUT_RATE_END_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
	VERTEX_INPUT_RATE_RANGE_SIZE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	VERTEX_INPUT_RATE_MAX_ENUM = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
	CHROMA_LOCATION_COSITED_EVEN = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_COSITED_EVEN"),
	CHROMA_LOCATION_MIDPOINT = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_MIDPOINT"),
	CHROMA_LOCATION_COSITED_EVEN_KHR = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_COSITED_EVEN_KHR"),
	CHROMA_LOCATION_MIDPOINT_KHR = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_MIDPOINT_KHR"),
	CHROMA_LOCATION_BEGIN_RANGE = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_BEGIN_RANGE"),
	CHROMA_LOCATION_END_RANGE = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_END_RANGE"),
	CHROMA_LOCATION_RANGE_SIZE = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_RANGE_SIZE"),
	CHROMA_LOCATION_MAX_ENUM = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_MAX_ENUM"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBitsNV",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBitsNV",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBitsNV",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBitsNV",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"
	),
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = ffi.cast(
		"enum VkExternalMemoryHandleTypeFlagBitsNV",
		"VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"
	),
	SHADER_INFO_TYPE_STATISTICS_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_STATISTICS_AMD"),
	SHADER_INFO_TYPE_BINARY_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_BINARY_AMD"),
	SHADER_INFO_TYPE_DISASSEMBLY_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"),
	SHADER_INFO_TYPE_BEGIN_RANGE_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD"),
	SHADER_INFO_TYPE_END_RANGE_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_END_RANGE_AMD"),
	SHADER_INFO_TYPE_RANGE_SIZE_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD"),
	SHADER_INFO_TYPE_MAX_ENUM_AMD = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_MAX_ENUM_AMD"),
	RASTERIZATION_ORDER_STRICT_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
	RASTERIZATION_ORDER_RELAXED_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
	RASTERIZATION_ORDER_BEGIN_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
	RASTERIZATION_ORDER_END_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
	RASTERIZATION_ORDER_RANGE_SIZE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
	RASTERIZATION_ORDER_MAX_ENUM_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
	IMAGE_TILING_OPTIMAL = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	IMAGE_TILING_LINEAR = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
	IMAGE_TILING_BEGIN_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
	IMAGE_TILING_END_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
	IMAGE_TILING_RANGE_SIZE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
	IMAGE_TILING_MAX_ENUM = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
	DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = ffi.cast(
		"enum VkDebugReportObjectTypeEXT",
		"VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT"
	),
	DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
	FORMAT_UNDEFINED = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
	FORMAT_R4G4_UNORM_PACK8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
	FORMAT_R4G4B4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
	FORMAT_B4G4R4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
	FORMAT_R5G6B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
	FORMAT_B5G6R5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
	FORMAT_R5G5B5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
	FORMAT_B5G5R5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
	FORMAT_A1R5G5B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
	FORMAT_R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
	FORMAT_R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
	FORMAT_R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
	FORMAT_R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
	FORMAT_R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
	FORMAT_R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
	FORMAT_R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
	FORMAT_R8G8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
	FORMAT_R8G8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
	FORMAT_R8G8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
	FORMAT_R8G8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
	FORMAT_R8G8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
	FORMAT_R8G8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
	FORMAT_R8G8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
	FORMAT_R8G8B8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
	FORMAT_R8G8B8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
	FORMAT_R8G8B8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
	FORMAT_R8G8B8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
	FORMAT_R8G8B8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
	FORMAT_R8G8B8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
	FORMAT_R8G8B8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
	FORMAT_B8G8R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
	FORMAT_B8G8R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
	FORMAT_B8G8R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
	FORMAT_B8G8R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
	FORMAT_B8G8R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
	FORMAT_B8G8R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
	FORMAT_B8G8R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
	FORMAT_R8G8B8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
	FORMAT_R8G8B8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
	FORMAT_R8G8B8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
	FORMAT_R8G8B8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
	FORMAT_R8G8B8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
	FORMAT_R8G8B8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
	FORMAT_R8G8B8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
	FORMAT_B8G8R8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
	FORMAT_B8G8R8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
	FORMAT_B8G8R8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
	FORMAT_B8G8R8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
	FORMAT_B8G8R8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
	FORMAT_B8G8R8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
	FORMAT_B8G8R8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
	FORMAT_A8B8G8R8_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
	FORMAT_A8B8G8R8_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
	FORMAT_A8B8G8R8_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
	FORMAT_A8B8G8R8_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
	FORMAT_A8B8G8R8_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
	FORMAT_A8B8G8R8_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
	FORMAT_A8B8G8R8_SRGB_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
	FORMAT_A2R10G10B10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
	FORMAT_A2R10G10B10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
	FORMAT_A2R10G10B10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
	FORMAT_A2R10G10B10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
	FORMAT_A2R10G10B10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
	FORMAT_A2R10G10B10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
	FORMAT_A2B10G10R10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
	FORMAT_A2B10G10R10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
	FORMAT_A2B10G10R10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
	FORMAT_A2B10G10R10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
	FORMAT_A2B10G10R10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
	FORMAT_A2B10G10R10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
	FORMAT_R16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
	FORMAT_R16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
	FORMAT_R16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
	FORMAT_R16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
	FORMAT_R16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
	FORMAT_R16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
	FORMAT_R16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
	FORMAT_R16G16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
	FORMAT_R16G16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
	FORMAT_R16G16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
	FORMAT_R16G16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
	FORMAT_R16G16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
	FORMAT_R16G16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
	FORMAT_R16G16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
	FORMAT_R16G16B16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
	FORMAT_R16G16B16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
	FORMAT_R16G16B16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
	FORMAT_R16G16B16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
	FORMAT_R16G16B16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
	FORMAT_R16G16B16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
	FORMAT_R16G16B16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
	FORMAT_R16G16B16A16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
	FORMAT_R16G16B16A16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
	FORMAT_R16G16B16A16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
	FORMAT_R16G16B16A16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
	FORMAT_R16G16B16A16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
	FORMAT_R16G16B16A16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
	FORMAT_R16G16B16A16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
	FORMAT_R32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	FORMAT_R32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
	FORMAT_R32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
	FORMAT_R32G32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
	FORMAT_R32G32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
	FORMAT_R32G32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
	FORMAT_R32G32B32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
	FORMAT_R32G32B32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
	FORMAT_R32G32B32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
	FORMAT_R32G32B32A32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
	FORMAT_R32G32B32A32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
	FORMAT_R32G32B32A32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
	FORMAT_R64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
	FORMAT_R64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
	FORMAT_R64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
	FORMAT_R64G64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
	FORMAT_R64G64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
	FORMAT_R64G64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
	FORMAT_R64G64B64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
	FORMAT_R64G64B64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
	FORMAT_R64G64B64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
	FORMAT_R64G64B64A64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
	FORMAT_R64G64B64A64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
	FORMAT_R64G64B64A64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
	FORMAT_B10G11R11_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
	FORMAT_E5B9G9R9_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
	FORMAT_D16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
	FORMAT_X8_D24_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
	FORMAT_D32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
	FORMAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
	FORMAT_D16_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
	FORMAT_D24_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
	FORMAT_D32_SFLOAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
	FORMAT_BC1_RGB_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
	FORMAT_BC1_RGB_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
	FORMAT_BC1_RGBA_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
	FORMAT_BC1_RGBA_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
	FORMAT_BC2_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
	FORMAT_BC2_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
	FORMAT_BC3_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
	FORMAT_BC3_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
	FORMAT_BC4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
	FORMAT_BC4_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
	FORMAT_BC5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
	FORMAT_BC5_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
	FORMAT_BC6H_UFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
	FORMAT_BC6H_SFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
	FORMAT_BC7_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
	FORMAT_BC7_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
	FORMAT_EAC_R11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
	FORMAT_EAC_R11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
	FORMAT_EAC_R11G11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
	FORMAT_EAC_R11G11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
	FORMAT_ASTC_4x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
	FORMAT_ASTC_4x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
	FORMAT_ASTC_5x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
	FORMAT_ASTC_5x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
	FORMAT_ASTC_6x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
	FORMAT_ASTC_6x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
	FORMAT_ASTC_8x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
	FORMAT_ASTC_8x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
	FORMAT_ASTC_8x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
	FORMAT_ASTC_8x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
	FORMAT_ASTC_10x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
	FORMAT_ASTC_10x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
	FORMAT_ASTC_10x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
	FORMAT_ASTC_10x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
	FORMAT_ASTC_10x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
	FORMAT_ASTC_10x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
	FORMAT_ASTC_12x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x12_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
	FORMAT_ASTC_12x12_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
	FORMAT_G8B8G8R8_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8B8G8R8_422_UNORM"),
	FORMAT_B8G8R8G8_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8G8_422_UNORM"),
	FORMAT_G8_B8_R8_3PLANE_420_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"),
	FORMAT_G8_B8R8_2PLANE_420_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"),
	FORMAT_G8_B8_R8_3PLANE_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"),
	FORMAT_G8_B8R8_2PLANE_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"),
	FORMAT_G8_B8_R8_3PLANE_444_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"),
	FORMAT_R10X6_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6_UNORM_PACK16"),
	FORMAT_R10X6G10X6_UNORM_2PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6_UNORM_2PACK16"),
	FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"),
	FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"),
	FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"),
	FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"),
	FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"),
	FORMAT_R12X4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4_UNORM_PACK16"),
	FORMAT_R12X4G12X4_UNORM_2PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4_UNORM_2PACK16"),
	FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"),
	FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"),
	FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"),
	FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"),
	FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"),
	FORMAT_G16B16G16R16_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16B16G16R16_422_UNORM"),
	FORMAT_B16G16R16G16_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B16G16R16G16_422_UNORM"),
	FORMAT_G16_B16_R16_3PLANE_420_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"),
	FORMAT_G16_B16R16_2PLANE_420_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"),
	FORMAT_G16_B16_R16_3PLANE_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"),
	FORMAT_G16_B16R16_2PLANE_422_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"),
	FORMAT_G16_B16_R16_3PLANE_444_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"),
	FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_G8B8G8R8_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8B8G8R8_422_UNORM_KHR"),
	FORMAT_B8G8R8G8_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8G8_422_UNORM_KHR"),
	FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR"),
	FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR"),
	FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR"),
	FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR"),
	FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR"),
	FORMAT_R10X6_UNORM_PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6_UNORM_PACK16_KHR"),
	FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR"),
	FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR"),
	FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR"),
	FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR"),
	FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR"),
	FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR"),
	FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR"),
	FORMAT_R12X4_UNORM_PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4_UNORM_PACK16_KHR"),
	FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR"),
	FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR"),
	FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR"),
	FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR"),
	FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR"),
	FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR"),
	FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR"),
	FORMAT_G16B16G16R16_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16B16G16R16_422_UNORM_KHR"),
	FORMAT_B16G16R16G16_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_B16G16R16G16_422_UNORM_KHR"),
	FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR"),
	FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR"),
	FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR"),
	FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR"),
	FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR"),
	FORMAT_BEGIN_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
	FORMAT_END_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
	FORMAT_RANGE_SIZE = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
	FORMAT_MAX_ENUM = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
	ATTACHMENT_STORE_OP_STORE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	ATTACHMENT_STORE_OP_DONT_CARE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
	ATTACHMENT_STORE_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
	ATTACHMENT_STORE_OP_END_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
	ATTACHMENT_STORE_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
	ATTACHMENT_STORE_OP_MAX_ENUM = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
	LOGIC_OP_CLEAR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
	LOGIC_OP_AND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
	LOGIC_OP_AND_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
	LOGIC_OP_COPY = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
	LOGIC_OP_AND_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
	LOGIC_OP_NO_OP = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
	LOGIC_OP_XOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	LOGIC_OP_OR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
	LOGIC_OP_NOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
	LOGIC_OP_EQUIVALENT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
	LOGIC_OP_INVERT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
	LOGIC_OP_OR_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
	LOGIC_OP_COPY_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
	LOGIC_OP_OR_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
	LOGIC_OP_NAND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
	LOGIC_OP_SET = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
	LOGIC_OP_BEGIN_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
	LOGIC_OP_END_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
	LOGIC_OP_RANGE_SIZE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
	LOGIC_OP_MAX_ENUM = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
	ATTACHMENT_LOAD_OP_LOAD = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
	ATTACHMENT_LOAD_OP_CLEAR = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
	ATTACHMENT_LOAD_OP_DONT_CARE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
	ATTACHMENT_LOAD_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
	ATTACHMENT_LOAD_OP_END_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
	ATTACHMENT_LOAD_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	ATTACHMENT_LOAD_OP_MAX_ENUM = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
	SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = ffi.cast(
		"enum VkSwapchainCreateFlagBitsKHR",
		"VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"
	),
	SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"),
	SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR"),
	COMPOSITE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
	COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_INHERIT_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
	COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
	IMAGE_ASPECT_COLOR_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
	IMAGE_ASPECT_DEPTH_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
	IMAGE_ASPECT_STENCIL_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
	IMAGE_ASPECT_METADATA_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
	IMAGE_ASPECT_PLANE_0_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_0_BIT"),
	IMAGE_ASPECT_PLANE_1_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_1_BIT"),
	IMAGE_ASPECT_PLANE_2_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_2_BIT"),
	IMAGE_ASPECT_PLANE_0_BIT_KHR = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR"),
	IMAGE_ASPECT_PLANE_1_BIT_KHR = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR"),
	IMAGE_ASPECT_PLANE_2_BIT_KHR = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR"),
	IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
	POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"),
	POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = ffi.cast(
		"enum VkPointClippingBehavior",
		"VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"
	),
	POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR"),
	POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = ffi.cast(
		"enum VkPointClippingBehavior",
		"VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR"
	),
	POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE"),
	POINT_CLIPPING_BEHAVIOR_END_RANGE = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_END_RANGE"),
	POINT_CLIPPING_BEHAVIOR_RANGE_SIZE = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE"),
	POINT_CLIPPING_BEHAVIOR_MAX_ENUM = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM"),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR"
	),
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalSemaphoreHandleTypeFlagBits",
		"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
	),
	POLYGON_MODE_FILL = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
	POLYGON_MODE_LINE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
	POLYGON_MODE_POINT = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
	POLYGON_MODE_FILL_RECTANGLE_NV = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
	POLYGON_MODE_BEGIN_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
	POLYGON_MODE_END_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
	POLYGON_MODE_RANGE_SIZE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	POLYGON_MODE_MAX_ENUM = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
	COLOR_SPACE_SRGB_NONLINEAR_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
	COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
	COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
	COLOR_SPACE_DCI_P3_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT"),
	COLOR_SPACE_DCI_P3_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
	COLOR_SPACE_BT709_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_LINEAR_EXT"),
	COLOR_SPACE_BT709_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
	COLOR_SPACE_BT2020_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
	COLOR_SPACE_HDR10_ST2084_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_ST2084_EXT"),
	COLOR_SPACE_DOLBYVISION_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DOLBYVISION_EXT"),
	COLOR_SPACE_HDR10_HLG_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_HLG_EXT"),
	COLOR_SPACE_ADOBERGB_LINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
	COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
	COLOR_SPACE_PASS_THROUGH_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_PASS_THROUGH_EXT"),
	COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
	COLOR_SPACE_BEGIN_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
	COLOR_SPACE_END_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
	COLOR_SPACE_RANGE_SIZE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
	COLOR_SPACE_MAX_ENUM_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
	IMAGE_TYPE_1D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
	IMAGE_TYPE_2D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
	IMAGE_TYPE_3D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
	IMAGE_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
	IMAGE_TYPE_END_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
	IMAGE_TYPE_RANGE_SIZE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	IMAGE_TYPE_MAX_ENUM = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
	SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
	SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
	SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = ffi.cast(
		"enum VkSparseImageFormatFlagBits",
		"VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"
	),
	SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
	BORDER_COLOR_INT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	BORDER_COLOR_INT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
	BORDER_COLOR_INT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
	BORDER_COLOR_BEGIN_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
	BORDER_COLOR_END_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
	BORDER_COLOR_RANGE_SIZE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
	BORDER_COLOR_MAX_ENUM = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
	SEMAPHORE_IMPORT_TEMPORARY_BIT = ffi.cast("enum VkSemaphoreImportFlagBits", "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"),
	SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = ffi.cast("enum VkSemaphoreImportFlagBits", "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR"),
	SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSemaphoreImportFlagBits", "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM"),
	MEMORY_ALLOCATE_DEVICE_MASK_BIT = ffi.cast("enum VkMemoryAllocateFlagBits", "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"),
	MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = ffi.cast("enum VkMemoryAllocateFlagBits", "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR"),
	MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryAllocateFlagBits", "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM"),
	INTERNAL_ALLOCATION_TYPE_EXECUTABLE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
	INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
	INTERNAL_ALLOCATION_TYPE_END_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
	INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	INTERNAL_ALLOCATION_TYPE_MAX_ENUM = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"
	),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"
	),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"
	),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR"
	),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR"
	),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR"
	),
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkExternalMemoryFeatureFlagBits",
		"VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"
	),
	BLEND_OVERLAP_UNCORRELATED_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
	BLEND_OVERLAP_DISJOINT_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_DISJOINT_EXT"),
	BLEND_OVERLAP_CONJOINT_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_CONJOINT_EXT"),
	BLEND_OVERLAP_BEGIN_RANGE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_BEGIN_RANGE_EXT"),
	BLEND_OVERLAP_END_RANGE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_END_RANGE_EXT"),
	BLEND_OVERLAP_RANGE_SIZE_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_RANGE_SIZE_EXT"),
	BLEND_OVERLAP_MAX_ENUM_EXT = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_MAX_ENUM_EXT"),
	VALIDATION_CHECK_ALL_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_ALL_EXT"),
	VALIDATION_CHECK_SHADERS_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_SHADERS_EXT"),
	VALIDATION_CHECK_BEGIN_RANGE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_BEGIN_RANGE_EXT"),
	VALIDATION_CHECK_END_RANGE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_END_RANGE_EXT"),
	VALIDATION_CHECK_RANGE_SIZE_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_RANGE_SIZE_EXT"),
	VALIDATION_CHECK_MAX_ENUM_EXT = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_MAX_ENUM_EXT"),
	DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
	DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT"),
	DEVICE_EVENT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_END_RANGE_EXT"),
	DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT"),
	DEVICE_EVENT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT"),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"
	),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"
	),
	QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"
	),
	QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"
	),
	QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"
	),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"
	),
	QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = ffi.cast(
		"enum VkQueryPipelineStatisticFlagBits",
		"VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"
	),
	COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = ffi.cast(
		"enum VkCommandBufferResetFlagBits",
		"VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"
	),
	COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
	FRONT_FACE_COUNTER_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
	FRONT_FACE_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	FRONT_FACE_BEGIN_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
	FRONT_FACE_END_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
	FRONT_FACE_RANGE_SIZE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
	FRONT_FACE_MAX_ENUM = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
	DESCRIPTOR_TYPE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
	DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
	DESCRIPTOR_TYPE_SAMPLED_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
	DESCRIPTOR_TYPE_STORAGE_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
	DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_INPUT_ATTACHMENT = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
	DESCRIPTOR_TYPE_BEGIN_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
	DESCRIPTOR_TYPE_END_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
	DESCRIPTOR_TYPE_RANGE_SIZE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	DESCRIPTOR_TYPE_MAX_ENUM = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
	BLEND_OP_ADD = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
	BLEND_OP_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
	BLEND_OP_REVERSE_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
	BLEND_OP_MIN = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
	BLEND_OP_MAX = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
	BLEND_OP_ZERO_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ZERO_EXT"),
	BLEND_OP_SRC_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_EXT"),
	BLEND_OP_DST_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_EXT"),
	BLEND_OP_SRC_OVER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OVER_EXT"),
	BLEND_OP_DST_OVER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OVER_EXT"),
	BLEND_OP_SRC_IN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_IN_EXT"),
	BLEND_OP_DST_IN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_IN_EXT"),
	BLEND_OP_SRC_OUT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OUT_EXT"),
	BLEND_OP_DST_OUT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OUT_EXT"),
	BLEND_OP_SRC_ATOP_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_ATOP_EXT"),
	BLEND_OP_DST_ATOP_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_ATOP_EXT"),
	BLEND_OP_XOR_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_XOR_EXT"),
	BLEND_OP_MULTIPLY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MULTIPLY_EXT"),
	BLEND_OP_SCREEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SCREEN_EXT"),
	BLEND_OP_OVERLAY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_OVERLAY_EXT"),
	BLEND_OP_DARKEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DARKEN_EXT"),
	BLEND_OP_LIGHTEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LIGHTEN_EXT"),
	BLEND_OP_COLORDODGE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORDODGE_EXT"),
	BLEND_OP_COLORBURN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORBURN_EXT"),
	BLEND_OP_HARDLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDLIGHT_EXT"),
	BLEND_OP_SOFTLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SOFTLIGHT_EXT"),
	BLEND_OP_DIFFERENCE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DIFFERENCE_EXT"),
	BLEND_OP_EXCLUSION_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_EXCLUSION_EXT"),
	BLEND_OP_INVERT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_EXT"),
	BLEND_OP_INVERT_RGB_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_RGB_EXT"),
	BLEND_OP_LINEARDODGE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARDODGE_EXT"),
	BLEND_OP_LINEARBURN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARBURN_EXT"),
	BLEND_OP_VIVIDLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_VIVIDLIGHT_EXT"),
	BLEND_OP_LINEARLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARLIGHT_EXT"),
	BLEND_OP_PINLIGHT_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PINLIGHT_EXT"),
	BLEND_OP_HARDMIX_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDMIX_EXT"),
	BLEND_OP_HSL_HUE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_HUE_EXT"),
	BLEND_OP_HSL_SATURATION_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_SATURATION_EXT"),
	BLEND_OP_HSL_COLOR_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_COLOR_EXT"),
	BLEND_OP_HSL_LUMINOSITY_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
	BLEND_OP_PLUS_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_EXT"),
	BLEND_OP_PLUS_CLAMPED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_EXT"),
	BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
	BLEND_OP_PLUS_DARKER_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_DARKER_EXT"),
	BLEND_OP_MINUS_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_EXT"),
	BLEND_OP_MINUS_CLAMPED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_CLAMPED_EXT"),
	BLEND_OP_CONTRAST_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_CONTRAST_EXT"),
	BLEND_OP_INVERT_OVG_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_OVG_EXT"),
	BLEND_OP_RED_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RED_EXT"),
	BLEND_OP_GREEN_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_GREEN_EXT"),
	BLEND_OP_BLUE_EXT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BLUE_EXT"),
	BLEND_OP_BEGIN_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
	BLEND_OP_END_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
	BLEND_OP_RANGE_SIZE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
	BLEND_OP_MAX_ENUM = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
	BLEND_FACTOR_ZERO = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
	BLEND_FACTOR_ONE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	BLEND_FACTOR_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
	BLEND_FACTOR_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
	BLEND_FACTOR_ONE_MINUS_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
	BLEND_FACTOR_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
	BLEND_FACTOR_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
	BLEND_FACTOR_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
	BLEND_FACTOR_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
	BLEND_FACTOR_SRC_ALPHA_SATURATE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
	BLEND_FACTOR_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
	BLEND_FACTOR_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
	BLEND_FACTOR_BEGIN_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
	BLEND_FACTOR_END_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
	BLEND_FACTOR_RANGE_SIZE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
	BLEND_FACTOR_MAX_ENUM = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
	PIPELINE_BIND_POINT_GRAPHICS = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	PIPELINE_BIND_POINT_COMPUTE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
	PIPELINE_BIND_POINT_BEGIN_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
	PIPELINE_BIND_POINT_END_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
	PIPELINE_BIND_POINT_RANGE_SIZE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
	PIPELINE_BIND_POINT_MAX_ENUM = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
	SHARING_MODE_EXCLUSIVE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
	SHARING_MODE_CONCURRENT = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
	SHARING_MODE_BEGIN_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
	SHARING_MODE_END_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
	SHARING_MODE_RANGE_SIZE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	SHARING_MODE_MAX_ENUM = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
	SAMPLER_ADDRESS_MODE_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
	SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
	SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
	SAMPLER_ADDRESS_MODE_END_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
	SAMPLER_ADDRESS_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	SAMPLER_ADDRESS_MODE_MAX_ENUM = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
	SPARSE_MEMORY_BIND_METADATA_BIT = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
	SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	PHYSICAL_DEVICE_TYPE_OTHER = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
	PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
	PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
	PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
	PHYSICAL_DEVICE_TYPE_CPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
	PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
	PHYSICAL_DEVICE_TYPE_END_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
	PHYSICAL_DEVICE_TYPE_RANGE_SIZE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	PHYSICAL_DEVICE_TYPE_MAX_ENUM = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV"
	),
	VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = ffi.cast(
		"enum VkViewportCoordinateSwizzleNV",
		"VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV"
	),
	MEMORY_PROPERTY_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
	MEMORY_PROPERTY_HOST_VISIBLE_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	MEMORY_PROPERTY_HOST_COHERENT_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
	MEMORY_PROPERTY_HOST_CACHED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
	MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
	MEMORY_PROPERTY_PROTECTED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_PROTECTED_BIT"),
	MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
	SUBPASS_CONTENTS_INLINE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
	SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
	SUBPASS_CONTENTS_BEGIN_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
	SUBPASS_CONTENTS_END_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
	SUBPASS_CONTENTS_RANGE_SIZE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	SUBPASS_CONTENTS_MAX_ENUM = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
	QUEUE_GRAPHICS_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
	QUEUE_COMPUTE_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
	QUEUE_TRANSFER_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	QUEUE_SPARSE_BINDING_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
	QUEUE_PROTECTED_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_PROTECTED_BIT"),
	QUEUE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
	COLOR_COMPONENT_R_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
	COLOR_COMPONENT_G_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	COLOR_COMPONENT_B_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
	COLOR_COMPONENT_A_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
	COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
	COMPONENT_SWIZZLE_IDENTITY = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
	COMPONENT_SWIZZLE_ZERO = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
	COMPONENT_SWIZZLE_ONE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
	COMPONENT_SWIZZLE_R = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
	COMPONENT_SWIZZLE_G = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
	COMPONENT_SWIZZLE_B = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
	COMPONENT_SWIZZLE_A = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
	COMPONENT_SWIZZLE_BEGIN_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
	COMPONENT_SWIZZLE_END_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
	COMPONENT_SWIZZLE_RANGE_SIZE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	COMPONENT_SWIZZLE_MAX_ENUM = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
	COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = ffi.cast(
		"enum VkCommandBufferUsageFlagBits",
		"VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"
	),
	COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = ffi.cast(
		"enum VkCommandBufferUsageFlagBits",
		"VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"
	),
	COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = ffi.cast(
		"enum VkCommandBufferUsageFlagBits",
		"VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"
	),
	COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	STENCIL_OP_KEEP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
	STENCIL_OP_ZERO = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
	STENCIL_OP_REPLACE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
	STENCIL_OP_INCREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
	STENCIL_OP_DECREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
	STENCIL_OP_INVERT = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
	STENCIL_OP_INCREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
	STENCIL_OP_DECREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
	STENCIL_OP_BEGIN_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
	STENCIL_OP_END_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
	STENCIL_OP_RANGE_SIZE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	STENCIL_OP_MAX_ENUM = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
	STENCIL_FACE_FRONT_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
	STENCIL_FACE_BACK_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
	STENCIL_FRONT_AND_BACK = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
	STENCIL_FACE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	COMMAND_BUFFER_LEVEL_PRIMARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
	COMMAND_BUFFER_LEVEL_SECONDARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
	COMMAND_BUFFER_LEVEL_BEGIN_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
	COMMAND_BUFFER_LEVEL_END_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
	COMMAND_BUFFER_LEVEL_RANGE_SIZE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	COMMAND_BUFFER_LEVEL_MAX_ENUM = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
	DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
	DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
	DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT"),
	DISCARD_RECTANGLE_MODE_END_RANGE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT"),
	DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT"),
	DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT"),
	SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = ffi.cast(
		"enum VkSamplerReductionModeEXT",
		"VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"
	),
	SAMPLER_REDUCTION_MODE_MIN_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MIN_EXT"),
	SAMPLER_REDUCTION_MODE_MAX_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_EXT"),
	SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT"),
	SAMPLER_REDUCTION_MODE_END_RANGE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT"),
	SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT"),
	SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT"),
	blend_overlap = {
		conjoint = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_CONJOINT_EXT"),
		end_range = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_END_RANGE_EXT"),
		disjoint = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_DISJOINT_EXT"),
		max_enum = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_MAX_ENUM_EXT"),
		uncorrelated = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
		begin_range = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkBlendOverlapEXT", "VK_BLEND_OVERLAP_RANGE_SIZE_EXT"),
	},
	front_face = {
		counter_clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
		end_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
		max_enum = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
		clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	},
	object_type = {
		swapchain = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
		instance = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INSTANCE"),
		end_range = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_END_RANGE"),
		buffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER"),
		command_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_POOL"),
		fence = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FENCE"),
		pipeline_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
		event = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_EVENT"),
		pipeline = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE"),
		display = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_KHR"),
		debug_utils_messenger = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"),
		semaphore = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SEMAPHORE"),
		indirect_commands_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX"),
		image_view = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE_VIEW"),
		max_enum = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_MAX_ENUM"),
		sampler_ycbcr_conversion = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR"),
		surface = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SURFACE_KHR"),
		descriptor_update_template = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR"),
		begin_range = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BEGIN_RANGE"),
		image = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_IMAGE"),
		device_memory = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE_MEMORY"),
		descriptor_set_layout = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
		display_mode = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
		buffer_view = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_BUFFER_VIEW"),
		range_size = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RANGE_SIZE"),
		descriptor_set = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_SET"),
		object_table = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_OBJECT_TABLE_NVX"),
		query_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUERY_POOL"),
		framebuffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_FRAMEBUFFER"),
		debug_report_callback = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
		sampler = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SAMPLER"),
		pipeline_cache = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PIPELINE_CACHE"),
		validation_cache = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"),
		device = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DEVICE"),
		physical_device = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
		shader_module = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_SHADER_MODULE"),
		unknown = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_UNKNOWN"),
		queue = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_QUEUE"),
		render_pass = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_RENDER_PASS"),
		descriptor_pool = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
		command_buffer = ffi.cast("enum VkObjectType", "VK_OBJECT_TYPE_COMMAND_BUFFER"),
	},
	display_plane_alpha = {
		flag_bits_max_enum = ffi.cast(
			"enum VkDisplayPlaneAlphaFlagBitsKHR",
			"VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"
		),
		per_pixel = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
		global = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.display_plane_alpha[v]
			end

			return bit.bor(unpack(flags))
		end,
		per_pixel_premultiplied = ffi.cast(
			"enum VkDisplayPlaneAlphaFlagBitsKHR",
			"VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"
		),
		opaque = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	},
	attachment_store_op = {
		end_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
		max_enum = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
		range_size = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
		begin_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
		dont_care = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
		store = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	},
	descriptor_pool_create = {
		update_after_bind = ffi.cast(
			"enum VkDescriptorPoolCreateFlagBits",
			"VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.descriptor_pool_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		free_descriptor_set = ffi.cast(
			"enum VkDescriptorPoolCreateFlagBits",
			"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"
		),
		flag_bits_max_enum = ffi.cast(
			"enum VkDescriptorPoolCreateFlagBits",
			"VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"
		),
	},
	access = {
		color_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
		transfer_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
		memory_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
		shader_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
		uniform_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
		host_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
		host_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
		color_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
		shader_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
		depth_stencil_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
		memory_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
		vertex_attribute_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
		depth_stencil_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
		command_process_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"),
		input_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
		color_attachment_read_noncoherent = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
		index_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
		command_process_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.access[v]
			end

			return bit.bor(unpack(flags))
		end,
		indirect_command_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
		transfer_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	},
	internal_allocation_type = {
		end_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
		executable = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
		begin_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	},
	pipeline_create = {
		flag_bits_max_enum = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
		disable_optimization = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
		view_index_from_device_index = ffi.cast(
			"enum VkPipelineCreateFlagBits",
			"VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR"
		),
		derivative = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
		allow_derivatives = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.pipeline_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		dispatch_base = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR"),
	},
	display_power_state = {
		suspend = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
		off = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_OFF_EXT"),
		max_enum = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT"),
		end_range = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_END_RANGE_EXT"),
		begin_range = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT"),
		on = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_ON_EXT"),
		range_size = ffi.cast("enum VkDisplayPowerStateEXT", "VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT"),
	},
	swapchain_create = {
		flag_bits_max_enum = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.swapchain_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		protected = ffi.cast("enum VkSwapchainCreateFlagBitsKHR", "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"),
		split_instance_bind_regions = ffi.cast(
			"enum VkSwapchainCreateFlagBitsKHR",
			"VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"
		),
	},
	indirect_commands_token_type = {
		type_push_constant = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX"
		),
		type_max_enum = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX"
		),
		type_pipeline = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX"
		),
		type_dispatch = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX"
		),
		type_index_buffer = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX"
		),
		type_end_range = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX"
		),
		type_vertex_buffer = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX"
		),
		type_begin_range = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX"
		),
		type_range_size = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX"
		),
		type_draw = ffi.cast("enum VkIndirectCommandsTokenTypeNVX", "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX"),
		type_draw_indexed = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX"
		),
		type_descriptor_set = ffi.cast(
			"enum VkIndirectCommandsTokenTypeNVX",
			"VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX"
		),
	},
	memory_allocate = {
		flag_bits_max_enum = ffi.cast("enum VkMemoryAllocateFlagBits", "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.memory_allocate[v]
			end

			return bit.bor(unpack(flags))
		end,
		device_mask = ffi.cast("enum VkMemoryAllocateFlagBits", "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR"),
	},
	blend_op = {
		softlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SOFTLIGHT_EXT"),
		hardlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDLIGHT_EXT"),
		src_out = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OUT_EXT"),
		dst_atop = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_ATOP_EXT"),
		contrast = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_CONTRAST_EXT"),
		colordodge = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORDODGE_EXT"),
		hsl_hue = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_HUE_EXT"),
		exclusion = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_EXCLUSION_EXT"),
		minus_clamped = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_CLAMPED_EXT"),
		dst = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_EXT"),
		multiply = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MULTIPLY_EXT"),
		dst_in = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_IN_EXT"),
		end_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
		pinlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PINLIGHT_EXT"),
		min = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
		max_enum = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
		dst_out = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OUT_EXT"),
		lighten = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LIGHTEN_EXT"),
		src_in = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_IN_EXT"),
		range_size = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
		difference = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DIFFERENCE_EXT"),
		begin_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
		plus_clamped = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_EXT"),
		hsl_saturation = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_SATURATION_EXT"),
		green = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_GREEN_EXT"),
		red = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RED_EXT"),
		add = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
		plus_darker = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_DARKER_EXT"),
		plus = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_EXT"),
		vividlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_VIVIDLIGHT_EXT"),
		minus = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MINUS_EXT"),
		hardmix = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HARDMIX_EXT"),
		plus_clamped_alpha = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
		hsl_luminosity = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
		colorburn = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_COLORBURN_EXT"),
		hsl_color = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_HSL_COLOR_EXT"),
		zero = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ZERO_EXT"),
		overlay = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_OVERLAY_EXT"),
		blue = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BLUE_EXT"),
		max = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
		linearlight = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARLIGHT_EXT"),
		src_atop = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_ATOP_EXT"),
		invert = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_EXT"),
		invert_rgb = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_RGB_EXT"),
		reverse_subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
		screen = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SCREEN_EXT"),
		src = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_EXT"),
		linearburn = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARBURN_EXT"),
		lineardodge = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_LINEARDODGE_EXT"),
		dst_over = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DST_OVER_EXT"),
		darken = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_DARKEN_EXT"),
		subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
		invert_ovg = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_INVERT_OVG_EXT"),
		src_over = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SRC_OVER_EXT"),
		xor = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_XOR_EXT"),
	},
	conservative_rasterization_mode = {
		underestimate = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"
		),
		end_range = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT"
		),
		max_enum = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT"
		),
		disabled = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"
		),
		begin_range = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT"
		),
		overestimate = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"
		),
		range_size = ffi.cast(
			"enum VkConservativeRasterizationModeEXT",
			"VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT"
		),
	},
	descriptor_set_layout_create = {
		flag_bits_max_enum = ffi.cast(
			"enum VkDescriptorSetLayoutCreateFlagBits",
			"VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.descriptor_set_layout_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		update_after_bind_pool = ffi.cast(
			"enum VkDescriptorSetLayoutCreateFlagBits",
			"VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT"
		),
		push_descriptor = ffi.cast(
			"enum VkDescriptorSetLayoutCreateFlagBits",
			"VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"
		),
	},
	debug_utils_message_type = {
		flag_bits_max_enum = ffi.cast(
			"enum VkDebugUtilsMessageTypeFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT"
		),
		performance = ffi.cast(
			"enum VkDebugUtilsMessageTypeFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"
		),
		validation = ffi.cast(
			"enum VkDebugUtilsMessageTypeFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.debug_utils_message_type[v]
			end

			return bit.bor(unpack(flags))
		end,
		general = ffi.cast(
			"enum VkDebugUtilsMessageTypeFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"
		),
	},
	external_memory_feature = {
		exportable = ffi.cast(
			"enum VkExternalMemoryFeatureFlagBits",
			"VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR"
		),
		dedicated_only = ffi.cast(
			"enum VkExternalMemoryFeatureFlagBits",
			"VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_memory_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalMemoryFeatureFlagBits",
			"VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"
		),
		importable = ffi.cast(
			"enum VkExternalMemoryFeatureFlagBits",
			"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR"
		),
	},
	object_entry_type = {
		descriptor_set = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX"),
		end_range = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX"),
		max_enum = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX"),
		index_buffer = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX"),
		vertex_buffer = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX"),
		push_constant = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX"),
		begin_range = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX"),
		pipeline = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX"),
		range_size = ffi.cast("enum VkObjectEntryTypeNVX", "VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX"),
	},
	structure_type = {
		bind_image_memory_swapchain_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
		pipeline_input_assembly_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"
		),
		pipeline_viewport_w_scaling_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"
		),
		pipeline_dynamic_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
		display_present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
		device_generated_commands_limits = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"),
		physical_device_sample_locations_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"
		),
		descriptor_set_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
		export_semaphore_win32_handle_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"
		),
		compute_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
		present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
		sampler_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
		cmd_process_commands_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"),
		debug_utils_object_tag_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
		physical_device_image_format_info_2 = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR"
		),
		loader_instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
		buffer_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
		dedicated_allocation_image_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"
		),
		command_buffer_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
		write_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
		physical_device_maintenance_3_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR"
		),
		image_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
		device_group_submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR"),
		dedicated_allocation_buffer_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"
		),
		image_swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
		device_group_render_pass_begin_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR"
		),
		device_event_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
		xcb_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
		import_fence_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
		command_buffer_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
		format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR"),
		graphics_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
		event_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
		physical_device_memory_properties_2 = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR"
		),
		instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
		device_group_device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR"),
		debug_marker_object_tag_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
		image_view_usage_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR"),
		physical_device_descriptor_indexing_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"
		),
		max_enum = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
		image_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
		range_size = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
		descriptor_set_variable_descriptor_count_allocate_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"
		),
		end_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
		physical_device_external_semaphore_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"
		),
		memory_dedicated_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"),
		bind_sparse_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
		memory_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
		fence_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
		begin_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
		memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
		queue_family_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR"),
		mapped_memory_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
		render_pass_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
		pipeline_cache_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
		sampler_reduction_mode_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"
		),
		device_group_bind_sparse_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR"),
		memory_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
		import_memory_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
		physical_device_shader_core_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"
		),
		wayland_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
		sampler_ycbcr_conversion_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR"
		),
		physical_device_external_memory_host_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"
		),
		image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
		vi_surface_create_info_nn = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
		memory_host_pointer_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"),
		import_semaphore_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
		fence_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
		display_power_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
		physical_device_external_fence_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"
		),
		export_semaphore_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"),
		shader_module_validation_cache_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"
		),
		physical_device_descriptor_indexing_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"
		),
		framebuffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
		memory_win32_handle_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
		descriptor_set_variable_descriptor_count_layout_support = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"
		),
		buffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
		sampler_ycbcr_conversion_image_format_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR"
		),
		validation_cache_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"),
		import_android_hardware_buffer_info_android = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"
		),
		pipeline_coverage_modulation_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"
		),
		acquire_next_image_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"),
		debug_utils_messenger_callback_data = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"
		),
		pipeline_color_blend_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"
		),
		pipeline_coverage_to_color_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"
		),
		descriptor_update_template_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"
		),
		physical_device_blend_operation_advanced_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"
		),
		physical_device_blend_operation_advanced_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"
		),
		display_mode_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
		external_semaphore_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"),
		pipeline_viewport_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
		image_format_list_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"),
		multisample_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"),
		pipeline_sample_locations_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"
		),
		export_fence_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		render_pass_sample_locations_begin_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"
		),
		import_semaphore_win32_handle_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"
		),
		sample_locations_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"),
		hdr_metadata = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
		pipeline_vertex_input_divisor_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"
		),
		render_pass_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
		external_format_android = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"),
		memory_allocate_flags_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR"),
		d3d12_fence_submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
		pipeline_rasterization_state_rasterization_order = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"
		),
		device_generated_commands_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"
		),
		android_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
		pipeline_depth_stencil_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"
		),
		device_queue_global_priority_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"
		),
		surface_capabilities_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
		command_buffer_inheritance_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
		semaphore_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
		macos_surface_create_info_mvk = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
		ios_surface_create_info_mvk = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
		descriptor_set_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
		physical_device_external_image_format_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"
		),
		display_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
		physical_device_subgroup_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
		memory_get_android_hardware_buffer_info_android = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"
		),
		export_fence_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"),
		physical_device_protected_memory_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"
		),
		physical_device_surface_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
		debug_marker_object_name_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
		bind_image_plane_memory_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR"),
		bind_image_memory_device_group_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR"
		),
		pipeline_rasterization_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"
		),
		import_fence_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		shared_present_surface_capabilities = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"
		),
		buffer_memory_requirements_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		pipeline_rasterization_conservative_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"
		),
		device_group_command_buffer_begin_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR"
		),
		descriptor_set_layout_binding_flags_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"
		),
		submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
		pipeline_discard_rectangle_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"
		),
		physical_device_sampler_ycbcr_conversion_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR"
		),
		dedicated_allocation_memory_allocate_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"
		),
		pipeline_viewport_swizzle_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"
		),
		physical_device_multiview_per_view_attributes_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"
		),
		present_times_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
		physical_device_shader_draw_parameter_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES"
		),
		memory_requirements_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR"),
		external_image_format_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"),
		sparse_image_memory_requirements_2 = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR"
		),
		shader_module_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
		device_group_present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"),
		physical_device_16bit_storage_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR"
		),
		debug_utils_label = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"),
		cmd_reserve_space_for_commands_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"
		),
		indirect_commands_layout_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"
		),
		import_memory_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		mir_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
		present_regions = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
		semaphore_get_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
		bind_buffer_memory_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR"),
		semaphore_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
		import_memory_host_pointer_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
		physical_device_push_descriptor_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"
		),
		android_hardware_buffer_format_properties_android = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"
		),
		device_group_swapchain_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"
		),
		memory_fd_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
		external_memory_buffer_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"
		),
		physical_device_multiview_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR"
		),
		debug_marker_marker_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
		command_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
		physical_device_vertex_attribute_divisor_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"
		),
		physical_device_conservative_rasterization_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"
		),
		external_fence_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"),
		external_memory_image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"),
		xlib_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
		sampler_ycbcr_conversion_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR"),
		buffer_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
		win32_keyed_mutex_acquire_release_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"
		),
		export_memory_win32_handle_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		export_memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"),
		physical_device_external_buffer_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"
		),
		descriptor_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
		object_table_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"),
		texture_lod_gather_format_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"
		),
		device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
		physical_device_group_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR"),
		bind_image_memory_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR"),
		physical_device_discard_rectangle_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"
		),
		debug_report_callback_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
		render_pass_multiview_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR"),
		fence_get_fd_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
		device_queue_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
		memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
		android_hardware_buffer_properties_android = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"
		),
		win32_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
		pipeline_multisample_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"
		),
		image_format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		debug_utils_messenger_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
		swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
		external_buffer_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"),
		memory_dedicated_requirements = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"),
		loader_device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
		copy_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
		render_pass_input_attachment_aspect_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR"
		),
		physical_device_features_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR"),
		physical_device_variable_pointer_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"
		),
		query_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
		android_hardware_buffer_usage_android = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
		display_event_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
		bind_buffer_memory_device_group_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR"
		),
		device_queue_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"),
		pipeline_shader_stage_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
		pipeline_tessellation_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"
		),
		physical_device_sampler_filter_minmax_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"
		),
		swapchain_counter_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
		debug_utils_object_name_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
		physical_device_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR"),
		validation_flags = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
		physical_device_protected_memory_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"
		),
		physical_device_sparse_image_format_info_2 = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR"
		),
		image_memory_requirements_info_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		physical_device_id_properties = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR"),
		pipeline_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
		image_sparse_memory_requirements_info_2 = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR"
		),
		protected_submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"),
		physical_device_multiview_features = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR"
		),
		surface_format_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
		physical_device_point_clipping_properties = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR"
		),
		image_plane_memory_requirements_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR"
		),
		application_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
		pipeline_vertex_input_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"
		),
		sparse_image_format_properties_2 = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		descriptor_set_layout_support = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR"),
		device_group_present_capabilities = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
		pipeline_tessellation_domain_origin_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR"
		),
		pipeline_color_blend_advanced_state_create_info = ffi.cast(
			"enum VkStructureType",
			"VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"
		),
	},
	sampler_reduction_mode = {
		weighted_average = ffi.cast(
			"enum VkSamplerReductionModeEXT",
			"VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"
		),
		end_range = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT"),
		max = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MAX_EXT"),
		begin_range = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT"),
		min = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_MIN_EXT"),
		range_size = ffi.cast("enum VkSamplerReductionModeEXT", "VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT"),
	},
	display_event_type = {
		end_range = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT"),
		begin_range = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT"),
		first_pixel_out = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
		range_size = ffi.cast("enum VkDisplayEventTypeEXT", "VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT"),
	},
	format_feature = {
		sampled_image_filter_linear = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"
		),
		color_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
		sampled_image_filter_cubic_bit_img = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"
		),
		transfer_dst = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR"),
		sampled_image_ycbcr_conversion_chroma_reconstruction_explicit = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR"
		),
		color_attachment_blend = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
		storage_texel_buffer_atomic = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"
		),
		vertex_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
		midpoint_chroma_samples = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR"
		),
		sampled_image_filter_minmax = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT"
		),
		blit_src = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
		cosited_chroma_samples = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR"
		),
		disjoint = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR"),
		storage_image_atomic = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
		transfer_src = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR"),
		sampled_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
		sampled_image_ycbcr_conversion_separate_reconstruction_filter = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR"
		),
		sampled_image_ycbcr_conversion_linear_filter = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR"
		),
		flag_bits_max_enum = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
		storage_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
		blit_dst = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
		depth_stencil_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		storage_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.format_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		uniform_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
		sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable = ffi.cast(
			"enum VkFormatFeatureFlagBits",
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR"
		),
	},
	command_buffer_usage = {
		render_pass_continue = ffi.cast(
			"enum VkCommandBufferUsageFlagBits",
			"VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"
		),
		simultaneous_use = ffi.cast(
			"enum VkCommandBufferUsageFlagBits",
			"VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.command_buffer_usage[v]
			end

			return bit.bor(unpack(flags))
		end,
		one_time_submit = ffi.cast(
			"enum VkCommandBufferUsageFlagBits",
			"VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"
		),
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	},
	query_control = {
		flag_bits_max_enum = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.query_control[v]
			end

			return bit.bor(unpack(flags))
		end,
		precise = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	},
	logic_op = {
		["or"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
		invert = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
		max_enum = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
		or_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
		nor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
		nand = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
		begin_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
		end_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
		set = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
		and_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
		["and"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
		or_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
		copy_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
		no_op = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
		copy = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
		and_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
		equivalent = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
		clear = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
		xor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	},
	command_pool_create = {
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
		protected = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_PROTECTED_BIT"),
		transient = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.command_pool_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		reset_command_buffer = ffi.cast(
			"enum VkCommandPoolCreateFlagBits",
			"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"
		),
	},
	pipeline_stage = {
		tessellation_control_shader = ffi.cast(
			"enum VkPipelineStageFlagBits",
			"VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"
		),
		host = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
		draw_indirect = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
		tessellation_evaluation_shader = ffi.cast(
			"enum VkPipelineStageFlagBits",
			"VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
		),
		color_attachment_output = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
		command_process = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"),
		early_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
		all_commands = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
		all_graphics = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
		top_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
		compute_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
		vertex_input = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
		transfer = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
		bottom_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
		late_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
		geometry_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.pipeline_stage[v]
			end

			return bit.bor(unpack(flags))
		end,
		vertex_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
		fragment_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	},
	external_semaphore_handle_type = {
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
		),
		opaque_win32_kmt = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"
		),
		opaque_fd = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
		),
		sync_fd = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_semaphore_handle_type[v]
			end

			return bit.bor(unpack(flags))
		end,
		opaque_win32 = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"
		),
		d3d12_fence = ffi.cast(
			"enum VkExternalSemaphoreHandleTypeFlagBits",
			"VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR"
		),
	},
	discard_rectangle_mode = {
		end_range = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT"),
		exclusive = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
		begin_range = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT"),
		inclusive = ffi.cast("enum VkDiscardRectangleModeEXT", "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
	},
	command_buffer_level = {
		end_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
		secondary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
		max_enum = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
		begin_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
		primary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
		range_size = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	},
	present_mode = {
		fifo = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
		mailbox = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
		end_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
		max_enum = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
		fifo_relaxed = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
		shared_continuous_refresh = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
		immediate = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
		begin_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
		shared_demand_refresh = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
		range_size = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	},
	stencil_face = {
		front_and_back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
		back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
		front = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.stencil_face[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	},
	stencil_op = {
		invert = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
		max_enum = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
		decrement_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
		increment_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
		end_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
		replace = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
		decrement_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
		zero = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
		increment_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
		keep = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
		range_size = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	},
	sampler_mipmap_mode = {
		linear = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
		nearest = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
		max_enum = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
		range_size = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	},
	sampler_address_mode = {
		end_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
		["repeat"] = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
		clamp_to_border = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
		mirrored_repeat = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
		max_enum = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
		clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
		begin_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
		mirror_clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
		range_size = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	},
	device_event_type = {
		end_range = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_END_RANGE_EXT"),
		display_hotplug = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
		begin_range = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT"),
		range_size = ffi.cast("enum VkDeviceEventTypeEXT", "VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT"),
	},
	debug_report = {
		warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
		flag_bits_max_enum = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
		performance_warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
		debug = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.debug_report[v]
			end

			return bit.bor(unpack(flags))
		end,
		error = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
		information = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	},
	debug_report_object_type = {
		swapchain = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"
		),
		instance = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
		end_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
		buffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
		command_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
		object_table = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"
		),
		pipeline_layout = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"
		),
		event = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
		pipeline = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
		display = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
		semaphore = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
		validation_cache_ext = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"
		),
		image_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
		debug_report_callback_ext = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"
		),
		sampler_ycbcr_conversion = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT"
		),
		surface = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
		descriptor_update_template = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT"
		),
		max_enum = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
		image = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
		device_memory = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"
		),
		begin_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
		display_mode = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"
		),
		buffer_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
		range_size = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
		descriptor_set = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"
		),
		indirect_commands_layout = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"
		),
		query_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
		framebuffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
		sampler = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
		descriptor_set_layout = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"
		),
		pipeline_cache = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"
		),
		device = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
		physical_device = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"
		),
		fence = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
		shader_module = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"
		),
		unknown = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
		queue = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
		render_pass = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
		descriptor_pool = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"
		),
		command_buffer = ffi.cast(
			"enum VkDebugReportObjectTypeEXT",
			"VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"
		),
	},
	fence_import = {
		flag_bits_max_enum = ffi.cast("enum VkFenceImportFlagBits", "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.fence_import[v]
			end

			return bit.bor(unpack(flags))
		end,
		temporary = ffi.cast("enum VkFenceImportFlagBits", "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR"),
	},
	queue = {
		flag_bits_max_enum = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
		protected = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_PROTECTED_BIT"),
		sparse_binding = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
		compute = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.queue[v]
			end

			return bit.bor(unpack(flags))
		end,
		graphics = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
		transfer = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	},
	system_allocation_scope = {
		object = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
		end_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
		max_enum = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
		cache = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
		command = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
		device = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
		begin_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
		instance = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
		range_size = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	},
	image_create = {
		protected = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_PROTECTED_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
		disjoint = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_DISJOINT_BIT_KHR"),
		cube_compatible = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
		sample_locations_compatible_depth = ffi.cast(
			"enum VkImageCreateFlagBits",
			"VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"
		),
		extended_usage = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR"),
		split_instance_bind_regions = ffi.cast(
			"enum VkImageCreateFlagBits",
			"VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"
		),
		block_texel_view_compatible = ffi.cast(
			"enum VkImageCreateFlagBits",
			"VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR"
		),
		sparse_aliased = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
		sparse_binding = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
		alias = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_ALIAS_BIT_KHR"),
		mutable_format = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.image_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		["2d_array_compatible"] = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR"),
		sparse_residency = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	indirect_commands_layout_usage = {
		flag_bits_max_enum = ffi.cast(
			"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
			"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX"
		),
		sparse_sequences = ffi.cast(
			"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
			"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"
		),
		empty_executions = ffi.cast(
			"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
			"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.indirect_commands_layout_usage[v]
			end

			return bit.bor(unpack(flags))
		end,
		indexed_sequences = ffi.cast(
			"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
			"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"
		),
		unordered_sequences = ffi.cast(
			"enum VkIndirectCommandsLayoutUsageFlagBitsNVX",
			"VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"
		),
	},
	memory_property = {
		device_local = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
		host_coherent = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
		host_cached = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
		lazily_allocated = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.memory_property[v]
			end

			return bit.bor(unpack(flags))
		end,
		protected = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_PROTECTED_BIT"),
		host_visible = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	},
	subgroup_feature = {
		clustered = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_CLUSTERED_BIT"),
		arithmetic = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"),
		ballot = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_BALLOT_BIT"),
		shuffle = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_SHUFFLE_BIT"),
		partitioned = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"),
		shuffle_relative = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"),
		quad = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_QUAD_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.subgroup_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		vote = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_VOTE_BIT"),
		basic = ffi.cast("enum VkSubgroupFeatureFlagBits", "VK_SUBGROUP_FEATURE_BASIC_BIT"),
	},
	viewport_coordinate_swizzle = {
		negative_z = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"
		),
		negative_y = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"
		),
		negative_x = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"
		),
		max_enum = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV"
		),
		negative_w = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"
		),
		positive_z = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"
		),
		positive_y = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"
		),
		range_size = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV"
		),
		end_range = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV"
		),
		positive_x = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"
		),
		begin_range = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV"
		),
		positive_w = ffi.cast(
			"enum VkViewportCoordinateSwizzleNV",
			"VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"
		),
	},
	image_tiling = {
		linear = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
		end_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
		max_enum = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
		optimal = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	},
	physical_device_type = {
		integrated_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
		end_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
		other = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
		max_enum = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
		virtual_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
		discrete_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
		cpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
		begin_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	},
	composite_alpha = {
		flag_bits_max_enum = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
		opaque = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.composite_alpha[v]
			end

			return bit.bor(unpack(flags))
		end,
		post_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
		inherit = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
		pre_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	},
	external_semaphore_feature = {
		exportable = ffi.cast(
			"enum VkExternalSemaphoreFeatureFlagBits",
			"VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_semaphore_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalSemaphoreFeatureFlagBits",
			"VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM"
		),
		importable = ffi.cast(
			"enum VkExternalSemaphoreFeatureFlagBits",
			"VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR"
		),
	},
	command_pool_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.command_pool_reset[v]
			end

			return bit.bor(unpack(flags))
		end,
		release_resources = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	},
	sparse_memory_bind = {
		metadata = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.sparse_memory_bind[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	},
	query_result = {
		flag_bits_max_enum = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
		["64"] = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
		with_availability = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.query_result[v]
			end

			return bit.bor(unpack(flags))
		end,
		partial = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
		wait = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	},
	sampler_ycbcr_model_conversion = {
		ycbcr_identity = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR"
		),
		end_range = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE"
		),
		max_enum = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM"
		),
		ycbcr_601 = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR"
		),
		rgb_identity = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR"
		),
		ycbcr_2020 = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR"
		),
		begin_range = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE"
		),
		ycbcr_709 = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR"
		),
		range_size = ffi.cast(
			"enum VkSamplerYcbcrModelConversion",
			"VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE"
		),
	},
	device_queue_create = {
		flag_bits_max_enum = ffi.cast("enum VkDeviceQueueCreateFlagBits", "VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.device_queue_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		protected = ffi.cast("enum VkDeviceQueueCreateFlagBits", "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT"),
	},
	pipeline_bind_point = {
		end_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
		compute = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
		begin_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
		graphics = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	},
	blend_factor = {
		src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
		max_enum = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
		one_minus_dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
		one_minus_src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
		constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
		one_minus_constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
		one_minus_src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
		zero = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
		range_size = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
		one_minus_dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
		one_minus_src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
		src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
		dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
		src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
		dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
		one_minus_constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
		end_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
		src_alpha_saturate = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
		constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
		begin_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
		src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
		one_minus_src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
		one = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	},
	image_aspect = {
		plane_1 = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR"),
		stencil = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
		plane_0 = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR"),
		depth = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
		metadata = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.image_aspect[v]
			end

			return bit.bor(unpack(flags))
		end,
		color = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
		plane_2 = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR"),
	},
	command_buffer_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.command_buffer_reset[v]
			end

			return bit.bor(unpack(flags))
		end,
		release_resources = ffi.cast(
			"enum VkCommandBufferResetFlagBits",
			"VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"
		),
	},
	vertex_input_rate = {
		end_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
		max_enum = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
		vertex = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
		instance = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
		begin_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	},
	dynamic_state = {
		blend_constants = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
		stencil_write_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
		sample_locations = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"),
		viewport_w_scaling = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
		viewport = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
		depth_bias = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
		max_enum = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
		line_width = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
		stencil_compare_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
		end_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
		discard_rectangle = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
		begin_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
		depth_bounds = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
		scissor = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
		stencil_reference = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
		range_size = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	},
	query_pipeline_statistic = {
		clipping_primitives = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"
		),
		fragment_shader_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"
		),
		geometry_shader_primitives = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"
		),
		input_assembly_primitives = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"
		),
		compute_shader_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"
		),
		flag_bits_max_enum = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"
		),
		tessellation_evaluation_shader_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"
		),
		tessellation_control_shader_patches = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"
		),
		vertex_shader_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"
		),
		clipping_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.query_pipeline_statistic[v]
			end

			return bit.bor(unpack(flags))
		end,
		geometry_shader_invocations = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"
		),
		input_assembly_vertices = ffi.cast(
			"enum VkQueryPipelineStatisticFlagBits",
			"VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"
		),
	},
	validation_check = {
		end_range = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_END_RANGE_EXT"),
		max_enum = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_MAX_ENUM_EXT"),
		shaders = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_SHADERS_EXT"),
		begin_range = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_RANGE_SIZE_EXT"),
		all = ffi.cast("enum VkValidationCheckEXT", "VK_VALIDATION_CHECK_ALL_EXT"),
	},
	external_fence_handle_type = {
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalFenceHandleTypeFlagBits",
			"VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
		),
		opaque_win32_kmt = ffi.cast(
			"enum VkExternalFenceHandleTypeFlagBits",
			"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"
		),
		opaque_fd = ffi.cast(
			"enum VkExternalFenceHandleTypeFlagBits",
			"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
		),
		sync_fd = ffi.cast(
			"enum VkExternalFenceHandleTypeFlagBits",
			"VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_fence_handle_type[v]
			end

			return bit.bor(unpack(flags))
		end,
		opaque_win32 = ffi.cast(
			"enum VkExternalFenceHandleTypeFlagBits",
			"VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"
		),
	},
	polygon_mode = {
		line = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
		max_enum = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
		end_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
		fill_rectangle = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
		begin_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
		point = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
		fill = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
		range_size = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	},
	surface_counter = {
		flag_bits_max_enum = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.surface_counter[v]
			end

			return bit.bor(unpack(flags))
		end,
		vblank = ffi.cast("enum VkSurfaceCounterFlagBitsEXT", "VK_SURFACE_COUNTER_VBLANK_EXT"),
	},
	device_group_present_mode = {
		remote = ffi.cast(
			"enum VkDeviceGroupPresentModeFlagBitsKHR",
			"VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"
		),
		sum = ffi.cast(
			"enum VkDeviceGroupPresentModeFlagBitsKHR",
			"VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"
		),
		["local"] = ffi.cast(
			"enum VkDeviceGroupPresentModeFlagBitsKHR",
			"VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.device_group_present_mode[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkDeviceGroupPresentModeFlagBitsKHR",
			"VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR"
		),
		local_multi_device = ffi.cast(
			"enum VkDeviceGroupPresentModeFlagBitsKHR",
			"VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR"
		),
	},
	cull_mode = {
		none = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
		back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
		front = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.cull_mode[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
		front_and_back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	},
	semaphore_import = {
		flag_bits_max_enum = ffi.cast("enum VkSemaphoreImportFlagBits", "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.semaphore_import[v]
			end

			return bit.bor(unpack(flags))
		end,
		temporary = ffi.cast("enum VkSemaphoreImportFlagBits", "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR"),
	},
	border_color = {
		end_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
		float_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
		float_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
		max_enum = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
		int_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
		range_size = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
		int_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
		begin_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
		int_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
		float_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	},
	sparse_image_format = {
		nonstandard_block_size = ffi.cast(
			"enum VkSparseImageFormatFlagBits",
			"VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"
		),
		aligned_mip_size = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.sparse_image_format[v]
			end

			return bit.bor(unpack(flags))
		end,
		single_miptail = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	},
	buffer_create = {
		flag_bits_max_enum = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
		sparse_aliased = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
		protected = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_PROTECTED_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.buffer_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		sparse_binding = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
		sparse_residency = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	tessellation_domain_origin = {
		end_range = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE"),
		max_enum = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM"),
		lower_left = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR"),
		begin_range = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE"),
		upper_left = ffi.cast("enum VkTessellationDomainOrigin", "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR"),
	},
	rasterization_order = {
		relaxed = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
		end_range = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
		strict = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
		begin_range = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
		max_enum = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
		range_size = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
	},
	image_usage = {
		sampled = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
		color_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
		transfer_src = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
		input_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
		transfer_dst = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
		depth_stencil_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.image_usage[v]
			end

			return bit.bor(unpack(flags))
		end,
		transient_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
		storage = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	},
	external_fence_feature = {
		exportable = ffi.cast(
			"enum VkExternalFenceFeatureFlagBits",
			"VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_fence_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalFenceFeatureFlagBits",
			"VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM"
		),
		importable = ffi.cast(
			"enum VkExternalFenceFeatureFlagBits",
			"VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR"
		),
	},
	external_memory_handle_type = {
		d3d11_texture_kmt = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR"
		),
		opaque_win32_kmt = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBitsNV",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"
		),
		opaque_win32 = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBitsNV",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"
		),
		dma_buf = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"
		),
		d3d11_image_kmt = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBitsNV",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"
		),
		host_allocation = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"
		),
		d3d11_image = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBitsNV",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"
		),
		host_mapped_foreign_memory = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"
		),
		flag_bits_max_enum = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBitsNV",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"
		),
		opaque_fd = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"
		),
		d3d11_texture = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR"
		),
		android_hardware_buffer_bit_android = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.external_memory_handle_type[v]
			end

			return bit.bor(unpack(flags))
		end,
		d3d12_resource = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR"
		),
		d3d12_heap = ffi.cast(
			"enum VkExternalMemoryHandleTypeFlagBits",
			"VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR"
		),
	},
	object_entry_usage = {
		compute = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.object_entry_usage[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkObjectEntryUsageFlagBitsNVX",
			"VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX"
		),
		graphics = ffi.cast("enum VkObjectEntryUsageFlagBitsNVX", "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"),
	},
	subpass_description = {
		per_view_position_x_only = ffi.cast(
			"enum VkSubpassDescriptionFlagBits",
			"VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.subpass_description[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkSubpassDescriptionFlagBits", "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
		per_view_attributes = ffi.cast(
			"enum VkSubpassDescriptionFlagBits",
			"VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"
		),
	},
	shader_info_type = {
		statistics = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_STATISTICS_AMD"),
		disassembly = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"),
		max_enum = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_MAX_ENUM_AMD"),
		end_range = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_END_RANGE_AMD"),
		begin_range = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD"),
		binary = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_BINARY_AMD"),
		range_size = ffi.cast("enum VkShaderInfoTypeAMD", "VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD"),
	},
	image_layout = {
		preinitialized = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
		general = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
		depth_attachment_stencil_read_only_optimal = ffi.cast(
			"enum VkImageLayout",
			"VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR"
		),
		transfer_src_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
		depth_stencil_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
		begin_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
		present_src = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
		undefined = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
		color_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
		depth_stencil_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
		shader_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
		max_enum = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
		depth_read_only_stencil_attachment_optimal = ffi.cast(
			"enum VkImageLayout",
			"VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR"
		),
		shared_present = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
		end_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
		transfer_dst_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
	},
	image_type = {
		["1d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
		end_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
		["2d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
		range_size = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	},
	dependency = {
		device_group = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR"),
		view_local = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.dependency[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
		by_region = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	},
	surface_transform = {
		identity = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
		rotate_90 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
		rotate_180 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
		horizontal_mirror_rotate_180 = ffi.cast(
			"enum VkSurfaceTransformFlagBitsKHR",
			"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"
		),
		horizontal_mirror_rotate_270 = ffi.cast(
			"enum VkSurfaceTransformFlagBitsKHR",
			"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"
		),
		rotate_270 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
		horizontal_mirror = ffi.cast(
			"enum VkSurfaceTransformFlagBitsKHR",
			"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"
		),
		flag_bits_max_enum = ffi.cast(
			"enum VkSurfaceTransformFlagBitsKHR",
			"VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.surface_transform[v]
			end

			return bit.bor(unpack(flags))
		end,
		inherit = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
		horizontal_mirror_rotate_90 = ffi.cast(
			"enum VkSurfaceTransformFlagBitsKHR",
			"VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"
		),
	},
	peer_memory_feature = {
		flag_bits_max_enum = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"),
		generic_src = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR"),
		copy_dst = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.peer_memory_feature[v]
			end

			return bit.bor(unpack(flags))
		end,
		copy_src = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR"),
		generic_dst = ffi.cast("enum VkPeerMemoryFeatureFlagBits", "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR"),
	},
	debug_utils_message_severity = {
		warning = ffi.cast(
			"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"
		),
		verbose = ffi.cast(
			"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"
		),
		info = ffi.cast(
			"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.debug_utils_message_severity[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast(
			"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT"
		),
		error = ffi.cast(
			"enum VkDebugUtilsMessageSeverityFlagBitsEXT",
			"VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"
		),
	},
	point_clipping_behavior = {
		end_range = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_END_RANGE"),
		all_clip_planes = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR"),
		max_enum = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM"),
		begin_range = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE"),
		user_clip_planes_only = ffi.cast(
			"enum VkPointClippingBehavior",
			"VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR"
		),
		range_size = ffi.cast("enum VkPointClippingBehavior", "VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE"),
	},
	descriptor_type = {
		max_enum = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
		sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
		storage_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
		sampled_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
		input_attachment = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
		uniform_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
		combined_image_sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
		storage_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
		uniform_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
		end_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
		storage_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
		begin_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
		uniform_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
		storage_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
		range_size = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	},
	attachment_load_op = {
		load = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
		dont_care = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
		max_enum = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
		end_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
		clear = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
		range_size = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	},
	chroma_location = {
		midpoint = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_MIDPOINT_KHR"),
		end_range = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_END_RANGE"),
		cosited_even = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_COSITED_EVEN_KHR"),
		begin_range = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_BEGIN_RANGE"),
		max_enum = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_MAX_ENUM"),
		range_size = ffi.cast("enum VkChromaLocation", "VK_CHROMA_LOCATION_RANGE_SIZE"),
	},
	format = {
		r64g64b64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
		b8g8r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
		r8g8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
		r8g8b8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
		r64g64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
		astc_5x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
		begin_range = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
		r8g8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
		eac_r11g11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
		astc_10x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
		a2r10g10b10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
		d32_sfloat_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
		g16b16g16r16_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16B16G16R16_422_UNORM_KHR"),
		astc_12x12_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
		r8g8b8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
		r64g64b64a64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
		g12x4_b12x4_r12x4_3plane_444_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR"),
		b8g8r8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
		d16_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
		r8g8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
		r16g16b16a16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
		r64g64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
		range_size = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
		g16_b16_r16_3plane_420_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR"),
		r16g16b16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
		r8g8b8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
		pvrtc1_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
		pvrtc2_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
		r8g8b8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
		etc2_r8g8b8a1_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
		d24_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
		pvrtc1_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
		pvrtc1_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
		a2b10g10r10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
		astc_12x12_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
		r16g16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
		g16_b16_r16_3plane_444_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR"),
		g16_b16r16_2plane_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR"),
		g16_b16_r16_3plane_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR"),
		g16_b16r16_2plane_420_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR"),
		s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
		r16g16b16a16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
		r8g8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
		pvrtc2_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
		pvrtc1_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
		pvrtc2_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
		r64g64b64a64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
		r64g64b64a64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
		g12x4_b12x4r12x4_2plane_422_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR"),
		a2r10g10b10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
		g12x4_b12x4_r12x4_3plane_422_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR"),
		g12x4_b12x4r12x4_2plane_420_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR"),
		r12x4g12x4b12x4a12x4_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR"),
		r16g16b16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
		r16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
		r10x6_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6_UNORM_PACK16_KHR"),
		r8g8b8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
		r16g16b16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
		r32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
		r12x4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4_UNORM_PACK16_KHR"),
		b12x4g12x4r12x4g12x4_422_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR"),
		r16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
		bc1_rgba_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
		r16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
		a8b8g8r8_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
		g12x4b12x4g12x4r12x4_422_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR"),
		r12x4g12x4_unorm_2pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR"),
		g10x6_b10x6_r10x6_3plane_444_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR"),
		g10x6_b10x6r10x6_2plane_422_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR"),
		g10x6_b10x6_r10x6_3plane_422_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR"),
		b10x6g10x6r10x6g10x6_422_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR"),
		g8_b8_r8_3plane_420_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR"),
		b8g8r8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
		b10g11r11_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
		g10x6_b10x6r10x6_2plane_420_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR"),
		g10x6b10x6g10x6r10x6_422_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR"),
		r10x6g10x6b10x6a10x6_unorm_4pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR"),
		g10x6_b10x6_r10x6_3plane_420_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR"),
		bc1_rgba_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
		g12x4_b12x4_r12x4_3plane_420_unorm_3pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR"),
		g8_b8_r8_3plane_444_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR"),
		g8_b8r8_2plane_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR"),
		etc2_r8g8b8a8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
		r8g8b8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
		g8_b8_r8_3plane_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR"),
		bc4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
		g8_b8r8_2plane_420_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR"),
		bc5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
		astc_10x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
		r8g8b8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
		r10x6g10x6_unorm_2pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR"),
		astc_5x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
		a8b8g8r8_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
		r8g8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
		r32g32b32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
		bc7_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
		g8b8g8r8_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_G8B8G8R8_422_UNORM_KHR"),
		astc_12x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
		etc2_r8g8b8a8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
		eac_r11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
		astc_12x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
		astc_10x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
		r5g6b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
		r32g32b32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
		r64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
		astc_10x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
		r32g32b32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
		bc1_rgb_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
		r64g64b64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
		etc2_r8g8b8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
		a2b10g10r10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
		r4g4_unorm_pack8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
		astc_10x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
		e5b9g9r9_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
		astc_10x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
		r16g16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
		r32g32b32a32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
		astc_8x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
		astc_8x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
		astc_8x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
		a8b8g8r8_srgb_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
		b8g8r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
		r16g16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
		astc_5x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
		astc_6x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
		astc_8x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
		a8b8g8r8_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
		astc_8x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
		r8g8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
		r32g32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
		astc_6x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
		astc_6x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
		r16g16b16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
		astc_6x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
		b8g8r8g8_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8G8_422_UNORM_KHR"),
		r32g32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
		astc_5x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
		a8b8g8r8_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
		r64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
		astc_4x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
		max_enum = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
		a2b10g10r10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
		eac_r11g11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
		a8b8g8r8_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
		a2b10g10r10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
		bc2_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
		x8_d24_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
		r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
		b8g8r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
		a1r5g5b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
		b5g6r5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
		r16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
		b8g8r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
		undefined = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
		eac_r11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
		etc2_r8g8b8a1_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
		r16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
		a2r10g10b10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
		pvrtc2_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
		r16g16b16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
		r16g16b16a16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
		bc3_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
		b8g8r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
		b8g8r8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
		etc2_r8g8b8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
		bc7_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
		r16g16b16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
		d32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
		bc6h_ufloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
		r64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
		bc5_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
		r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
		bc4_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
		r16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
		bc3_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
		bc2_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
		r32g32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
		bc1_rgb_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
		astc_10x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
		r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
		b8g8r8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
		r8g8b8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
		astc_4x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
		r8g8b8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
		a2r10g10b10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
		end_range = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
		b8g8r8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
		b5g5r5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
		astc_10x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
		astc_8x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
		r16g16b16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
		b4g4r4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
		a2r10g10b10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
		r16g16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
		r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
		r16g16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
		r8g8b8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
		a8b8g8r8_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
		b8g8r8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
		r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
		r8g8b8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
		r8g8b8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
		b16g16r16g16_422_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B16G16R16G16_422_UNORM_KHR"),
		b8g8r8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
		r8g8b8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
		r8g8b8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
		r64g64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
		a2b10g10r10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
		r64g64b64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
		r16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
		a2r10g10b10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
		a2b10g10r10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
		r16g16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
		r4g4b4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
		r16g16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
		bc6h_sfloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
		b8g8r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
		r5g5b5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
		r8g8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
		r16g16b16a16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
		r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
		r16g16b16a16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
		r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
		r16g16b16a16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
		r16g16b16a16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
		d16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
		b8g8r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
		r32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
		r32g32b32a32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
		r32g32b32a32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
		r32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	},
	component_swizzle = {
		identity = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
		one = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
		max_enum = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
		g = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
		b = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
		zero = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
		end_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
		r = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
		begin_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
		a = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
		range_size = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	},
	query_type = {
		occlusion = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
		end_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
		pipeline_statistics = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
		timestamp = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
		range_size = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	},
	primitive_topology = {
		line_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
		triangle_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
		end_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
		triangle_fan = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
		max_enum = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
		line_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
		range_size = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
		point_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
		line_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
		line_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
		triangle_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
		triangle_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
		begin_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
		triangle_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
		patch_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	},
	memory_heap = {
		device_local = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.memory_heap[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
		multi_instance = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR"),
	},
	sample_count = {
		["4"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
		["8"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
		["32"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
		["2"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
		["64"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.sample_count[v]
			end

			return bit.bor(unpack(flags))
		end,
		["1"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
		["16"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	},
	image_view_type = {
		["2d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
		end_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
		["2d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
		["1d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
		cube = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
		cube_array = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
		begin_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
		["1d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	},
	coverage_modulation_mode = {
		none = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_NONE_NV"),
		max_enum = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV"),
		rgb = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGB_NV"),
		rgba = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
		alpha = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
		begin_range = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV"),
		end_range = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_END_RANGE_NV"),
		range_size = ffi.cast("enum VkCoverageModulationModeNV", "VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV"),
	},
	pipeline_cache_header_version = {
		end_range = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
		begin_range = ffi.cast(
			"enum VkPipelineCacheHeaderVersion",
			"VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"
		),
		one = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
		range_size = ffi.cast(
			"enum VkPipelineCacheHeaderVersion",
			"VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"
		),
	},
	index_type = {
		uint32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
		uint16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
		max_enum = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
		range_size = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	},
	attachment_description = {
		flag_bits_max_enum = ffi.cast(
			"enum VkAttachmentDescriptionFlagBits",
			"VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.attachment_description[v]
			end

			return bit.bor(unpack(flags))
		end,
		may_alias = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	},
	descriptor_update_template_type = {
		descriptor_set = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR"
		),
		end_range = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE"
		),
		push_descriptors = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR"
		),
		begin_range = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE"
		),
		max_enum = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM"
		),
		range_size = ffi.cast(
			"enum VkDescriptorUpdateTemplateType",
			"VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE"
		),
	},
	filter = {
		linear = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
		nearest = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
		max_enum = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
		cubic_img = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
		begin_range = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
		range_size = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	},
	validation_cache_header_version = {
		end_range = ffi.cast(
			"enum VkValidationCacheHeaderVersionEXT",
			"VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT"
		),
		max_enum = ffi.cast(
			"enum VkValidationCacheHeaderVersionEXT",
			"VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT"
		),
		begin_range = ffi.cast(
			"enum VkValidationCacheHeaderVersionEXT",
			"VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT"
		),
		one = ffi.cast(
			"enum VkValidationCacheHeaderVersionEXT",
			"VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"
		),
		range_size = ffi.cast(
			"enum VkValidationCacheHeaderVersionEXT",
			"VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT"
		),
	},
	result = {
		error_validation_failed = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
		error_initialization_failed = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
		event_set = ffi.cast("enum VkResult", "VK_EVENT_SET"),
		suboptimal = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
		error_invalid_shader = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
		error_device_lost = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
		incomplete = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
		event_reset = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
		result_range_size = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
		error_out_of_pool_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_POOL_MEMORY_KHR"),
		error_out_of_date = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
		error_incompatible_display = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
		error_not_permitted = ffi.cast("enum VkResult", "VK_ERROR_NOT_PERMITTED_EXT"),
		error_extension_not_present = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
		error_memory_map_failed = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
		error_feature_not_present = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
		result_end_range = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
		not_ready = ffi.cast("enum VkResult", "VK_NOT_READY"),
		error_too_many_objects = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
		result_max_enum = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
		error_incompatible_driver = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
		error_layer_not_present = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
		error_fragmentation = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTATION_EXT"),
		timeout = ffi.cast("enum VkResult", "VK_TIMEOUT"),
		error_surface_lost = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
		error_invalid_external_handle = ffi.cast("enum VkResult", "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR"),
		error_format_not_supported = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
		error_out_of_device_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
		success = ffi.cast("enum VkResult", "VK_SUCCESS"),
		error_fragmented_pool = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
		error_native_window_in_use = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
		error_out_of_host_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
		result_begin_range = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
	},
	sharing_mode = {
		end_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
		max_enum = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
		exclusive = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
		begin_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
		concurrent = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
		range_size = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	},
	buffer_usage = {
		transfer_src = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
		index_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
		uniform_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
		uniform_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
		vertex_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
		storage_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
		indirect_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.buffer_usage[v]
			end

			return bit.bor(unpack(flags))
		end,
		storage_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
		transfer_dst = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	},
	descriptor_binding = {
		partially_bound = ffi.cast(
			"enum VkDescriptorBindingFlagBitsEXT",
			"VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT"
		),
		flag_bits_max_enum = ffi.cast(
			"enum VkDescriptorBindingFlagBitsEXT",
			"VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT"
		),
		update_after_bind = ffi.cast(
			"enum VkDescriptorBindingFlagBitsEXT",
			"VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
		),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.descriptor_binding[v]
			end

			return bit.bor(unpack(flags))
		end,
		update_unused_while_pending = ffi.cast(
			"enum VkDescriptorBindingFlagBitsEXT",
			"VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT"
		),
		variable_descriptor_count = ffi.cast(
			"enum VkDescriptorBindingFlagBitsEXT",
			"VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"
		),
	},
	subpass_contents = {
		end_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
		inline = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
		secondary_command_buffers = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
		begin_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
		max_enum = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
		range_size = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	},
	color_component = {
		b = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
		r = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.color_component[v]
			end

			return bit.bor(unpack(flags))
		end,
		a = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
		g = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	},
	fence_create = {
		signaled = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.fence_create[v]
			end

			return bit.bor(unpack(flags))
		end,
		flag_bits_max_enum = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	},
	compare_op = {
		not_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
		end_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
		greater_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
		max_enum = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
		never = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
		equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
		less = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
		greater = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
		less_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
		always = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
		begin_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	},
	colorspace = {
		_hdr10_hlg = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_HLG_EXT"),
		_adobergb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
		_display_p3_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
		_end_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
		_bt2020_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
		_bt709_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
		_adobergb_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
		_dci_p3_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT"),
		_begin_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
		_extended_srgb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
		_extended_srgb_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
		_max_enum = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
		_range_size = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
		_srgb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
		_dci_p3_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
		_pass_through = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_PASS_THROUGH_EXT"),
		_bt709_linear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BT709_LINEAR_EXT"),
		_hdr10_st2084 = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_HDR10_ST2084_EXT"),
		_dolbyvision = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_DOLBYVISION_EXT"),
	},
	queue_global_priority = {
		max_enum = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT"),
		medium = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"),
		realtime = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"),
		high = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"),
		end_range = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT"),
		low = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"),
		begin_range = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT"),
		range_size = ffi.cast("enum VkQueueGlobalPriorityEXT", "VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT"),
	},
	sampler_ycbcr_range = {
		end_range = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_END_RANGE"),
		max_enum = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_MAX_ENUM"),
		itu_full = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR"),
		begin_range = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE"),
		itu_narrow = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR"),
		range_size = ffi.cast("enum VkSamplerYcbcrRange", "VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE"),
	},
	shader_stage = {
		compute = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
		fragment = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
		all = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
		flag_bits_max_enum = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
		geometry = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
		all_graphics = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
		vertex = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
		tessellation_control = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
		tessellation_evaluation = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
		make_enums = function(flags)
			if #flags == 0 then return 0 end

			for i, v in ipairs(flags) do
				flags[i] = library.e.shader_stage[v]
			end

			return bit.bor(unpack(flags))
		end,
	},
}

function library.GetInstanceLayerProperties()
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceLayerProperties(count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceLayerProperties(count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDevices(instance)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumeratePhysicalDevices(instance, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDevice_T * [?]", count[0])
	local status = CLIB.vkEnumeratePhysicalDevices(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

--[[
function library.GetInstanceVersion()
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceVersion(, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("unsigned int [?]", count[0])
	local status = CLIB.vkEnumerateInstanceVersion(, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
]] function library.GetInstanceExtensionProperties(pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetDeviceLayerProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceGroups(instance)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumeratePhysicalDeviceGroups(instance, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDeviceGroupProperties [?]", count[0])
	local status = CLIB.vkEnumeratePhysicalDeviceGroups(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetDeviceExtensionProperties(physicalDevice, pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceGroups(instance)
	local count = ffi.new("uint32_t[1]")
	library.EnumeratePhysicalDeviceGroupsKHR(instance, count, nil)

	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDeviceGroupProperties [?]", count[0])
	local status = library.EnumeratePhysicalDeviceGroupsKHR(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceMultisampleProperties(physicalDevice, samples)
	if type(samples) == "table" then
		samples = library.e.sample_count.make_enums(samples)
	elseif type(samples) == "string" then
		samples = library.e.sample_count[samples]
	end

	local box = ffi.new("struct VkMultisamplePropertiesEXT [1]")
	library.GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, box)
	return box[0]
end

function library.GetPipelineCacheData(device, pipelineCache, pDataSize)
	local box = ffi.new("void [1]")
	local status = CLIB.vkGetPipelineCacheData(device, pipelineCache, pDataSize, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo)
	if type(pExternalSemaphoreInfo) == "table" then
		pExternalSemaphoreInfo = library.s.PhysicalDeviceExternalSemaphoreInfo(pExternalSemaphoreInfo, false)
	end

	local box = ffi.new("struct VkExternalSemaphoreProperties [1]")
	CLIB.vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceFormatProperties2(physicalDevice, format)
	if type(format) == "string" then format = library.e.format[format] end

	local box = ffi.new("struct VkFormatProperties2 [1]")
	library.GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, box)
	return box[0]
end

function library.GetRefreshCycleDurationGOO(device, swapchain)
	local box = ffi.new("struct VkRefreshCycleDurationGOOGLE [1]")
	local status = library.GetRefreshCycleDurationGOOGLE(device, swapchain, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetMemoryFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.MemoryGetFdInfoKHR(pGetFdInfo, false)
	end

	local box = ffi.new("int [1]")
	local status = library.GetMemoryFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties2 [1]")
	CLIB.vkGetPhysicalDeviceProperties2(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties [1]")
	CLIB.vkGetPhysicalDeviceProperties(physicalDevice, box)
	return box[0]
end

function library.GetDescriptorSetLayoutSupport(device, pCreateInfo)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorSetLayoutCreateInfo(pCreateInfo, false)
	end

	local box = ffi.new("struct VkDescriptorSetLayoutSupport [1]")
	library.GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, box)
	return box[0]
end

function library.GetDisplayPlaneSupportedDisplays(physicalDevice, planeIndex)
	local count = ffi.new("uint32_t[1]")
	library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, nil)
	local array = ffi.new("struct VkDisplayKHR_T * [?]", count[0])
	local status = library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetSwapchainStatus(device)
	local box = ffi.new("struct VkSwapchainKHR_T [1]")
	local status = library.GetSwapchainStatusKHR(device, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceMemoryProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties2 [1]")
	library.GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo)
	if type(pExternalSemaphoreInfo) == "table" then
		pExternalSemaphoreInfo = library.s.PhysicalDeviceExternalSemaphoreInfo(pExternalSemaphoreInfo, false)
	end

	local box = ffi.new("struct VkExternalSemaphoreProperties [1]")
	library.GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, box)
	return box[0]
end

function library.GetFenceStatus(device)
	local box = ffi.new("struct VkFence_T [1]")
	local status = CLIB.vkGetFenceStatus(device, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetImageSparseMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageSparseMemoryRequirementsInfo2(pInfo, false)
	end

	local count = ffi.new("uint32_t[1]")
	library.GetImageSparseMemoryRequirements2KHR(device, pInfo, count, nil)
	local array = ffi.new("struct VkSparseImageMemoryRequirements2 [?]", count[0])
	library.GetImageSparseMemoryRequirements2KHR(device, pInfo, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceFeatures2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures2 [1]")
	library.GetPhysicalDeviceFeatures2KHR(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo)
	if type(pExternalBufferInfo) == "table" then
		pExternalBufferInfo = library.s.PhysicalDeviceExternalBufferInfo(pExternalBufferInfo, false)
	end

	local box = ffi.new("struct VkExternalBufferProperties [1]")
	library.GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo)
	if type(pExternalFenceInfo) == "table" then
		pExternalFenceInfo = library.s.PhysicalDeviceExternalFenceInfo(pExternalFenceInfo, false)
	end

	local box = ffi.new("struct VkExternalFenceProperties [1]")
	library.GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, box)
	return box[0]
end

function library.GetPastPresentationTimingGOO(device, swapchain)
	local count = ffi.new("uint32_t[1]")
	library.GetPastPresentationTimingGOOGLE(device, swapchain, count, nil)
	local array = ffi.new("struct VkPastPresentationTimingGOOGLE [?]", count[0])
	local status = library.GetPastPresentationTimingGOOGLE(device, swapchain, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags)
	if type(format) == "string" then format = library.e.format[format] end

	if type(type) == "string" then type = library.e.image_type[type] end

	if type(tiling) == "string" then tiling = library.e.image_tiling[tiling] end

	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end

	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end

	local box = ffi.new("struct VkImageFormatProperties [1]")
	local status = CLIB.vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceFormatProperties2(physicalDevice, format)
	if type(format) == "string" then format = library.e.format[format] end

	local box = ffi.new("struct VkFormatProperties2 [1]")
	CLIB.vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, box)
	return box[0]
end

function library.GetDisplayPlaneCapabilities(physicalDevice, mode, planeIndex)
	local box = ffi.new("struct VkDisplayPlaneCapabilitiesKHR [1]")
	local status = library.GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetImageSparseMemoryRequirements(device, image)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, nil)
	local array = ffi.new("struct VkSparseImageMemoryRequirements [?]", count[0])
	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetEventStatus(device)
	local box = ffi.new("struct VkEvent_T [1]")
	local status = CLIB.vkGetEventStatus(device, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo)
	if type(pFormatInfo) == "table" then
		pFormatInfo = library.s.PhysicalDeviceSparseImageFormatInfo2(pFormatInfo, false)
	end

	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, count, nil)
	local array = ffi.new("struct VkSparseImageFormatProperties2 [?]", count[0])
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetDisplayModeProperties(physicalDevice, display)
	local count = ffi.new("uint32_t[1]")
	library.GetDisplayModePropertiesKHR(physicalDevice, display, count, nil)
	local array = ffi.new("struct VkDisplayModePropertiesKHR [?]", count[0])
	local status = library.GetDisplayModePropertiesKHR(physicalDevice, display, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetFenceFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.FenceGetFdInfoKHR(pGetFdInfo, false)
	end

	local box = ffi.new("int [1]")
	local status = library.GetFenceFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetBufferMemoryRequirements(device, buffer)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetBufferMemoryRequirements(device, buffer, box)
	return box[0]
end

function library.GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex)
	local box = ffi.new("unsigned int [1]")
	library.GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, box)
	return box[0]
end

function library.GetPhysicalDeviceGeneratedCommandsProperties(physicalDevice, pFeatures)
	if type(pFeatures) == "table" then
		pFeatures = library.s.DeviceGeneratedCommandsFeaturesNVX(pFeatures, false)
	end

	local box = ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX [1]")
	library.GetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, box)
	return box[0]
end

function library.GetRenderAreaGranularity(device, renderPass)
	local box = ffi.new("struct VkExtent2D [1]")
	CLIB.vkGetRenderAreaGranularity(device, renderPass, box)
	return box[0]
end

function library.GetDeviceQueue2(device, pQueueInfo)
	if type(pQueueInfo) == "table" then
		pQueueInfo = library.s.DeviceQueueInfo2(pQueueInfo, false)
	end

	local box = ffi.new("struct VkQueue_T * [1]")
	CLIB.vkGetDeviceQueue2(device, pQueueInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceQueueFamilyProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, nil)
	local array = ffi.new("struct VkQueueFamilyProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetBufferMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.BufferMemoryRequirementsInfo2(pInfo, false)
	end

	local box = ffi.new("struct VkMemoryRequirements2 [1]")
	CLIB.vkGetBufferMemoryRequirements2(device, pInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceSurfaceCapabilities2(physicalDevice, surface)
	local box = ffi.new("struct VkSurfaceCapabilities2EXT [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceMemoryProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties2 [1]")
	CLIB.vkGetPhysicalDeviceMemoryProperties2(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo)
	if type(pImageFormatInfo) == "table" then
		pImageFormatInfo = library.s.PhysicalDeviceImageFormatInfo2(pImageFormatInfo, false)
	end

	local box = ffi.new("struct VkImageFormatProperties2 [1]")
	local status = library.GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetSwapchainCounter(device, swapchain, counter)
	if type(counter) == "table" then
		counter = library.e.surface_counter.make_enums(counter)
	elseif type(counter) == "string" then
		counter = library.e.surface_counter[counter]
	end

	local box = ffi.new("unsigned long [1]")
	local status = library.GetSwapchainCounterEXT(device, swapchain, counter, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex)
	local box = ffi.new("unsigned int [1]")
	CLIB.vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, box)
	return box[0]
end

function library.GetPhysicalDeviceQueueFamilyProperties2(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, count, nil)
	local array = ffi.new("struct VkQueueFamilyProperties2 [?]", count[0])
	library.GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceExternalImageFormatPropertie(physicalDevice, format, type, tiling, usage, flags, externalHandleType)
	if type(format) == "string" then format = library.e.format[format] end

	if type(type) == "string" then type = library.e.image_type[type] end

	if type(tiling) == "string" then tiling = library.e.image_tiling[tiling] end

	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end

	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end

	if type(externalHandleType) == "table" then
		externalHandleType = library.e.external_memory_handle_type.make_enums(externalHandleType)
	elseif type(externalHandleType) == "string" then
		externalHandleType = library.e.external_memory_handle_type[externalHandleType]
	end

	local box = ffi.new("struct VkExternalImageFormatPropertiesNV [1]")
	local status = library.GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceProperties2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties2 [1]")
	library.GetPhysicalDeviceProperties2KHR(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling)
	if type(format) == "string" then format = library.e.format[format] end

	if type(type) == "string" then type = library.e.image_type[type] end

	if type(samples) == "table" then
		samples = library.e.sample_count.make_enums(samples)
	elseif type(samples) == "string" then
		samples = library.e.sample_count[samples]
	end

	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end

	if type(tiling) == "string" then tiling = library.e.image_tiling[tiling] end

	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, nil)
	local array = ffi.new("struct VkSparseImageFormatProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceSurfaceFormats2(physicalDevice, pSurfaceInfo)
	if type(pSurfaceInfo) == "table" then
		pSurfaceInfo = library.s.PhysicalDeviceSurfaceInfo2KHR(pSurfaceInfo, false)
	end

	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, count, nil)
	local array = ffi.new("struct VkSurfaceFormat2KHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceSurfaceFormats(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, nil)
	local array = ffi.new("struct VkSurfaceFormatKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetImageSubresourceLayout(device, image, pSubresource)
	if type(pSubresource) == "table" then
		pSubresource = library.s.ImageSubresource(pSubresource, false)
	end

	local box = ffi.new("struct VkSubresourceLayout [1]")
	CLIB.vkGetImageSubresourceLayout(device, image, pSubresource, box)
	return box[0]
end

function library.GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo)
	if type(pExternalFenceInfo) == "table" then
		pExternalFenceInfo = library.s.PhysicalDeviceExternalFenceInfo(pExternalFenceInfo, false)
	end

	local box = ffi.new("struct VkExternalFenceProperties [1]")
	CLIB.vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo)
	if type(pExternalBufferInfo) == "table" then
		pExternalBufferInfo = library.s.PhysicalDeviceExternalBufferInfo(pExternalBufferInfo, false)
	end

	local box = ffi.new("struct VkExternalBufferProperties [1]")
	CLIB.vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceSurfaceCapabilities(physicalDevice, surface)
	local box = ffi.new("struct VkSurfaceCapabilitiesKHR [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceSurfaceSupport(physicalDevice, queueFamilyIndex, surface)
	local box = ffi.new("unsigned int [1]")
	local status = library.GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo)
	if type(pFormatInfo) == "table" then
		pFormatInfo = library.s.PhysicalDeviceSparseImageFormatInfo2(pFormatInfo, false)
	end

	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, count, nil)
	local array = ffi.new("struct VkSparseImageFormatProperties2 [?]", count[0])
	library.GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceFeatures(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures [1]")
	CLIB.vkGetPhysicalDeviceFeatures(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDevicePresentRectangles(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, count, nil)
	local array = ffi.new("struct VkRect2D [?]", count[0])
	local status = library.GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetDeviceMemoryCommitment(device, memory)
	local box = ffi.new("unsigned long [1]")
	CLIB.vkGetDeviceMemoryCommitment(device, memory, box)
	return box[0]
end

function library.GetMemoryHostPointerProperties(device, handleType, pHostPointer)
	if type(handleType) == "table" then
		handleType = library.e.external_memory_handle_type.make_enums(handleType)
	elseif type(handleType) == "string" then
		handleType = library.e.external_memory_handle_type[handleType]
	end

	local box = ffi.new("struct VkMemoryHostPointerPropertiesEXT [1]")
	local status = library.GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetValidationCacheData(device, validationCache, pDataSize)
	local box = ffi.new("void [1]")
	local status = library.GetValidationCacheDataEXT(device, validationCache, pDataSize, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetSemaphoreFd(device, pGetFdInfo)
	if type(pGetFdInfo) == "table" then
		pGetFdInfo = library.s.SemaphoreGetFdInfoKHR(pGetFdInfo, false)
	end

	local box = ffi.new("int [1]")
	local status = library.GetSemaphoreFdKHR(device, pGetFdInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.AcquireNextImage(device, swapchain, timeout, semaphore, fence)
	local box = ffi.new("unsigned int [1]")
	local status = library.AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetImageMemoryRequirements(device, image)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetImageMemoryRequirements(device, image, box)
	return box[0]
end

function library.GetPhysicalDeviceMemoryProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties [1]")
	CLIB.vkGetPhysicalDeviceMemoryProperties(physicalDevice, box)
	return box[0]
end

function library.GetPhysicalDeviceSurfaceCapabilities2(physicalDevice, pSurfaceInfo)
	if type(pSurfaceInfo) == "table" then
		pSurfaceInfo = library.s.PhysicalDeviceSurfaceInfo2KHR(pSurfaceInfo, false)
	end

	local box = ffi.new("struct VkSurfaceCapabilities2KHR [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetBufferMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.BufferMemoryRequirementsInfo2(pInfo, false)
	end

	local box = ffi.new("struct VkMemoryRequirements2 [1]")
	library.GetBufferMemoryRequirements2KHR(device, pInfo, box)
	return box[0]
end

function library.GetDeviceQueue(device, queueFamilyIndex, queueIndex)
	local box = ffi.new("struct VkQueue_T * [1]")
	CLIB.vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, box)
	return box[0]
end

function library.GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo)
	if type(pImageFormatInfo) == "table" then
		pImageFormatInfo = library.s.PhysicalDeviceImageFormatInfo2(pImageFormatInfo, false)
	end

	local box = ffi.new("struct VkImageFormatProperties2 [1]")
	local status = CLIB.vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetMemoryFdProperties(device, handleType, fd)
	if type(handleType) == "table" then
		handleType = library.e.external_memory_handle_type.make_enums(handleType)
	elseif type(handleType) == "string" then
		handleType = library.e.external_memory_handle_type[handleType]
	end

	local box = ffi.new("struct VkMemoryFdPropertiesKHR [1]")
	local status = library.GetMemoryFdPropertiesKHR(device, handleType, fd, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetDeviceGroupPresentCapabilities(device)
	local box = ffi.new("struct VkDeviceGroupPresentCapabilitiesKHR [1]")
	local status = library.GetDeviceGroupPresentCapabilitiesKHR(device, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetPhysicalDeviceFormatProperties(physicalDevice, format)
	if type(format) == "string" then format = library.e.format[format] end

	local box = ffi.new("struct VkFormatProperties [1]")
	CLIB.vkGetPhysicalDeviceFormatProperties(physicalDevice, format, box)
	return box[0]
end

function library.GetSwapchainImages(device, swapchain)
	local count = ffi.new("uint32_t[1]")
	library.GetSwapchainImagesKHR(device, swapchain, count, nil)
	local array = ffi.new("struct VkImage_T * [?]", count[0])
	local status = library.GetSwapchainImagesKHR(device, swapchain, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetDescriptorSetLayoutSupport(device, pCreateInfo)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorSetLayoutCreateInfo(pCreateInfo, false)
	end

	local box = ffi.new("struct VkDescriptorSetLayoutSupport [1]")
	CLIB.vkGetDescriptorSetLayoutSupport(device, pCreateInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceFeatures2(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures2 [1]")
	CLIB.vkGetPhysicalDeviceFeatures2(physicalDevice, box)
	return box[0]
end

function library.GetImageMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageMemoryRequirementsInfo2(pInfo, false)
	end

	local box = ffi.new("struct VkMemoryRequirements2 [1]")
	CLIB.vkGetImageMemoryRequirements2(device, pInfo, box)
	return box[0]
end

function library.GetPhysicalDeviceQueueFamilyProperties2(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, count, nil)
	local array = ffi.new("struct VkQueueFamilyProperties2 [?]", count[0])
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceDisplayPlaneProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, nil)
	local array = ffi.new("struct VkDisplayPlanePropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetPhysicalDeviceSurfacePresentModes(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, nil)
	local array = ffi.new("enum VkPresentModeKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetImageMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageMemoryRequirementsInfo2(pInfo, false)
	end

	local box = ffi.new("struct VkMemoryRequirements2 [1]")
	library.GetImageMemoryRequirements2KHR(device, pInfo, box)
	return box[0]
end

function library.GetDeviceGroupSurfacePresentModes(device, surface)
	local box = ffi.new("unsigned int [1]")
	local status = library.GetDeviceGroupSurfacePresentModesKHR(device, surface, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.AcquireNextImage2(device, pAcquireInfo)
	if type(pAcquireInfo) == "table" then
		pAcquireInfo = library.s.AcquireNextImageInfoKHR(pAcquireInfo, false)
	end

	local box = ffi.new("unsigned int [1]")
	local status = library.AcquireNextImage2KHR(device, pAcquireInfo, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.GetImageSparseMemoryRequirements2(device, pInfo)
	if type(pInfo) == "table" then
		pInfo = library.s.ImageSparseMemoryRequirementsInfo2(pInfo, false)
	end

	local count = ffi.new("uint32_t[1]")
	CLIB.vkGetImageSparseMemoryRequirements2(device, pInfo, count, nil)
	local array = ffi.new("struct VkSparseImageMemoryRequirements2 [?]", count[0])
	CLIB.vkGetImageSparseMemoryRequirements2(device, pInfo, count, array)
	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end

function library.GetPhysicalDeviceDisplayProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, nil)
	local array = ffi.new("struct VkDisplayPropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end

function library.GetShaderInfo(device, pipeline, shaderStage, infoType, pInfoSize)
	if type(shaderStage) == "table" then
		shaderStage = library.e.shader_stage.make_enums(shaderStage)
	elseif type(shaderStage) == "string" then
		shaderStage = library.e.shader_stage[shaderStage]
	end

	if type(infoType) == "string" then
		infoType = library.e.shader_info_type[infoType]
	end

	local box = ffi.new("void [1]")
	local status = library.GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, box)

	if status == "VK_SUCCESS" then return box[0], status end

	return nil, status
end

function library.MapMemory(device, memory, a, b, c, type, func)
	local data = ffi.new("void *[1]")
	local status = CLIB.vkMapMemory(device, memory, a, b, c, data)

	if status == "VK_SUCCESS" then
		if func then
			local ptr = func(ffi.cast(type .. " *", data[0]))

			if ptr then data[0] = ptr end

			library.UnmapMemory(device, memory)
		end

		return data[0]
	end

	return nil, status
end

library.s = {}

function library.s.ApplicationInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_APPLICATION_INFO"
	return table_only and tbl or ffi.new("struct VkApplicationInfo", tbl)
end

function library.s.InstanceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"

	if type(tbl.pApplicationInfo) == "table" then
		tbl.pApplicationInfo = library.s.ApplicationInfo(tbl.pApplicationInfo, false)
	end

	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end

	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end

	return table_only and tbl or ffi.new("struct VkInstanceCreateInfo", tbl)
end

function library.s.DeviceQueueCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.device_queue_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.device_queue_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkDeviceQueueCreateInfo", tbl)
end

function library.s.DeviceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"

	if type(tbl.pQueueCreateInfos) == "table" then
		if not tbl.queueCreateInfoCount then
			tbl.queueCreateInfoCount = #tbl.pQueueCreateInfos
		end

		tbl.pQueueCreateInfos = library.s.DeviceQueueCreateInfoArray(tbl.pQueueCreateInfos, false)
	end

	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end

	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end

	if type(tbl.pEnabledFeatures) == "table" then
		tbl.pEnabledFeatures = library.s.PhysicalDeviceFeatures(tbl.pEnabledFeatures, false)
	end

	return table_only and tbl or ffi.new("struct VkDeviceCreateInfo", tbl)
end

function library.s.SubmitInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SUBMIT_INFO"

	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end

		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end

	if type(tbl.pCommandBuffers) == "table" then
		if not tbl.commandBufferCount then
			tbl.commandBufferCount = #tbl.pCommandBuffers
		end

		tbl.pCommandBuffers = library.s.CommandBufferArray(tbl.pCommandBuffers, false)
	end

	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end

		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end

	return table_only and tbl or ffi.new("struct VkSubmitInfo", tbl)
end

function library.s.MemoryAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"
	return table_only and tbl or ffi.new("struct VkMemoryAllocateInfo", tbl)
end

function library.s.MappedMemoryRange(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"
	return table_only and tbl or ffi.new("struct VkMappedMemoryRange", tbl)
end

function library.s.BindSparseInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"

	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end

		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end

	if type(tbl.pBufferBinds) == "table" then
		if not tbl.bufferBindCount then tbl.bufferBindCount = #tbl.pBufferBinds end

		tbl.pBufferBinds = library.s.SparseBufferMemoryBindInfoArray(tbl.pBufferBinds, false)
	end

	if type(tbl.pImageOpaqueBinds) == "table" then
		if not tbl.imageOpaqueBindCount then
			tbl.imageOpaqueBindCount = #tbl.pImageOpaqueBinds
		end

		tbl.pImageOpaqueBinds = library.s.SparseImageOpaqueMemoryBindInfoArray(tbl.pImageOpaqueBinds, false)
	end

	if type(tbl.pImageBinds) == "table" then
		if not tbl.imageBindCount then tbl.imageBindCount = #tbl.pImageBinds end

		tbl.pImageBinds = library.s.SparseImageMemoryBindInfoArray(tbl.pImageBinds, false)
	end

	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end

		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end

	return table_only and tbl or ffi.new("struct VkBindSparseInfo", tbl)
end

function library.s.FenceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.fence_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.fence_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkFenceCreateInfo", tbl)
end

function library.s.SemaphoreCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkSemaphoreCreateInfo", tbl)
end

function library.s.EventCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkEventCreateInfo", tbl)
end

function library.s.QueryPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"

	if type(tbl.queryType) == "string" then
		tbl.queryType = library.e.query_type[tbl.queryType]
	end

	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end

	return table_only and tbl or ffi.new("struct VkQueryPoolCreateInfo", tbl)
end

function library.s.BufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.buffer_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.buffer_create[tbl.flags]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.buffer_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.buffer_usage[tbl.usage]
	end

	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end

	return table_only and tbl or ffi.new("struct VkBufferCreateInfo", tbl)
end

function library.s.BufferViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"

	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	return table_only and tbl or ffi.new("struct VkBufferViewCreateInfo", tbl)
end

function library.s.ImageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end

	if type(tbl.imageType) == "string" then
		tbl.imageType = library.e.image_type[tbl.imageType]
	end

	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end

	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end

	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end

	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end

	return table_only and tbl or ffi.new("struct VkImageCreateInfo", tbl)
end

function library.s.ImageViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"

	if type(tbl.viewType) == "string" then
		tbl.viewType = library.e.image_view_type[tbl.viewType]
	end

	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.components) == "table" then
		tbl.components = library.s.ComponentMapping(tbl.components, true)
	end

	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end

	return table_only and tbl or ffi.new("struct VkImageViewCreateInfo", tbl)
end

function library.s.ShaderModuleCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkShaderModuleCreateInfo", tbl)
end

function library.s.PipelineCacheCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkPipelineCacheCreateInfo", tbl)
end

function library.s.PipelineShaderStageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"

	if type(tbl.stage) == "table" then
		tbl.stage = library.e.shader_stage.make_enums(tbl.stage)
	elseif type(tbl.stage) == "string" then
		tbl.stage = library.e.shader_stage[tbl.stage]
	end

	if type(tbl.pSpecializationInfo) == "table" then
		tbl.pSpecializationInfo = library.s.SpecializationInfo(tbl.pSpecializationInfo, false)
	end

	return table_only and tbl or ffi.new("struct VkPipelineShaderStageCreateInfo", tbl)
end

function library.s.PipelineVertexInputStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"

	if type(tbl.pVertexBindingDescriptions) == "table" then
		if not tbl.vertexBindingDescriptionCount then
			tbl.vertexBindingDescriptionCount = #tbl.pVertexBindingDescriptions
		end

		tbl.pVertexBindingDescriptions = library.s.VertexInputBindingDescriptionArray(tbl.pVertexBindingDescriptions, false)
	end

	if type(tbl.pVertexAttributeDescriptions) == "table" then
		if not tbl.vertexAttributeDescriptionCount then
			tbl.vertexAttributeDescriptionCount = #tbl.pVertexAttributeDescriptions
		end

		tbl.pVertexAttributeDescriptions = library.s.VertexInputAttributeDescriptionArray(tbl.pVertexAttributeDescriptions, false)
	end

	return table_only and tbl or ffi.new("struct VkPipelineVertexInputStateCreateInfo", tbl)
end

function library.s.PipelineInputAssemblyStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"

	if type(tbl.topology) == "string" then
		tbl.topology = library.e.primitive_topology[tbl.topology]
	end

	tbl.primitiveRestartEnable = tbl.primitiveRestartEnable and 1 or 0
	return table_only and
		tbl or
		ffi.new("struct VkPipelineInputAssemblyStateCreateInfo", tbl)
end

function library.s.PipelineTessellationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"
	return table_only and
		tbl or
		ffi.new("struct VkPipelineTessellationStateCreateInfo", tbl)
end

function library.s.PipelineViewportStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"

	if type(tbl.pViewports) == "table" then
		if not tbl.viewportCount then tbl.viewportCount = #tbl.pViewports end

		tbl.pViewports = library.s.ViewportArray(tbl.pViewports, false)
	end

	if type(tbl.pScissors) == "table" then
		if not tbl.scissorCount then tbl.scissorCount = #tbl.pScissors end

		tbl.pScissors = library.s.Rect2DArray(tbl.pScissors, false)
	end

	return table_only and tbl or ffi.new("struct VkPipelineViewportStateCreateInfo", tbl)
end

function library.s.PipelineRasterizationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"
	tbl.depthClampEnable = tbl.depthClampEnable and 1 or 0
	tbl.rasterizerDiscardEnable = tbl.rasterizerDiscardEnable and 1 or 0

	if type(tbl.polygonMode) == "string" then
		tbl.polygonMode = library.e.polygon_mode[tbl.polygonMode]
	end

	if type(tbl.cullMode) == "table" then
		tbl.cullMode = library.e.cull_mode.make_enums(tbl.cullMode)
	elseif type(tbl.cullMode) == "string" then
		tbl.cullMode = library.e.cull_mode[tbl.cullMode]
	end

	if type(tbl.frontFace) == "string" then
		tbl.frontFace = library.e.front_face[tbl.frontFace]
	end

	tbl.depthBiasEnable = tbl.depthBiasEnable and 1 or 0
	return table_only and
		tbl or
		ffi.new("struct VkPipelineRasterizationStateCreateInfo", tbl)
end

function library.s.PipelineMultisampleStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"

	if type(tbl.rasterizationSamples) == "table" then
		tbl.rasterizationSamples = library.e.sample_count.make_enums(tbl.rasterizationSamples)
	elseif type(tbl.rasterizationSamples) == "string" then
		tbl.rasterizationSamples = library.e.sample_count[tbl.rasterizationSamples]
	end

	tbl.sampleShadingEnable = tbl.sampleShadingEnable and 1 or 0
	tbl.alphaToCoverageEnable = tbl.alphaToCoverageEnable and 1 or 0
	tbl.alphaToOneEnable = tbl.alphaToOneEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineMultisampleStateCreateInfo", tbl)
end

function library.s.PipelineDepthStencilStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"
	tbl.depthTestEnable = tbl.depthTestEnable and 1 or 0
	tbl.depthWriteEnable = tbl.depthWriteEnable and 1 or 0

	if type(tbl.depthCompareOp) == "string" then
		tbl.depthCompareOp = library.e.compare_op[tbl.depthCompareOp]
	end

	tbl.depthBoundsTestEnable = tbl.depthBoundsTestEnable and 1 or 0
	tbl.stencilTestEnable = tbl.stencilTestEnable and 1 or 0

	if type(tbl.front) == "table" then
		tbl.front = library.s.StencilOpState(tbl.front, true)
	end

	if type(tbl.back) == "table" then
		tbl.back = library.s.StencilOpState(tbl.back, true)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineDepthStencilStateCreateInfo", tbl)
end

function library.s.PipelineColorBlendStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"
	tbl.logicOpEnable = tbl.logicOpEnable and 1 or 0

	if type(tbl.logicOp) == "string" then
		tbl.logicOp = library.e.logic_op[tbl.logicOp]
	end

	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then tbl.attachmentCount = #tbl.pAttachments end

		tbl.pAttachments = library.s.PipelineColorBlendAttachmentStateArray(tbl.pAttachments, false)
	end

	return table_only and tbl or ffi.new("struct VkPipelineColorBlendStateCreateInfo", tbl)
end

function library.s.PipelineDynamicStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"

	if type(tbl.pDynamicStates) == "string" then
		tbl.pDynamicStates = library.e.dynamic_state[tbl.pDynamicStates]
	end

	return table_only and tbl or ffi.new("struct VkPipelineDynamicStateCreateInfo", tbl)
end

function library.s.GraphicsPipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end

	if type(tbl.pStages) == "table" then
		if not tbl.stageCount then tbl.stageCount = #tbl.pStages end

		tbl.pStages = library.s.PipelineShaderStageCreateInfoArray(tbl.pStages, false)
	end

	if type(tbl.pVertexInputState) == "table" then
		tbl.pVertexInputState = library.s.PipelineVertexInputStateCreateInfo(tbl.pVertexInputState, false)
	end

	if type(tbl.pInputAssemblyState) == "table" then
		tbl.pInputAssemblyState = library.s.PipelineInputAssemblyStateCreateInfo(tbl.pInputAssemblyState, false)
	end

	if type(tbl.pTessellationState) == "table" then
		tbl.pTessellationState = library.s.PipelineTessellationStateCreateInfo(tbl.pTessellationState, false)
	end

	if type(tbl.pViewportState) == "table" then
		tbl.pViewportState = library.s.PipelineViewportStateCreateInfo(tbl.pViewportState, false)
	end

	if type(tbl.pRasterizationState) == "table" then
		tbl.pRasterizationState = library.s.PipelineRasterizationStateCreateInfo(tbl.pRasterizationState, false)
	end

	if type(tbl.pMultisampleState) == "table" then
		tbl.pMultisampleState = library.s.PipelineMultisampleStateCreateInfo(tbl.pMultisampleState, false)
	end

	if type(tbl.pDepthStencilState) == "table" then
		tbl.pDepthStencilState = library.s.PipelineDepthStencilStateCreateInfo(tbl.pDepthStencilState, false)
	end

	if type(tbl.pColorBlendState) == "table" then
		tbl.pColorBlendState = library.s.PipelineColorBlendStateCreateInfo(tbl.pColorBlendState, false)
	end

	if type(tbl.pDynamicState) == "table" then
		tbl.pDynamicState = library.s.PipelineDynamicStateCreateInfo(tbl.pDynamicState, false)
	end

	return table_only and tbl or ffi.new("struct VkGraphicsPipelineCreateInfo", tbl)
end

function library.s.ComputePipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end

	if type(tbl.stage) == "table" then
		tbl.stage = library.s.PipelineShaderStageCreateInfo(tbl.stage, true)
	end

	return table_only and tbl or ffi.new("struct VkComputePipelineCreateInfo", tbl)
end

function library.s.PipelineLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"

	if type(tbl.pSetLayouts) == "table" then
		if not tbl.setLayoutCount then tbl.setLayoutCount = #tbl.pSetLayouts end

		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end

	if type(tbl.pPushConstantRanges) == "table" then
		if not tbl.pushConstantRangeCount then
			tbl.pushConstantRangeCount = #tbl.pPushConstantRanges
		end

		tbl.pPushConstantRanges = library.s.PushConstantRangeArray(tbl.pPushConstantRanges, false)
	end

	return table_only and tbl or ffi.new("struct VkPipelineLayoutCreateInfo", tbl)
end

function library.s.SamplerCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"

	if type(tbl.magFilter) == "string" then
		tbl.magFilter = library.e.filter[tbl.magFilter]
	end

	if type(tbl.minFilter) == "string" then
		tbl.minFilter = library.e.filter[tbl.minFilter]
	end

	if type(tbl.mipmapMode) == "string" then
		tbl.mipmapMode = library.e.sampler_mipmap_mode[tbl.mipmapMode]
	end

	if type(tbl.addressModeU) == "string" then
		tbl.addressModeU = library.e.sampler_address_mode[tbl.addressModeU]
	end

	if type(tbl.addressModeV) == "string" then
		tbl.addressModeV = library.e.sampler_address_mode[tbl.addressModeV]
	end

	if type(tbl.addressModeW) == "string" then
		tbl.addressModeW = library.e.sampler_address_mode[tbl.addressModeW]
	end

	tbl.anisotropyEnable = tbl.anisotropyEnable and 1 or 0
	tbl.compareEnable = tbl.compareEnable and 1 or 0

	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end

	if type(tbl.borderColor) == "string" then
		tbl.borderColor = library.e.border_color[tbl.borderColor]
	end

	return table_only and tbl or ffi.new("struct VkSamplerCreateInfo", tbl)
end

function library.s.DescriptorSetLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.descriptor_set_layout_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.descriptor_set_layout_create[tbl.flags]
	end

	if type(tbl.pBindings) == "table" then
		if not tbl.bindingCount then tbl.bindingCount = #tbl.pBindings end

		tbl.pBindings = library.s.DescriptorSetLayoutBindingArray(tbl.pBindings, false)
	end

	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutCreateInfo", tbl)
end

function library.s.DescriptorPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.descriptor_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.descriptor_pool_create[tbl.flags]
	end

	if type(tbl.pPoolSizes) == "table" then
		if not tbl.poolSizeCount then tbl.poolSizeCount = #tbl.pPoolSizes end

		tbl.pPoolSizes = library.s.DescriptorPoolSizeArray(tbl.pPoolSizes, false)
	end

	return table_only and tbl or ffi.new("struct VkDescriptorPoolCreateInfo", tbl)
end

function library.s.DescriptorSetAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"

	if type(tbl.pSetLayouts) == "table" then
		if not tbl.descriptorSetCount then
			tbl.descriptorSetCount = #tbl.pSetLayouts
		end

		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end

	return table_only and tbl or ffi.new("struct VkDescriptorSetAllocateInfo", tbl)
end

function library.s.WriteDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"

	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end

	if type(tbl.pImageInfo) == "table" then
		if not tbl.descriptorCount then tbl.descriptorCount = #tbl.pImageInfo end

		tbl.pImageInfo = library.s.DescriptorImageInfoArray(tbl.pImageInfo)
	end

	if type(tbl.pBufferInfo) == "table" then
		if not tbl.descriptorCount then tbl.descriptorCount = #tbl.pBufferInfo end

		tbl.pBufferInfo = library.s.DescriptorBufferInfoArray(tbl.pBufferInfo)
	end

	if type(tbl.pTexelBufferView) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pTexelBufferView
		end

		tbl.pTexelBufferView = library.s.BufferViewArray(tbl.pTexelBufferView)
	end

	return table_only and tbl or ffi.new("struct VkWriteDescriptorSet", tbl)
end

function library.s.CopyDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"
	return table_only and tbl or ffi.new("struct VkCopyDescriptorSet", tbl)
end

function library.s.FramebufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"

	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then tbl.attachmentCount = #tbl.pAttachments end

		tbl.pAttachments = library.s.ImageViewArray(tbl.pAttachments, false)
	end

	return table_only and tbl or ffi.new("struct VkFramebufferCreateInfo", tbl)
end

function library.s.RenderPassCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"

	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then tbl.attachmentCount = #tbl.pAttachments end

		tbl.pAttachments = library.s.AttachmentDescriptionArray(tbl.pAttachments, false)
	end

	if type(tbl.pSubpasses) == "table" then
		if not tbl.subpassCount then tbl.subpassCount = #tbl.pSubpasses end

		tbl.pSubpasses = library.s.SubpassDescriptionArray(tbl.pSubpasses, false)
	end

	if type(tbl.pDependencies) == "table" then
		if not tbl.dependencyCount then tbl.dependencyCount = #tbl.pDependencies end

		tbl.pDependencies = library.s.SubpassDependencyArray(tbl.pDependencies, false)
	end

	return table_only and tbl or ffi.new("struct VkRenderPassCreateInfo", tbl)
end

function library.s.CommandPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_pool_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkCommandPoolCreateInfo", tbl)
end

function library.s.CommandBufferAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"

	if type(tbl.level) == "string" then
		tbl.level = library.e.command_buffer_level[tbl.level]
	end

	return table_only and tbl or ffi.new("struct VkCommandBufferAllocateInfo", tbl)
end

function library.s.CommandBufferInheritanceInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"
	tbl.occlusionQueryEnable = tbl.occlusionQueryEnable and 1 or 0

	if type(tbl.queryFlags) == "table" then
		tbl.queryFlags = library.e.query_control.make_enums(tbl.queryFlags)
	elseif type(tbl.queryFlags) == "string" then
		tbl.queryFlags = library.e.query_control[tbl.queryFlags]
	end

	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end

	return table_only and tbl or ffi.new("struct VkCommandBufferInheritanceInfo", tbl)
end

function library.s.CommandBufferBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_buffer_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_buffer_usage[tbl.flags]
	end

	if type(tbl.pInheritanceInfo) == "table" then
		tbl.pInheritanceInfo = library.s.CommandBufferInheritanceInfo(tbl.pInheritanceInfo, false)
	end

	return table_only and tbl or ffi.new("struct VkCommandBufferBeginInfo", tbl)
end

function library.s.RenderPassBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"

	if type(tbl.renderArea) == "table" then
		tbl.renderArea = library.s.Rect2D(tbl.renderArea, true)
	end

	if type(tbl.pClearValues) == "table" then
		if not tbl.clearValueCount then tbl.clearValueCount = #tbl.pClearValues end

		tbl.pClearValues = library.s.ClearValueArray(tbl.pClearValues, false)
	end

	return table_only and tbl or ffi.new("struct VkRenderPassBeginInfo", tbl)
end

function library.s.BufferMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"

	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end

	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end

	return table_only and tbl or ffi.new("struct VkBufferMemoryBarrier", tbl)
end

function library.s.ImageMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"

	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end

	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end

	if type(tbl.oldLayout) == "string" then
		tbl.oldLayout = library.e.image_layout[tbl.oldLayout]
	end

	if type(tbl.newLayout) == "string" then
		tbl.newLayout = library.e.image_layout[tbl.newLayout]
	end

	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end

	return table_only and tbl or ffi.new("struct VkImageMemoryBarrier", tbl)
end

function library.s.MemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_BARRIER"

	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end

	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end

	return table_only and tbl or ffi.new("struct VkMemoryBarrier", tbl)
end

function library.s.PhysicalDeviceSubgroupProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"

	if type(tbl.supportedStages) == "table" then
		tbl.supportedStages = library.e.shader_stage.make_enums(tbl.supportedStages)
	elseif type(tbl.supportedStages) == "string" then
		tbl.supportedStages = library.e.shader_stage[tbl.supportedStages]
	end

	if type(tbl.supportedOperations) == "table" then
		tbl.supportedOperations = library.e.subgroup_feature.make_enums(tbl.supportedOperations)
	elseif type(tbl.supportedOperations) == "string" then
		tbl.supportedOperations = library.e.subgroup_feature[tbl.supportedOperations]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSubgroupProperties", tbl)
end

function library.s.BindBufferMemoryInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"
	return table_only and tbl or ffi.new("struct VkBindBufferMemoryInfo", tbl)
end

function library.s.BindImageMemoryInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"
	return table_only and tbl or ffi.new("struct VkBindImageMemoryInfo", tbl)
end

function library.s.MemoryDedicatedRequirements(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"
	return table_only and tbl or ffi.new("struct VkMemoryDedicatedRequirements", tbl)
end

function library.s.MemoryDedicatedAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"
	return table_only and tbl or ffi.new("struct VkMemoryDedicatedAllocateInfo", tbl)
end

function library.s.MemoryAllocateFlagsInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.memory_allocate.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.memory_allocate[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkMemoryAllocateFlagsInfo", tbl)
end

function library.s.DeviceGroupRenderPassBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"

	if type(tbl.pDeviceRenderAreas) == "table" then
		if not tbl.deviceRenderAreaCount then
			tbl.deviceRenderAreaCount = #tbl.pDeviceRenderAreas
		end

		tbl.pDeviceRenderAreas = library.s.Rect2DArray(tbl.pDeviceRenderAreas, false)
	end

	return table_only and tbl or ffi.new("struct VkDeviceGroupRenderPassBeginInfo", tbl)
end

function library.s.DeviceGroupCommandBufferBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"
	return table_only and tbl or ffi.new("struct VkDeviceGroupCommandBufferBeginInfo", tbl)
end

function library.s.DeviceGroupSubmitInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"
	return table_only and tbl or ffi.new("struct VkDeviceGroupSubmitInfo", tbl)
end

function library.s.DeviceGroupBindSparseInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"
	return table_only and tbl or ffi.new("struct VkDeviceGroupBindSparseInfo", tbl)
end

function library.s.BindBufferMemoryDeviceGroupInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"
	return table_only and tbl or ffi.new("struct VkBindBufferMemoryDeviceGroupInfo", tbl)
end

function library.s.BindImageMemoryDeviceGroupInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"

	if type(tbl.pSplitInstanceBindRegions) == "table" then
		if not tbl.splitInstanceBindRegionCount then
			tbl.splitInstanceBindRegionCount = #tbl.pSplitInstanceBindRegions
		end

		tbl.pSplitInstanceBindRegions = library.s.Rect2DArray(tbl.pSplitInstanceBindRegions, false)
	end

	return table_only and tbl or ffi.new("struct VkBindImageMemoryDeviceGroupInfo", tbl)
end

function library.s.PhysicalDeviceGroupProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"

	if type(tbl.physicalDevices) == "table" then
		if not tbl.physicalDeviceCount then
			tbl.physicalDeviceCount = #tbl.physicalDevices
		end

		tbl.physicalDevices = library.s.PhysicalDeviceArray(tbl.physicalDevices, false)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceGroupProperties", tbl)
end

function library.s.DeviceGroupDeviceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"

	if type(tbl.pPhysicalDevices) == "table" then
		if not tbl.physicalDeviceCount then
			tbl.physicalDeviceCount = #tbl.pPhysicalDevices
		end

		tbl.pPhysicalDevices = library.s.PhysicalDeviceArray(tbl.pPhysicalDevices, false)
	end

	return table_only and tbl or ffi.new("struct VkDeviceGroupDeviceCreateInfo", tbl)
end

function library.s.PhysicalDevicePointClippingProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"

	if type(tbl.pointClippingBehavior) == "string" then
		tbl.pointClippingBehavior = library.e.point_clipping_behavior[tbl.pointClippingBehavior]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDevicePointClippingProperties", tbl)
end

function library.s.RenderPassInputAttachmentAspectCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"

	if type(tbl.pAspectReferences) == "table" then
		if not tbl.aspectReferenceCount then
			tbl.aspectReferenceCount = #tbl.pAspectReferences
		end

		tbl.pAspectReferences = library.s.InputAttachmentAspectReferenceArray(tbl.pAspectReferences, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkRenderPassInputAttachmentAspectCreateInfo", tbl)
end

function library.s.ImageViewUsageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	return table_only and tbl or ffi.new("struct VkImageViewUsageCreateInfo", tbl)
end

function library.s.PipelineTessellationDomainOriginStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"

	if type(tbl.domainOrigin) == "string" then
		tbl.domainOrigin = library.e.tessellation_domain_origin[tbl.domainOrigin]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineTessellationDomainOriginStateCreateInfo", tbl)
end

function library.s.RenderPassMultiviewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkRenderPassMultiviewCreateInfo", tbl)
end

function library.s.PhysicalDeviceMultiviewFeatures(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMultiviewFeatures", tbl)
end

function library.s.PhysicalDeviceMultiviewProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMultiviewProperties", tbl)
end

function library.s.PhysicalDeviceVariablePointerFeatures(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceVariablePointerFeatures", tbl)
end

function library.s.ProtectedSubmitInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"
	return table_only and tbl or ffi.new("struct VkProtectedSubmitInfo", tbl)
end

function library.s.PhysicalDeviceProtectedMemoryFeatures(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceProtectedMemoryFeatures", tbl)
end

function library.s.PhysicalDeviceProtectedMemoryProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceProtectedMemoryProperties", tbl)
end

function library.s.SamplerYcbcrConversionCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"

	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.ycbcrModel) == "string" then
		tbl.ycbcrModel = library.e.sampler_ycbcr_model_conversion[tbl.ycbcrModel]
	end

	if type(tbl.ycbcrRange) == "string" then
		tbl.ycbcrRange = library.e.sampler_ycbcr_range[tbl.ycbcrRange]
	end

	if type(tbl.components) == "table" then
		tbl.components = library.s.ComponentMapping(tbl.components, true)
	end

	if type(tbl.xChromaOffset) == "string" then
		tbl.xChromaOffset = library.e.chroma_location[tbl.xChromaOffset]
	end

	if type(tbl.yChromaOffset) == "string" then
		tbl.yChromaOffset = library.e.chroma_location[tbl.yChromaOffset]
	end

	if type(tbl.chromaFilter) == "string" then
		tbl.chromaFilter = library.e.filter[tbl.chromaFilter]
	end

	return table_only and tbl or ffi.new("struct VkSamplerYcbcrConversionCreateInfo", tbl)
end

function library.s.SamplerYcbcrConversionInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"
	return table_only and tbl or ffi.new("struct VkSamplerYcbcrConversionInfo", tbl)
end

function library.s.BindImagePlaneMemoryInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"

	if type(tbl.planeAspect) == "table" then
		tbl.planeAspect = library.e.image_aspect.make_enums(tbl.planeAspect)
	elseif type(tbl.planeAspect) == "string" then
		tbl.planeAspect = library.e.image_aspect[tbl.planeAspect]
	end

	return table_only and tbl or ffi.new("struct VkBindImagePlaneMemoryInfo", tbl)
end

function library.s.ImagePlaneMemoryRequirementsInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"

	if type(tbl.planeAspect) == "table" then
		tbl.planeAspect = library.e.image_aspect.make_enums(tbl.planeAspect)
	elseif type(tbl.planeAspect) == "string" then
		tbl.planeAspect = library.e.image_aspect[tbl.planeAspect]
	end

	return table_only and tbl or ffi.new("struct VkImagePlaneMemoryRequirementsInfo", tbl)
end

function library.s.PhysicalDeviceSamplerYcbcrConversionFeatures(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceSamplerYcbcrConversionFeatures", tbl)
end

function library.s.SamplerYcbcrConversionImageFormatProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"
	return table_only and
		tbl or
		ffi.new("struct VkSamplerYcbcrConversionImageFormatProperties", tbl)
end

function library.s.DescriptorUpdateTemplateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"

	if type(tbl.pDescriptorUpdateEntries) == "table" then
		if not tbl.descriptorUpdateEntryCount then
			tbl.descriptorUpdateEntryCount = #tbl.pDescriptorUpdateEntries
		end

		tbl.pDescriptorUpdateEntries = library.s.DescriptorUpdateTemplateEntryArray(tbl.pDescriptorUpdateEntries, false)
	end

	if type(tbl.templateType) == "string" then
		tbl.templateType = library.e.descriptor_update_template_type[tbl.templateType]
	end

	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorUpdateTemplateCreateInfo", tbl)
end

function library.s.PhysicalDeviceExternalImageFormatInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceExternalImageFormatInfo", tbl)
end

function library.s.ExternalImageFormatProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"

	if type(tbl.externalMemoryProperties) == "table" then
		tbl.externalMemoryProperties = library.s.ExternalMemoryProperties(tbl.externalMemoryProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkExternalImageFormatProperties", tbl)
end

function library.s.PhysicalDeviceExternalBufferInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.buffer_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.buffer_create[tbl.flags]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.buffer_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.buffer_usage[tbl.usage]
	end

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalBufferInfo", tbl)
end

function library.s.ExternalBufferProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"

	if type(tbl.externalMemoryProperties) == "table" then
		tbl.externalMemoryProperties = library.s.ExternalMemoryProperties(tbl.externalMemoryProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkExternalBufferProperties", tbl)
end

function library.s.ExternalMemoryBufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalMemoryBufferCreateInfo", tbl)
end

function library.s.ExternalMemoryImageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalMemoryImageCreateInfo", tbl)
end

function library.s.ExportMemoryAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExportMemoryAllocateInfo", tbl)
end

function library.s.PhysicalDeviceExternalFenceInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceExternalFenceInfo", tbl)
end

function library.s.ExternalFenceProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"

	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_fence_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_fence_handle_type[tbl.exportFromImportedHandleTypes]
	end

	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_fence_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_fence_handle_type[tbl.compatibleHandleTypes]
	end

	if type(tbl.externalFenceFeatures) == "table" then
		tbl.externalFenceFeatures = library.e.external_fence_feature.make_enums(tbl.externalFenceFeatures)
	elseif type(tbl.externalFenceFeatures) == "string" then
		tbl.externalFenceFeatures = library.e.external_fence_feature[tbl.externalFenceFeatures]
	end

	return table_only and tbl or ffi.new("struct VkExternalFenceProperties", tbl)
end

function library.s.ExportFenceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_fence_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_fence_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExportFenceCreateInfo", tbl)
end

function library.s.ExportSemaphoreCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_semaphore_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExportSemaphoreCreateInfo", tbl)
end

function library.s.PhysicalDeviceExternalSemaphoreInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceExternalSemaphoreInfo", tbl)
end

function library.s.ExternalSemaphoreProperties(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"

	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_semaphore_handle_type[tbl.exportFromImportedHandleTypes]
	end

	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_semaphore_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_semaphore_handle_type[tbl.compatibleHandleTypes]
	end

	if type(tbl.externalSemaphoreFeatures) == "table" then
		tbl.externalSemaphoreFeatures = library.e.external_semaphore_feature.make_enums(tbl.externalSemaphoreFeatures)
	elseif type(tbl.externalSemaphoreFeatures) == "string" then
		tbl.externalSemaphoreFeatures = library.e.external_semaphore_feature[tbl.externalSemaphoreFeatures]
	end

	return table_only and tbl or ffi.new("struct VkExternalSemaphoreProperties", tbl)
end

function library.s.DescriptorSetLayoutSupport(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"
	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutSupport", tbl)
end

function library.s.PhysicalDeviceShaderDrawParameterFeatures(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceShaderDrawParameterFeatures", tbl)
end

function library.s.SwapchainCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.swapchain_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.swapchain_create[tbl.flags]
	end

	if type(tbl.imageFormat) == "string" then
		tbl.imageFormat = library.e.format[tbl.imageFormat]
	end

	if type(tbl.imageColorSpace) == "string" then
		tbl.imageColorSpace = library.e.colorspace[tbl.imageColorSpace]
	end

	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end

	if type(tbl.imageUsage) == "table" then
		tbl.imageUsage = library.e.image_usage.make_enums(tbl.imageUsage)
	elseif type(tbl.imageUsage) == "string" then
		tbl.imageUsage = library.e.image_usage[tbl.imageUsage]
	end

	if type(tbl.imageSharingMode) == "string" then
		tbl.imageSharingMode = library.e.sharing_mode[tbl.imageSharingMode]
	end

	if type(tbl.preTransform) == "table" then
		tbl.preTransform = library.e.surface_transform.make_enums(tbl.preTransform)
	elseif type(tbl.preTransform) == "string" then
		tbl.preTransform = library.e.surface_transform[tbl.preTransform]
	end

	if type(tbl.compositeAlpha) == "table" then
		tbl.compositeAlpha = library.e.composite_alpha.make_enums(tbl.compositeAlpha)
	elseif type(tbl.compositeAlpha) == "string" then
		tbl.compositeAlpha = library.e.composite_alpha[tbl.compositeAlpha]
	end

	if type(tbl.presentMode) == "string" then
		tbl.presentMode = library.e.present_mode[tbl.presentMode]
	end

	return table_only and tbl or ffi.new("struct VkSwapchainCreateInfoKHR", tbl)
end

function library.s.PresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"

	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end

		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end

	if type(tbl.pSwapchains) == "table" then
		if not tbl.swapchainCount then tbl.swapchainCount = #tbl.pSwapchains end

		tbl.pSwapchains = library.s.SwapchainKHRArray(tbl.pSwapchains, false)
	end

	if type(tbl.pResults) == "string" then
		tbl.pResults = library.e.result[tbl.pResults]
	end

	return table_only and tbl or ffi.new("struct VkPresentInfoKHR", tbl)
end

function library.s.DeviceGroupPresentCapabilitiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"

	if type(tbl.modes) == "table" then
		tbl.modes = library.e.device_group_present_mode.make_enums(tbl.modes)
	elseif type(tbl.modes) == "string" then
		tbl.modes = library.e.device_group_present_mode[tbl.modes]
	end

	return table_only and tbl or ffi.new("struct VkDeviceGroupPresentCapabilitiesKHR", tbl)
end

function library.s.ImageSwapchainCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"
	return table_only and tbl or ffi.new("struct VkImageSwapchainCreateInfoKHR", tbl)
end

function library.s.BindImageMemorySwapchainInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"
	return table_only and tbl or ffi.new("struct VkBindImageMemorySwapchainInfoKHR", tbl)
end

function library.s.AcquireNextImageInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"
	return table_only and tbl or ffi.new("struct VkAcquireNextImageInfoKHR", tbl)
end

function library.s.DeviceGroupPresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"

	if type(tbl.mode) == "table" then
		tbl.mode = library.e.device_group_present_mode.make_enums(tbl.mode)
	elseif type(tbl.mode) == "string" then
		tbl.mode = library.e.device_group_present_mode[tbl.mode]
	end

	return table_only and tbl or ffi.new("struct VkDeviceGroupPresentInfoKHR", tbl)
end

function library.s.DeviceGroupSwapchainCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"

	if type(tbl.modes) == "table" then
		tbl.modes = library.e.device_group_present_mode.make_enums(tbl.modes)
	elseif type(tbl.modes) == "string" then
		tbl.modes = library.e.device_group_present_mode[tbl.modes]
	end

	return table_only and tbl or ffi.new("struct VkDeviceGroupSwapchainCreateInfoKHR", tbl)
end

function library.s.DisplayModeCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"

	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplayModeCreateInfoKHR", tbl)
end

function library.s.DisplaySurfaceCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"

	if type(tbl.transform) == "table" then
		tbl.transform = library.e.surface_transform.make_enums(tbl.transform)
	elseif type(tbl.transform) == "string" then
		tbl.transform = library.e.surface_transform[tbl.transform]
	end

	if type(tbl.alphaMode) == "table" then
		tbl.alphaMode = library.e.display_plane_alpha.make_enums(tbl.alphaMode)
	elseif type(tbl.alphaMode) == "string" then
		tbl.alphaMode = library.e.display_plane_alpha[tbl.alphaMode]
	end

	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplaySurfaceCreateInfoKHR", tbl)
end

function library.s.DisplayPresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"

	if type(tbl.srcRect) == "table" then
		tbl.srcRect = library.s.Rect2D(tbl.srcRect, true)
	end

	if type(tbl.dstRect) == "table" then
		tbl.dstRect = library.s.Rect2D(tbl.dstRect, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplayPresentInfoKHR", tbl)
end

function library.s.DebugReportCallbackCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.debug_report.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.debug_report[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkDebugReportCallbackCreateInfoEXT", tbl)
end

function library.s.PipelineRasterizationStateRasterizationOrderAMD(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"

	if type(tbl.rasterizationOrder) == "string" then
		tbl.rasterizationOrder = library.e.rasterization_order[tbl.rasterizationOrder]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD", tbl)
end

function library.s.DebugMarkerObjectNameInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"

	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end

	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectNameInfoEXT", tbl)
end

function library.s.DebugMarkerObjectTagInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"

	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end

	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectTagInfoEXT", tbl)
end

function library.s.DebugMarkerMarkerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"
	return table_only and tbl or ffi.new("struct VkDebugMarkerMarkerInfoEXT", tbl)
end

function library.s.DedicatedAllocationImageCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"
	return table_only and
		tbl or
		ffi.new("struct VkDedicatedAllocationImageCreateInfoNV", tbl)
end

function library.s.DedicatedAllocationBufferCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"
	return table_only and
		tbl or
		ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV", tbl)
end

function library.s.DedicatedAllocationMemoryAllocateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"
	return table_only and
		tbl or
		ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV", tbl)
end

function library.s.ExternalMemoryImageCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalMemoryImageCreateInfoNV", tbl)
end

function library.s.ExportMemoryAllocateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"

	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type[tbl.handleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExportMemoryAllocateInfoNV", tbl)
end

function library.s.ValidationFlagsEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"

	if type(tbl.pDisabledValidationChecks) == "string" then
		tbl.pDisabledValidationChecks = library.e.validation_check[tbl.pDisabledValidationChecks]
	end

	return table_only and tbl or ffi.new("struct VkValidationFlagsEXT", tbl)
end

function library.s.ImportMemoryFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkImportMemoryFdInfoKHR", tbl)
end

function library.s.MemoryFdPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"
	return table_only and tbl or ffi.new("struct VkMemoryFdPropertiesKHR", tbl)
end

function library.s.MemoryGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkMemoryGetFdInfoKHR", tbl)
end

function library.s.ImportSemaphoreFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.semaphore_import.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.semaphore_import[tbl.flags]
	end

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkImportSemaphoreFdInfoKHR", tbl)
end

function library.s.SemaphoreGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_semaphore_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_semaphore_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkSemaphoreGetFdInfoKHR", tbl)
end

function library.s.PhysicalDevicePushDescriptorPropertiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDevicePushDescriptorPropertiesKHR", tbl)
end

function library.s.PresentRegionsKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"

	if type(tbl.pRegions) == "table" then
		if not tbl.swapchainCount then tbl.swapchainCount = #tbl.pRegions end

		tbl.pRegions = library.s.PresentRegionKHRArray(tbl.pRegions, false)
	end

	return table_only and tbl or ffi.new("struct VkPresentRegionsKHR", tbl)
end

function library.s.ObjectTableCreateInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"

	if type(tbl.pObjectEntryTypes) == "string" then
		tbl.pObjectEntryTypes = library.e.object_entry_type[tbl.pObjectEntryTypes]
	end

	return table_only and tbl or ffi.new("struct VkObjectTableCreateInfoNVX", tbl)
end

function library.s.IndirectCommandsLayoutCreateInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"

	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.indirect_commands_layout_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.indirect_commands_layout_usage[tbl.flags]
	end

	if type(tbl.pTokens) == "table" then
		if not tbl.tokenCount then tbl.tokenCount = #tbl.pTokens end

		tbl.pTokens = library.s.IndirectCommandsLayoutTokenNVXArray(tbl.pTokens, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkIndirectCommandsLayoutCreateInfoNVX", tbl)
end

function library.s.CmdProcessCommandsInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"

	if type(tbl.pIndirectCommandsTokens) == "table" then
		if not tbl.indirectCommandsTokenCount then
			tbl.indirectCommandsTokenCount = #tbl.pIndirectCommandsTokens
		end

		tbl.pIndirectCommandsTokens = library.s.IndirectCommandsTokenNVXArray(tbl.pIndirectCommandsTokens, false)
	end

	return table_only and tbl or ffi.new("struct VkCmdProcessCommandsInfoNVX", tbl)
end

function library.s.CmdReserveSpaceForCommandsInfoNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"
	return table_only and tbl or ffi.new("struct VkCmdReserveSpaceForCommandsInfoNVX", tbl)
end

function library.s.DeviceGeneratedCommandsLimitsNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"
	return table_only and tbl or ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX", tbl)
end

function library.s.DeviceGeneratedCommandsFeaturesNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"
	return table_only and tbl or ffi.new("struct VkDeviceGeneratedCommandsFeaturesNVX", tbl)
end

function library.s.PipelineViewportWScalingStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"
	tbl.viewportWScalingEnable = tbl.viewportWScalingEnable and 1 or 0

	if type(tbl.pViewportWScalings) == "table" then
		if not tbl.viewportCount then
			tbl.viewportCount = #tbl.pViewportWScalings
		end

		tbl.pViewportWScalings = library.s.ViewportWScalingNVArray(tbl.pViewportWScalings, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineViewportWScalingStateCreateInfoNV", tbl)
end

function library.s.DisplayPowerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"

	if type(tbl.powerState) == "string" then
		tbl.powerState = library.e.display_power_state[tbl.powerState]
	end

	return table_only and tbl or ffi.new("struct VkDisplayPowerInfoEXT", tbl)
end

function library.s.DeviceEventInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"

	if type(tbl.deviceEvent) == "string" then
		tbl.deviceEvent = library.e.device_event_type[tbl.deviceEvent]
	end

	return table_only and tbl or ffi.new("struct VkDeviceEventInfoEXT", tbl)
end

function library.s.DisplayEventInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"

	if type(tbl.displayEvent) == "string" then
		tbl.displayEvent = library.e.display_event_type[tbl.displayEvent]
	end

	return table_only and tbl or ffi.new("struct VkDisplayEventInfoEXT", tbl)
end

function library.s.SwapchainCounterCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"

	if type(tbl.surfaceCounters) == "table" then
		tbl.surfaceCounters = library.e.surface_counter.make_enums(tbl.surfaceCounters)
	elseif type(tbl.surfaceCounters) == "string" then
		tbl.surfaceCounters = library.e.surface_counter[tbl.surfaceCounters]
	end

	return table_only and tbl or ffi.new("struct VkSwapchainCounterCreateInfoEXT", tbl)
end

function library.s.PresentTimesInfoGOOGLE(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"

	if type(tbl.pTimes) == "table" then
		if not tbl.swapchainCount then tbl.swapchainCount = #tbl.pTimes end

		tbl.pTimes = library.s.PresentTimeGOOGLEArray(tbl.pTimes, false)
	end

	return table_only and tbl or ffi.new("struct VkPresentTimesInfoGOOGLE", tbl)
end

function library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", tbl)
end

function library.s.PipelineViewportSwizzleStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"

	if type(tbl.pViewportSwizzles) == "table" then
		if not tbl.viewportCount then tbl.viewportCount = #tbl.pViewportSwizzles end

		tbl.pViewportSwizzles = library.s.ViewportSwizzleNVArray(tbl.pViewportSwizzles, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineViewportSwizzleStateCreateInfoNV", tbl)
end

function library.s.PhysicalDeviceDiscardRectanglePropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceDiscardRectanglePropertiesEXT", tbl)
end

function library.s.PipelineDiscardRectangleStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"

	if type(tbl.discardRectangleMode) == "string" then
		tbl.discardRectangleMode = library.e.discard_rectangle_mode[tbl.discardRectangleMode]
	end

	if type(tbl.pDiscardRectangles) == "table" then
		if not tbl.discardRectangleCount then
			tbl.discardRectangleCount = #tbl.pDiscardRectangles
		end

		tbl.pDiscardRectangles = library.s.Rect2DArray(tbl.pDiscardRectangles, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineDiscardRectangleStateCreateInfoEXT", tbl)
end

function library.s.PhysicalDeviceConservativeRasterizationPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT", tbl)
end

function library.s.PipelineRasterizationConservativeStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"

	if type(tbl.conservativeRasterizationMode) == "string" then
		tbl.conservativeRasterizationMode = library.e.conservative_rasterization_mode[tbl.conservativeRasterizationMode]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineRasterizationConservativeStateCreateInfoEXT", tbl)
end

function library.s.HdrMetadataEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"

	if type(tbl.displayPrimaryRed) == "table" then
		tbl.displayPrimaryRed = library.s.XYColorEXT(tbl.displayPrimaryRed, true)
	end

	if type(tbl.displayPrimaryGreen) == "table" then
		tbl.displayPrimaryGreen = library.s.XYColorEXT(tbl.displayPrimaryGreen, true)
	end

	if type(tbl.displayPrimaryBlue) == "table" then
		tbl.displayPrimaryBlue = library.s.XYColorEXT(tbl.displayPrimaryBlue, true)
	end

	if type(tbl.whitePoint) == "table" then
		tbl.whitePoint = library.s.XYColorEXT(tbl.whitePoint, true)
	end

	return table_only and tbl or ffi.new("struct VkHdrMetadataEXT", tbl)
end

function library.s.SharedPresentSurfaceCapabilitiesKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"

	if type(tbl.sharedPresentSupportedUsageFlags) == "table" then
		tbl.sharedPresentSupportedUsageFlags = library.e.image_usage.make_enums(tbl.sharedPresentSupportedUsageFlags)
	elseif type(tbl.sharedPresentSupportedUsageFlags) == "string" then
		tbl.sharedPresentSupportedUsageFlags = library.e.image_usage[tbl.sharedPresentSupportedUsageFlags]
	end

	return table_only and
		tbl or
		ffi.new("struct VkSharedPresentSurfaceCapabilitiesKHR", tbl)
end

function library.s.ImportFenceFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.fence_import.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.fence_import[tbl.flags]
	end

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkImportFenceFdInfoKHR", tbl)
end

function library.s.FenceGetFdInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_fence_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_fence_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkFenceGetFdInfoKHR", tbl)
end

function library.s.DebugUtilsObjectNameInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"

	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.object_type[tbl.objectType]
	end

	return table_only and tbl or ffi.new("struct VkDebugUtilsObjectNameInfoEXT", tbl)
end

function library.s.DebugUtilsObjectTagInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"

	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.object_type[tbl.objectType]
	end

	return table_only and tbl or ffi.new("struct VkDebugUtilsObjectTagInfoEXT", tbl)
end

function library.s.DebugUtilsLabelEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"
	return table_only and tbl or ffi.new("struct VkDebugUtilsLabelEXT", tbl)
end

function library.s.DebugUtilsMessengerCallbackDataEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"

	if type(tbl.pQueueLabels) == "table" then
		if not tbl.queueLabelCount then tbl.queueLabelCount = #tbl.pQueueLabels end

		tbl.pQueueLabels = library.s.DebugUtilsLabelEXTArray(tbl.pQueueLabels, false)
	end

	if type(tbl.pCmdBufLabels) == "table" then
		if not tbl.cmdBufLabelCount then
			tbl.cmdBufLabelCount = #tbl.pCmdBufLabels
		end

		tbl.pCmdBufLabels = library.s.DebugUtilsLabelEXTArray(tbl.pCmdBufLabels, false)
	end

	if type(tbl.pObjects) == "table" then
		if not tbl.objectCount then tbl.objectCount = #tbl.pObjects end

		tbl.pObjects = library.s.DebugUtilsObjectNameInfoEXTArray(tbl.pObjects, false)
	end

	return table_only and tbl or ffi.new("struct VkDebugUtilsMessengerCallbackDataEXT", tbl)
end

function library.s.DebugUtilsMessengerCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"

	if type(tbl.messageSeverity) == "table" then
		tbl.messageSeverity = library.e.debug_utils_message_severity.make_enums(tbl.messageSeverity)
	elseif type(tbl.messageSeverity) == "string" then
		tbl.messageSeverity = library.e.debug_utils_message_severity[tbl.messageSeverity]
	end

	if type(tbl.messageType) == "table" then
		tbl.messageType = library.e.debug_utils_message_type.make_enums(tbl.messageType)
	elseif type(tbl.messageType) == "string" then
		tbl.messageType = library.e.debug_utils_message_type[tbl.messageType]
	end

	return table_only and tbl or ffi.new("struct VkDebugUtilsMessengerCreateInfoEXT", tbl)
end

function library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", tbl)
end

function library.s.SamplerReductionModeCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"

	if type(tbl.reductionMode) == "string" then
		tbl.reductionMode = library.e.sampler_reduction_mode[tbl.reductionMode]
	end

	return table_only and tbl or ffi.new("struct VkSamplerReductionModeCreateInfoEXT", tbl)
end

function library.s.SampleLocationsInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"

	if type(tbl.sampleLocationsPerPixel) == "table" then
		tbl.sampleLocationsPerPixel = library.e.sample_count.make_enums(tbl.sampleLocationsPerPixel)
	elseif type(tbl.sampleLocationsPerPixel) == "string" then
		tbl.sampleLocationsPerPixel = library.e.sample_count[tbl.sampleLocationsPerPixel]
	end

	if type(tbl.sampleLocationGridSize) == "table" then
		tbl.sampleLocationGridSize = library.s.Extent2D(tbl.sampleLocationGridSize, true)
	end

	if type(tbl.pSampleLocations) == "table" then
		if not tbl.sampleLocationsCount then
			tbl.sampleLocationsCount = #tbl.pSampleLocations
		end

		tbl.pSampleLocations = library.s.SampleLocationEXTArray(tbl.pSampleLocations, false)
	end

	return table_only and tbl or ffi.new("struct VkSampleLocationsInfoEXT", tbl)
end

function library.s.RenderPassSampleLocationsBeginInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"

	if type(tbl.pAttachmentInitialSampleLocations) == "table" then
		if not tbl.attachmentInitialSampleLocationsCount then
			tbl.attachmentInitialSampleLocationsCount = #tbl.pAttachmentInitialSampleLocations
		end

		tbl.pAttachmentInitialSampleLocations = library.s.AttachmentSampleLocationsEXTArray(tbl.pAttachmentInitialSampleLocations, false)
	end

	if type(tbl.pPostSubpassSampleLocations) == "table" then
		if not tbl.postSubpassSampleLocationsCount then
			tbl.postSubpassSampleLocationsCount = #tbl.pPostSubpassSampleLocations
		end

		tbl.pPostSubpassSampleLocations = library.s.SubpassSampleLocationsEXTArray(tbl.pPostSubpassSampleLocations, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkRenderPassSampleLocationsBeginInfoEXT", tbl)
end

function library.s.PipelineSampleLocationsStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"
	tbl.sampleLocationsEnable = tbl.sampleLocationsEnable and 1 or 0

	if type(tbl.sampleLocationsInfo) == "table" then
		tbl.sampleLocationsInfo = library.s.SampleLocationsInfoEXT(tbl.sampleLocationsInfo, true)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineSampleLocationsStateCreateInfoEXT", tbl)
end

function library.s.PhysicalDeviceSampleLocationsPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"

	if type(tbl.sampleLocationSampleCounts) == "table" then
		tbl.sampleLocationSampleCounts = library.e.sample_count.make_enums(tbl.sampleLocationSampleCounts)
	elseif type(tbl.sampleLocationSampleCounts) == "string" then
		tbl.sampleLocationSampleCounts = library.e.sample_count[tbl.sampleLocationSampleCounts]
	end

	if type(tbl.maxSampleLocationGridSize) == "table" then
		tbl.maxSampleLocationGridSize = library.s.Extent2D(tbl.maxSampleLocationGridSize, true)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceSampleLocationsPropertiesEXT", tbl)
end

function library.s.MultisamplePropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"

	if type(tbl.maxSampleLocationGridSize) == "table" then
		tbl.maxSampleLocationGridSize = library.s.Extent2D(tbl.maxSampleLocationGridSize, true)
	end

	return table_only and tbl or ffi.new("struct VkMultisamplePropertiesEXT", tbl)
end

function library.s.ImageFormatListCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"

	if type(tbl.pViewFormats) == "string" then
		tbl.pViewFormats = library.e.format[tbl.pViewFormats]
	end

	return table_only and tbl or ffi.new("struct VkImageFormatListCreateInfoKHR", tbl)
end

function library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", tbl)
end

function library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", tbl)
end

function library.s.PipelineColorBlendAdvancedStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"

	if type(tbl.blendOverlap) == "string" then
		tbl.blendOverlap = library.e.blend_overlap[tbl.blendOverlap]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineColorBlendAdvancedStateCreateInfoEXT", tbl)
end

function library.s.PipelineCoverageToColorStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"
	tbl.coverageToColorEnable = tbl.coverageToColorEnable and 1 or 0
	return table_only and
		tbl or
		ffi.new("struct VkPipelineCoverageToColorStateCreateInfoNV", tbl)
end

function library.s.PipelineCoverageModulationStateCreateInfoNV(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"

	if type(tbl.coverageModulationMode) == "string" then
		tbl.coverageModulationMode = library.e.coverage_modulation_mode[tbl.coverageModulationMode]
	end

	tbl.coverageModulationTableEnable = tbl.coverageModulationTableEnable and 1 or 0
	return table_only and
		tbl or
		ffi.new("struct VkPipelineCoverageModulationStateCreateInfoNV", tbl)
end

function library.s.ValidationCacheCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"
	return table_only and tbl or ffi.new("struct VkValidationCacheCreateInfoEXT", tbl)
end

function library.s.ShaderModuleValidationCacheCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkShaderModuleValidationCacheCreateInfoEXT", tbl)
end

function library.s.DescriptorSetLayoutBindingFlagsCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT", tbl)
end

function library.s.PhysicalDeviceDescriptorIndexingFeaturesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT", tbl)
end

function library.s.PhysicalDeviceDescriptorIndexingPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT", tbl)
end

function library.s.DescriptorSetVariableDescriptorCountAllocateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT", tbl)
end

function library.s.DescriptorSetVariableDescriptorCountLayoutSupportEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT", tbl)
end

function library.s.DeviceQueueGlobalPriorityCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"

	if type(tbl.globalPriority) == "string" then
		tbl.globalPriority = library.e.queue_global_priority[tbl.globalPriority]
	end

	return table_only and
		tbl or
		ffi.new("struct VkDeviceQueueGlobalPriorityCreateInfoEXT", tbl)
end

function library.s.ImportMemoryHostPointerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"

	if type(tbl.handleType) == "table" then
		tbl.handleType = library.e.external_memory_handle_type.make_enums(tbl.handleType)
	elseif type(tbl.handleType) == "string" then
		tbl.handleType = library.e.external_memory_handle_type[tbl.handleType]
	end

	return table_only and tbl or ffi.new("struct VkImportMemoryHostPointerInfoEXT", tbl)
end

function library.s.MemoryHostPointerPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"
	return table_only and tbl or ffi.new("struct VkMemoryHostPointerPropertiesEXT", tbl)
end

function library.s.PhysicalDeviceExternalMemoryHostPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT", tbl)
end

function library.s.PhysicalDeviceShaderCorePropertiesAMD(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceShaderCorePropertiesAMD", tbl)
end

function library.s.PhysicalDeviceVertexAttributeDivisorPropertiesEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", tbl)
end

function library.s.PipelineVertexInputDivisorStateCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"

	if type(tbl.pVertexBindingDivisors) == "table" then
		if not tbl.vertexBindingDivisorCount then
			tbl.vertexBindingDivisorCount = #tbl.pVertexBindingDivisors
		end

		tbl.pVertexBindingDivisors = library.s.VertexInputBindingDivisorDescriptionEXTArray(tbl.pVertexBindingDivisors, false)
	end

	return table_only and
		tbl or
		ffi.new("struct VkPipelineVertexInputDivisorStateCreateInfoEXT", tbl)
end

function library.s.PhysicalDeviceMultiviewFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceMultiviewFeatures[?]", #tbl, tbl)
end

function library.s.DedicatedAllocationMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationMemoryAllocateInfoNV(v)
	end

	return ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV[?]", #tbl, tbl)
end

function library.s.DescriptorPoolArray(tbl)
	return ffi.new("struct VkDescriptorPool_T *[?]", #tbl, tbl)
end

function library.s.ClearDepthStencilValue(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkClearDepthStencilValue", tbl)
end

function library.s.ClearDepthStencilValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearDepthStencilValue(v)
	end

	return ffi.new("struct VkClearDepthStencilValue[?]", #tbl, tbl)
end

function library.s.SparseBufferMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then tbl.bindCount = #tbl.pBinds end

		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end

	return table_only and tbl or ffi.new("struct VkSparseBufferMemoryBindInfo", tbl)
end

function library.s.SparseBufferMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseBufferMemoryBindInfo(v)
	end

	return ffi.new("struct VkSparseBufferMemoryBindInfo[?]", #tbl, tbl)
end

function library.s.ImageViewArray(tbl)
	return ffi.new("struct VkImageView_T *[?]", #tbl, tbl)
end

function library.s.DescriptorSetArray(tbl)
	return ffi.new("struct VkDescriptorSet_T *[?]", #tbl, tbl)
end

function library.s.MemoryDedicatedRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedRequirements(v)
	end

	return ffi.new("struct VkMemoryDedicatedRequirements[?]", #tbl, tbl)
end

function library.s.ComponentMapping(tbl, table_only)
	if type(tbl.r) == "string" then tbl.r = library.e.component_swizzle[tbl.r] end

	if type(tbl.g) == "string" then tbl.g = library.e.component_swizzle[tbl.g] end

	if type(tbl.b) == "string" then tbl.b = library.e.component_swizzle[tbl.b] end

	if type(tbl.a) == "string" then tbl.a = library.e.component_swizzle[tbl.a] end

	return table_only and tbl or ffi.new("struct VkComponentMapping", tbl)
end

function library.s.ComponentMappingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComponentMapping(v)
	end

	return ffi.new("struct VkComponentMapping[?]", #tbl, tbl)
end

function library.s.PipelineMultisampleStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineMultisampleStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineMultisampleStateCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineTessellationDomainOriginStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineTessellationDomainOriginStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineTessellationDomainOriginStateCreateInfo[?]", #tbl, tbl)
end

function library.s.DebugUtilsObjectTagInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugUtilsObjectTagInfoEXT(v)
	end

	return ffi.new("struct VkDebugUtilsObjectTagInfoEXT[?]", #tbl, tbl)
end

function library.s.SurfaceCapabilities2EXT(tbl, table_only)
	if type(tbl.currentExtent) == "table" then
		tbl.currentExtent = library.s.Extent2D(tbl.currentExtent, true)
	end

	if type(tbl.minImageExtent) == "table" then
		tbl.minImageExtent = library.s.Extent2D(tbl.minImageExtent, true)
	end

	if type(tbl.maxImageExtent) == "table" then
		tbl.maxImageExtent = library.s.Extent2D(tbl.maxImageExtent, true)
	end

	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end

	if type(tbl.currentTransform) == "table" then
		tbl.currentTransform = library.e.surface_transform.make_enums(tbl.currentTransform)
	elseif type(tbl.currentTransform) == "string" then
		tbl.currentTransform = library.e.surface_transform[tbl.currentTransform]
	end

	if type(tbl.supportedCompositeAlpha) == "table" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha.make_enums(tbl.supportedCompositeAlpha)
	elseif type(tbl.supportedCompositeAlpha) == "string" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha[tbl.supportedCompositeAlpha]
	end

	if type(tbl.supportedUsageFlags) == "table" then
		tbl.supportedUsageFlags = library.e.image_usage.make_enums(tbl.supportedUsageFlags)
	elseif type(tbl.supportedUsageFlags) == "string" then
		tbl.supportedUsageFlags = library.e.image_usage[tbl.supportedUsageFlags]
	end

	if type(tbl.supportedSurfaceCounters) == "table" then
		tbl.supportedSurfaceCounters = library.e.surface_counter.make_enums(tbl.supportedSurfaceCounters)
	elseif type(tbl.supportedSurfaceCounters) == "string" then
		tbl.supportedSurfaceCounters = library.e.surface_counter[tbl.supportedSurfaceCounters]
	end

	return table_only and tbl or ffi.new("struct VkSurfaceCapabilities2EXT", tbl)
end

function library.s.SurfaceCapabilities2EXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilities2EXT(v)
	end

	return ffi.new("struct VkSurfaceCapabilities2EXT[?]", #tbl, tbl)
end

function library.s.DispatchIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDispatchIndirectCommand", tbl)
end

function library.s.DispatchIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DispatchIndirectCommand(v)
	end

	return ffi.new("struct VkDispatchIndirectCommand[?]", #tbl, tbl)
end

function library.s.ExternalMemoryProperties(tbl, table_only)
	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature[tbl.externalMemoryFeatures]
	end

	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type[tbl.exportFromImportedHandleTypes]
	end

	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type[tbl.compatibleHandleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalMemoryProperties", tbl)
end

function library.s.ExternalMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryProperties(v)
	end

	return ffi.new("struct VkExternalMemoryProperties[?]", #tbl, tbl)
end

function library.s.DebugMarkerObjectTagInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectTagInfoEXT(v)
	end

	return ffi.new("struct VkDebugMarkerObjectTagInfoEXT[?]", #tbl, tbl)
end

function library.s.PipelineCoverageModulationStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCoverageModulationStateCreateInfoNV(v)
	end

	return ffi.new("struct VkPipelineCoverageModulationStateCreateInfoNV[?]", #tbl, tbl)
end

function library.s.DebugReportCallbackEXTArray(tbl)
	return ffi.new("struct VkDebugReportCallbackEXT_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMultiviewFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceMultiviewFeatures[?]", #tbl, tbl)
end

function library.s.BufferArray(tbl)
	return ffi.new("struct VkBuffer_T *[?]", #tbl, tbl)
end

function library.s.ExternalMemoryImageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfo(v)
	end

	return ffi.new("struct VkExternalMemoryImageCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineCacheArray(tbl)
	return ffi.new("struct VkPipelineCache_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceImageFormatInfo2(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end

	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceImageFormatInfo2", tbl)
end

function library.s.PhysicalDeviceImageFormatInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceImageFormatInfo2(v)
	end

	return ffi.new("struct VkPhysicalDeviceImageFormatInfo2[?]", #tbl, tbl)
end

function library.s.ImageArray(tbl)
	return ffi.new("struct VkImage_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMemoryProperties(tbl, table_only)
	if type(tbl.memoryTypes) == "table" then
		tbl.memoryTypes = library.s.MemoryType(tbl.memoryTypes, true)
	end

	if type(tbl.memoryHeaps) == "table" then
		tbl.memoryHeaps = library.s.MemoryHeap(tbl.memoryHeaps, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties", tbl)
end

function library.s.PhysicalDeviceMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceMemoryProperties[?]", #tbl, tbl)
end

function library.s.ApplicationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ApplicationInfo(v)
	end

	return ffi.new("struct VkApplicationInfo[?]", #tbl, tbl)
end

function library.s.SubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubmitInfo(v)
	end

	return ffi.new("struct VkSubmitInfo[?]", #tbl, tbl)
end

function library.s.RenderPassBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassBeginInfo(v)
	end

	return ffi.new("struct VkRenderPassBeginInfo[?]", #tbl, tbl)
end

function library.s.ExternalImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatProperties(v)
	end

	return ffi.new("struct VkExternalImageFormatProperties[?]", #tbl, tbl)
end

function library.s.ImagePlaneMemoryRequirementsInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImagePlaneMemoryRequirementsInfo(v)
	end

	return ffi.new("struct VkImagePlaneMemoryRequirementsInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceProperties2(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.PhysicalDeviceProperties(tbl.properties, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties2", tbl)
end

function library.s.PhysicalDeviceProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties2(v)
	end

	return ffi.new("struct VkPhysicalDeviceProperties2[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSparseImageFormatInfo2(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end

	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2", tbl)
end

function library.s.PhysicalDeviceSparseImageFormatInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseImageFormatInfo2(v)
	end

	return ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2[?]", #tbl, tbl)
end

function library.s.ObjectTableCreateInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableCreateInfoNVX(v)
	end

	return ffi.new("struct VkObjectTableCreateInfoNVX[?]", #tbl, tbl)
end

function library.s.ComputePipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComputePipelineCreateInfo(v)
	end

	return ffi.new("struct VkComputePipelineCreateInfo[?]", #tbl, tbl)
end

function library.s.StencilOpState(tbl, table_only)
	if type(tbl.failOp) == "string" then
		tbl.failOp = library.e.stencil_op[tbl.failOp]
	end

	if type(tbl.passOp) == "string" then
		tbl.passOp = library.e.stencil_op[tbl.passOp]
	end

	if type(tbl.depthFailOp) == "string" then
		tbl.depthFailOp = library.e.stencil_op[tbl.depthFailOp]
	end

	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end

	return table_only and tbl or ffi.new("struct VkStencilOpState", tbl)
end

function library.s.StencilOpStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.StencilOpState(v)
	end

	return ffi.new("struct VkStencilOpState[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionArray(tbl)
	return ffi.new("struct VkSamplerYcbcrConversion_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceArray(tbl)
	return ffi.new("struct VkPhysicalDevice_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSubgroupPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSubgroupProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceSubgroupProperties[?]", #tbl, tbl)
end

function library.s.ShaderModuleArray(tbl)
	return ffi.new("struct VkShaderModule_T *[?]", #tbl, tbl)
end

function library.s.BindBufferMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindBufferMemoryInfo(v)
	end

	return ffi.new("struct VkBindBufferMemoryInfo[?]", #tbl, tbl)
end

function library.s.CmdProcessCommandsInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CmdProcessCommandsInfoNVX(v)
	end

	return ffi.new("struct VkCmdProcessCommandsInfoNVX[?]", #tbl, tbl)
end

function library.s.PhysicalDevice16BitStorageFeatures(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDevice16BitStorageFeatures", tbl)
end

function library.s.PhysicalDevice16BitStorageFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevice16BitStorageFeatures(v)
	end

	return ffi.new("struct VkPhysicalDevice16BitStorageFeatures[?]", #tbl, tbl)
end

function library.s.Extent3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent3D", tbl)
end

function library.s.Extent3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent3D(v)
	end

	return ffi.new("struct VkExtent3D[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceDiscardRectanglePropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceDiscardRectanglePropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceDiscardRectanglePropertiesEXT[?]", #tbl, tbl)
end

function library.s.PipelineDepthStencilStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDepthStencilStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineDepthStencilStateCreateInfo[?]", #tbl, tbl)
end

function library.s.DebugUtilsMessengerCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugUtilsMessengerCreateInfoEXT(v)
	end

	return ffi.new("struct VkDebugUtilsMessengerCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.ProtectedSubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ProtectedSubmitInfo(v)
	end

	return ffi.new("struct VkProtectedSubmitInfo[?]", #tbl, tbl)
end

function library.s.PipelineTessellationDomainOriginStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineTessellationDomainOriginStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineTessellationDomainOriginStateCreateInfo[?]", #tbl, tbl)
end

function library.s.ExternalFencePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalFenceProperties(v)
	end

	return ffi.new("struct VkExternalFenceProperties[?]", #tbl, tbl)
end

function library.s.PipelineViewportSwizzleStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportSwizzleStateCreateInfoNV(v)
	end

	return ffi.new("struct VkPipelineViewportSwizzleStateCreateInfoNV[?]", #tbl, tbl)
end

function library.s.AttachmentDescription(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.attachment_description.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.attachment_description[tbl.flags]
	end

	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end

	if type(tbl.loadOp) == "string" then
		tbl.loadOp = library.e.attachment_load_op[tbl.loadOp]
	end

	if type(tbl.storeOp) == "string" then
		tbl.storeOp = library.e.attachment_store_op[tbl.storeOp]
	end

	if type(tbl.stencilLoadOp) == "string" then
		tbl.stencilLoadOp = library.e.attachment_load_op[tbl.stencilLoadOp]
	end

	if type(tbl.stencilStoreOp) == "string" then
		tbl.stencilStoreOp = library.e.attachment_store_op[tbl.stencilStoreOp]
	end

	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end

	if type(tbl.finalLayout) == "string" then
		tbl.finalLayout = library.e.image_layout[tbl.finalLayout]
	end

	return table_only and tbl or ffi.new("struct VkAttachmentDescription", tbl)
end

function library.s.AttachmentDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentDescription(v)
	end

	return ffi.new("struct VkAttachmentDescription[?]", #tbl, tbl)
end

function library.s.ExportMemoryAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfo(v)
	end

	return ffi.new("struct VkExportMemoryAllocateInfo[?]", #tbl, tbl)
end

function library.s.RenderPassMultiviewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassMultiviewCreateInfo(v)
	end

	return ffi.new("struct VkRenderPassMultiviewCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineVertexInputDivisorStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineVertexInputDivisorStateCreateInfoEXT(v)
	end

	return ffi.new("struct VkPipelineVertexInputDivisorStateCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.AttachmentReference(tbl, table_only)
	if type(tbl.layout) == "string" then
		tbl.layout = library.e.image_layout[tbl.layout]
	end

	return table_only and tbl or ffi.new("struct VkAttachmentReference", tbl)
end

function library.s.AttachmentReferenceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentReference(v)
	end

	return ffi.new("struct VkAttachmentReference[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceShaderCorePropertiesAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceShaderCorePropertiesAMD(v)
	end

	return ffi.new("struct VkPhysicalDeviceShaderCorePropertiesAMD[?]", #tbl, tbl)
end

function library.s.SparseImageFormatProperties2(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.SparseImageFormatProperties(tbl.properties, true)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties2", tbl)
end

function library.s.SparseImageFormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties2(v)
	end

	return ffi.new("struct VkSparseImageFormatProperties2[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMultiviewPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceMultiviewProperties[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalMemoryHostPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalMemoryHostPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT[?]", #tbl, tbl)
end

function library.s.ClearColorValue(tbl, table_only)
	return table_only and tbl or ffi.new("union VkClearColorValue", tbl)
end

function library.s.ClearColorValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearColorValue(v)
	end

	return ffi.new("union VkClearColorValue[?]", #tbl, tbl)
end

function library.s.QueueFamilyProperties2(tbl, table_only)
	if type(tbl.queueFamilyProperties) == "table" then
		tbl.queueFamilyProperties = library.s.QueueFamilyProperties(tbl.queueFamilyProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties2", tbl)
end

function library.s.QueueFamilyProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties2(v)
	end

	return ffi.new("struct VkQueueFamilyProperties2[?]", #tbl, tbl)
end

function library.s.ImportMemoryHostPointerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportMemoryHostPointerInfoEXT(v)
	end

	return ffi.new("struct VkImportMemoryHostPointerInfoEXT[?]", #tbl, tbl)
end

function library.s.DeviceQueueGlobalPriorityCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceQueueGlobalPriorityCreateInfoEXT(v)
	end

	return ffi.new("struct VkDeviceQueueGlobalPriorityCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.DescriptorSetVariableDescriptorCountLayoutSupportEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetVariableDescriptorCountLayoutSupportEXT(v)
	end

	return ffi.new("struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT[?]", #tbl, tbl)
end

function library.s.IndirectCommandsLayoutTokenNVX(tbl, table_only)
	if type(tbl.tokenType) == "string" then
		tbl.tokenType = library.e.indirect_commands_token_type[tbl.tokenType]
	end

	return table_only and tbl or ffi.new("struct VkIndirectCommandsLayoutTokenNVX", tbl)
end

function library.s.IndirectCommandsLayoutTokenNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsLayoutTokenNVX(v)
	end

	return ffi.new("struct VkIndirectCommandsLayoutTokenNVX[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMaintenance3Properties(tbl, table_only)
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceMaintenance3Properties", tbl)
end

function library.s.PhysicalDeviceMaintenance3PropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMaintenance3Properties(v)
	end

	return ffi.new("struct VkPhysicalDeviceMaintenance3Properties[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceDescriptorIndexingPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceDescriptorIndexingPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceDescriptorIndexingFeaturesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceDescriptorIndexingFeaturesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutBindingFlagsCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutBindingFlagsCreateInfoEXT(v)
	end

	return ffi.new("struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.FenceGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FenceGetFdInfoKHR(v)
	end

	return ffi.new("struct VkFenceGetFdInfoKHR[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionArray(tbl)
	return ffi.new("struct VkSamplerYcbcrConversion_T *[?]", #tbl, tbl)
end

function library.s.ShaderModuleValidationCacheCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderModuleValidationCacheCreateInfoEXT(v)
	end

	return ffi.new("struct VkShaderModuleValidationCacheCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.ValidationCacheCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ValidationCacheCreateInfoEXT(v)
	end

	return ffi.new("struct VkValidationCacheCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.BufferViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferViewCreateInfo(v)
	end

	return ffi.new("struct VkBufferViewCreateInfo[?]", #tbl, tbl)
end

function library.s.ValidationCacheEXTArray(tbl)
	return ffi.new("struct VkValidationCacheEXT_T *[?]", #tbl, tbl)
end

function library.s.ClearValue(tbl, table_only)
	if type(tbl.color) == "table" then
		tbl.color = library.s.ClearColorValue(tbl.color, true)
	end

	if type(tbl.depthStencil) == "table" then
		tbl.depthStencil = library.s.ClearDepthStencilValue(tbl.depthStencil, true)
	end

	return table_only and tbl or ffi.new("union VkClearValue", tbl)
end

function library.s.ClearValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearValue(v)
	end

	return ffi.new("union VkClearValue[?]", #tbl, tbl)
end

function library.s.SubpassDescription(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.subpass_description.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.subpass_description[tbl.flags]
	end

	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end

	if type(tbl.pInputAttachments) == "table" then
		if not tbl.inputAttachmentCount then
			tbl.inputAttachmentCount = #tbl.pInputAttachments
		end

		tbl.pInputAttachments = library.s.AttachmentReferenceArray(tbl.pInputAttachments, false)
	end

	if type(tbl.pColorAttachments) == "table" then
		if not tbl.colorAttachmentCount then
			tbl.colorAttachmentCount = #tbl.pColorAttachments
		end

		tbl.pColorAttachments = library.s.AttachmentReferenceArray(tbl.pColorAttachments, false)
	end

	if type(tbl.pResolveAttachments) == "table" then
		tbl.pResolveAttachments = library.s.AttachmentReference(tbl.pResolveAttachments, false)
	end

	if type(tbl.pDepthStencilAttachment) == "table" then
		tbl.pDepthStencilAttachment = library.s.AttachmentReference(tbl.pDepthStencilAttachment, false)
	end

	return table_only and tbl or ffi.new("struct VkSubpassDescription", tbl)
end

function library.s.SubpassDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDescription(v)
	end

	return ffi.new("struct VkSubpassDescription[?]", #tbl, tbl)
end

function library.s.PipelineCoverageToColorStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCoverageToColorStateCreateInfoNV(v)
	end

	return ffi.new("struct VkPipelineCoverageToColorStateCreateInfoNV[?]", #tbl, tbl)
end

function library.s.ClearAttachment(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	if type(tbl.clearValue) == "table" then
		tbl.clearValue = library.s.ClearValue(tbl.clearValue, true)
	end

	return table_only and tbl or ffi.new("struct VkClearAttachment", tbl)
end

function library.s.ClearAttachmentArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearAttachment(v)
	end

	return ffi.new("struct VkClearAttachment[?]", #tbl, tbl)
end

function library.s.DisplayPowerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPowerInfoEXT(v)
	end

	return ffi.new("struct VkDisplayPowerInfoEXT[?]", #tbl, tbl)
end

function library.s.ImageSubresourceLayers(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	return table_only and tbl or ffi.new("struct VkImageSubresourceLayers", tbl)
end

function library.s.ImageSubresourceLayersArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceLayers(v)
	end

	return ffi.new("struct VkImageSubresourceLayers[?]", #tbl, tbl)
end

function library.s.ObjectTableEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkObjectTableEntryNVX", tbl)
end

function library.s.ObjectTableEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableEntryNVX(v)
	end

	return ffi.new("struct VkObjectTableEntryNVX[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceVariablePointerFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceVariablePointerFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceVariablePointerFeatures[?]", #tbl, tbl)
end

function library.s.SparseImageFormatProperties(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	if type(tbl.imageGranularity) == "table" then
		tbl.imageGranularity = library.s.Extent3D(tbl.imageGranularity, true)
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_image_format.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_image_format[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties", tbl)
end

function library.s.SparseImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties(v)
	end

	return ffi.new("struct VkSparseImageFormatProperties[?]", #tbl, tbl)
end

function library.s.PipelineColorBlendAdvancedStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendAdvancedStateCreateInfoEXT(v)
	end

	return ffi.new("struct VkPipelineColorBlendAdvancedStateCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT[?]", #tbl, tbl)
end

function library.s.DeviceGroupDeviceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupDeviceCreateInfo(v)
	end

	return ffi.new("struct VkDeviceGroupDeviceCreateInfo[?]", #tbl, tbl)
end

function library.s.InputAttachmentAspectReference(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	return table_only and tbl or ffi.new("struct VkInputAttachmentAspectReference", tbl)
end

function library.s.InputAttachmentAspectReferenceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.InputAttachmentAspectReference(v)
	end

	return ffi.new("struct VkInputAttachmentAspectReference[?]", #tbl, tbl)
end

function library.s.QueueFamilyProperties(tbl, table_only)
	if type(tbl.queueFlags) == "table" then
		tbl.queueFlags = library.e.queue.make_enums(tbl.queueFlags)
	elseif type(tbl.queueFlags) == "string" then
		tbl.queueFlags = library.e.queue[tbl.queueFlags]
	end

	if type(tbl.minImageTransferGranularity) == "table" then
		tbl.minImageTransferGranularity = library.s.Extent3D(tbl.minImageTransferGranularity, true)
	end

	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties", tbl)
end

function library.s.QueueFamilyPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties(v)
	end

	return ffi.new("struct VkQueueFamilyProperties[?]", #tbl, tbl)
end

function library.s.ClearRect(tbl, table_only)
	if type(tbl.rect) == "table" then
		tbl.rect = library.s.Rect2D(tbl.rect, true)
	end

	return table_only and tbl or ffi.new("struct VkClearRect", tbl)
end

function library.s.ClearRectArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearRect(v)
	end

	return ffi.new("struct VkClearRect[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT[?]", #tbl, tbl)
end

function library.s.LayerProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkLayerProperties", tbl)
end

function library.s.LayerPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.LayerProperties(v)
	end

	return ffi.new("struct VkLayerProperties[?]", #tbl, tbl)
end

function library.s.MultisamplePropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MultisamplePropertiesEXT(v)
	end

	return ffi.new("struct VkMultisamplePropertiesEXT[?]", #tbl, tbl)
end

function library.s.ImageMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageMemoryRequirementsInfo2", tbl)
end

function library.s.ImageMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkImageMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.IndirectCommandsLayoutCreateInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsLayoutCreateInfoNVX(v)
	end

	return ffi.new("struct VkIndirectCommandsLayoutCreateInfoNVX[?]", #tbl, tbl)
end

function library.s.PipelineSampleLocationsStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineSampleLocationsStateCreateInfoEXT(v)
	end

	return ffi.new("struct VkPipelineSampleLocationsStateCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.RenderPassSampleLocationsBeginInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassSampleLocationsBeginInfoEXT(v)
	end

	return ffi.new("struct VkRenderPassSampleLocationsBeginInfoEXT[?]", #tbl, tbl)
end

function library.s.FormatProperties2(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.FormatProperties(tbl.formatProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkFormatProperties2", tbl)
end

function library.s.FormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties2(v)
	end

	return ffi.new("struct VkFormatProperties2[?]", #tbl, tbl)
end

function library.s.BufferMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferMemoryRequirementsInfo2", tbl)
end

function library.s.BufferMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkBufferMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.AttachmentSampleLocationsEXT(tbl, table_only)
	if type(tbl.sampleLocationsInfo) == "table" then
		tbl.sampleLocationsInfo = library.s.SampleLocationsInfoEXT(tbl.sampleLocationsInfo, true)
	end

	return table_only and tbl or ffi.new("struct VkAttachmentSampleLocationsEXT", tbl)
end

function library.s.AttachmentSampleLocationsEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentSampleLocationsEXT(v)
	end

	return ffi.new("struct VkAttachmentSampleLocationsEXT[?]", #tbl, tbl)
end

function library.s.SampleLocationsInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SampleLocationsInfoEXT(v)
	end

	return ffi.new("struct VkSampleLocationsInfoEXT[?]", #tbl, tbl)
end

function library.s.SampleLocationEXT(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSampleLocationEXT", tbl)
end

function library.s.SampleLocationEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SampleLocationEXT(v)
	end

	return ffi.new("struct VkSampleLocationEXT[?]", #tbl, tbl)
end

function library.s.SamplerReductionModeCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerReductionModeCreateInfoEXT(v)
	end

	return ffi.new("struct VkSamplerReductionModeCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalSemaphoreInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalSemaphoreInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalSemaphoreInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceConservativeRasterizationPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceConservativeRasterizationPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT[?]", #tbl, tbl)
end

function library.s.BindImagePlaneMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImagePlaneMemoryInfo(v)
	end

	return ffi.new("struct VkBindImagePlaneMemoryInfo[?]", #tbl, tbl)
end

function library.s.MemoryAllocateFlagsInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateFlagsInfo(v)
	end

	return ffi.new("struct VkMemoryAllocateFlagsInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupPresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupPresentInfoKHR(v)
	end

	return ffi.new("struct VkDeviceGroupPresentInfoKHR[?]", #tbl, tbl)
end

function library.s.IndirectCommandsLayoutNVXArray(tbl)
	return ffi.new("struct VkIndirectCommandsLayoutNVX_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceVariablePointerFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceVariablePointerFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceVariablePointerFeatures[?]", #tbl, tbl)
end

function library.s.DebugMarkerObjectNameInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectNameInfoEXT(v)
	end

	return ffi.new("struct VkDebugMarkerObjectNameInfoEXT[?]", #tbl, tbl)
end

function library.s.DebugUtilsObjectNameInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugUtilsObjectNameInfoEXT(v)
	end

	return ffi.new("struct VkDebugUtilsObjectNameInfoEXT[?]", #tbl, tbl)
end

function library.s.FormatProperties(tbl, table_only)
	if type(tbl.linearTilingFeatures) == "table" then
		tbl.linearTilingFeatures = library.e.format_feature.make_enums(tbl.linearTilingFeatures)
	elseif type(tbl.linearTilingFeatures) == "string" then
		tbl.linearTilingFeatures = library.e.format_feature[tbl.linearTilingFeatures]
	end

	if type(tbl.optimalTilingFeatures) == "table" then
		tbl.optimalTilingFeatures = library.e.format_feature.make_enums(tbl.optimalTilingFeatures)
	elseif type(tbl.optimalTilingFeatures) == "string" then
		tbl.optimalTilingFeatures = library.e.format_feature[tbl.optimalTilingFeatures]
	end

	if type(tbl.bufferFeatures) == "table" then
		tbl.bufferFeatures = library.e.format_feature.make_enums(tbl.bufferFeatures)
	elseif type(tbl.bufferFeatures) == "string" then
		tbl.bufferFeatures = library.e.format_feature[tbl.bufferFeatures]
	end

	return table_only and tbl or ffi.new("struct VkFormatProperties", tbl)
end

function library.s.FormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties(v)
	end

	return ffi.new("struct VkFormatProperties[?]", #tbl, tbl)
end

function library.s.CopyDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CopyDescriptorSet(v)
	end

	return ffi.new("struct VkCopyDescriptorSet[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionInfo(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionInfo[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutSupportArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutSupport(v)
	end

	return ffi.new("struct VkDescriptorSetLayoutSupport[?]", #tbl, tbl)
end

function library.s.DescriptorSetVariableDescriptorCountAllocateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetVariableDescriptorCountAllocateInfoEXT(v)
	end

	return ffi.new("struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT[?]", #tbl, tbl)
end

function library.s.RectLayerKHR(tbl, table_only)
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset2D(tbl.offset, true)
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent2D(tbl.extent, true)
	end

	return table_only and tbl or ffi.new("struct VkRectLayerKHR", tbl)
end

function library.s.RectLayerKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RectLayerKHR(v)
	end

	return ffi.new("struct VkRectLayerKHR[?]", #tbl, tbl)
end

function library.s.ObjectTableNVXArray(tbl)
	return ffi.new("struct VkObjectTableNVX_T *[?]", #tbl, tbl)
end

function library.s.HdrMetadataEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.HdrMetadataEXT(v)
	end

	return ffi.new("struct VkHdrMetadataEXT[?]", #tbl, tbl)
end

function library.s.ShaderStatisticsInfoAMD(tbl, table_only)
	if type(tbl.shaderStageMask) == "table" then
		tbl.shaderStageMask = library.e.shader_stage.make_enums(tbl.shaderStageMask)
	elseif type(tbl.shaderStageMask) == "string" then
		tbl.shaderStageMask = library.e.shader_stage[tbl.shaderStageMask]
	end

	if type(tbl.resourceUsage) == "table" then
		tbl.resourceUsage = library.s.ShaderResourceUsageAMD(tbl.resourceUsage, true)
	end

	return table_only and tbl or ffi.new("struct VkShaderStatisticsInfoAMD", tbl)
end

function library.s.ShaderStatisticsInfoAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderStatisticsInfoAMD(v)
	end

	return ffi.new("struct VkShaderStatisticsInfoAMD[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceProperties(tbl, table_only)
	if type(tbl.deviceType) == "string" then
		tbl.deviceType = library.e.physical_device_type[tbl.deviceType]
	end

	if type(tbl.limits) == "table" then
		tbl.limits = library.s.PhysicalDeviceLimits(tbl.limits, true)
	end

	if type(tbl.sparseProperties) == "table" then
		tbl.sparseProperties = library.s.PhysicalDeviceSparseProperties(tbl.sparseProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties", tbl)
end

function library.s.PhysicalDevicePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceProperties[?]", #tbl, tbl)
end

function library.s.PipelineRasterizationConservativeStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationConservativeStateCreateInfoEXT(v)
	end

	return ffi.new("struct VkPipelineRasterizationConservativeStateCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.ObjectTableVertexBufferEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkObjectTableVertexBufferEntryNVX", tbl)
end

function library.s.ObjectTableVertexBufferEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableVertexBufferEntryNVX(v)
	end

	return ffi.new("struct VkObjectTableVertexBufferEntryNVX[?]", #tbl, tbl)
end

function library.s.PresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentInfoKHR(v)
	end

	return ffi.new("struct VkPresentInfoKHR[?]", #tbl, tbl)
end

function library.s.PipelineArray(tbl)
	return ffi.new("struct VkPipeline_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(v)
	end

	return ffi.new("struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX[?]", #tbl, tbl)
end

function library.s.GraphicsPipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.GraphicsPipelineCreateInfo(v)
	end

	return ffi.new("struct VkGraphicsPipelineCreateInfo[?]", #tbl, tbl)
end

function library.s.BufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCreateInfo(v)
	end

	return ffi.new("struct VkBufferCreateInfo[?]", #tbl, tbl)
end

function library.s.PresentTimesInfoGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentTimesInfoGOOGLE(v)
	end

	return ffi.new("struct VkPresentTimesInfoGOOGLE[?]", #tbl, tbl)
end

function library.s.PresentTimeGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPresentTimeGOOGLE", tbl)
end

function library.s.PresentTimeGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentTimeGOOGLE(v)
	end

	return ffi.new("struct VkPresentTimeGOOGLE[?]", #tbl, tbl)
end

function library.s.ImportSemaphoreFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportSemaphoreFdInfoKHR(v)
	end

	return ffi.new("struct VkImportSemaphoreFdInfoKHR[?]", #tbl, tbl)
end

function library.s.PastPresentationTimingGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPastPresentationTimingGOOGLE", tbl)
end

function library.s.PastPresentationTimingGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PastPresentationTimingGOOGLE(v)
	end

	return ffi.new("struct VkPastPresentationTimingGOOGLE[?]", #tbl, tbl)
end

function library.s.RefreshCycleDurationGOOGLE(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkRefreshCycleDurationGOOGLE", tbl)
end

function library.s.RefreshCycleDurationGOOGLEArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RefreshCycleDurationGOOGLE(v)
	end

	return ffi.new("struct VkRefreshCycleDurationGOOGLE[?]", #tbl, tbl)
end

function library.s.DescriptorPoolSize(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.descriptor_type[tbl.type]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorPoolSize", tbl)
end

function library.s.DescriptorPoolSizeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolSize(v)
	end

	return ffi.new("struct VkDescriptorPoolSize[?]", #tbl, tbl)
end

function library.s.SubpassDependency(tbl, table_only)
	if type(tbl.srcStageMask) == "table" then
		tbl.srcStageMask = library.e.pipeline_stage.make_enums(tbl.srcStageMask)
	elseif type(tbl.srcStageMask) == "string" then
		tbl.srcStageMask = library.e.pipeline_stage[tbl.srcStageMask]
	end

	if type(tbl.dstStageMask) == "table" then
		tbl.dstStageMask = library.e.pipeline_stage.make_enums(tbl.dstStageMask)
	elseif type(tbl.dstStageMask) == "string" then
		tbl.dstStageMask = library.e.pipeline_stage[tbl.dstStageMask]
	end

	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end

	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end

	if type(tbl.dependencyFlags) == "table" then
		tbl.dependencyFlags = library.e.dependency.make_enums(tbl.dependencyFlags)
	elseif type(tbl.dependencyFlags) == "string" then
		tbl.dependencyFlags = library.e.dependency[tbl.dependencyFlags]
	end

	return table_only and tbl or ffi.new("struct VkSubpassDependency", tbl)
end

function library.s.SubpassDependencyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDependency(v)
	end

	return ffi.new("struct VkSubpassDependency[?]", #tbl, tbl)
end

function library.s.QueueFamilyProperties2(tbl, table_only)
	if type(tbl.queueFamilyProperties) == "table" then
		tbl.queueFamilyProperties = library.s.QueueFamilyProperties(tbl.queueFamilyProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties2", tbl)
end

function library.s.QueueFamilyProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties2(v)
	end

	return ffi.new("struct VkQueueFamilyProperties2[?]", #tbl, tbl)
end

function library.s.ImageCopy(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end

	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end

	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end

	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end

	return table_only and tbl or ffi.new("struct VkImageCopy", tbl)
end

function library.s.ImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCopy(v)
	end

	return ffi.new("struct VkImageCopy[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutArray(tbl)
	return ffi.new("struct VkDescriptorSetLayout_T *[?]", #tbl, tbl)
end

function library.s.VertexInputAttributeDescription(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	return table_only and tbl or ffi.new("struct VkVertexInputAttributeDescription", tbl)
end

function library.s.VertexInputAttributeDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputAttributeDescription(v)
	end

	return ffi.new("struct VkVertexInputAttributeDescription[?]", #tbl, tbl)
end

function library.s.ImportMemoryFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportMemoryFdInfoKHR(v)
	end

	return ffi.new("struct VkImportMemoryFdInfoKHR[?]", #tbl, tbl)
end

function library.s.DisplayEventInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayEventInfoEXT(v)
	end

	return ffi.new("struct VkDisplayEventInfoEXT[?]", #tbl, tbl)
end

function library.s.DeviceEventInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceEventInfoEXT(v)
	end

	return ffi.new("struct VkDeviceEventInfoEXT[?]", #tbl, tbl)
end

function library.s.FormatProperties2(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.FormatProperties(tbl.formatProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkFormatProperties2", tbl)
end

function library.s.FormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties2(v)
	end

	return ffi.new("struct VkFormatProperties2[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionCreateInfo(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionCreateInfo[?]", #tbl, tbl)
end

function library.s.ExternalSemaphorePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalSemaphoreProperties(v)
	end

	return ffi.new("struct VkExternalSemaphoreProperties[?]", #tbl, tbl)
end

function library.s.CommandBufferBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferBeginInfo(v)
	end

	return ffi.new("struct VkCommandBufferBeginInfo[?]", #tbl, tbl)
end

function library.s.DisplayModeCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeCreateInfoKHR(v)
	end

	return ffi.new("struct VkDisplayModeCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.DeviceGroupSubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupSubmitInfo(v)
	end

	return ffi.new("struct VkDeviceGroupSubmitInfo[?]", #tbl, tbl)
end

function library.s.SwapchainCounterCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SwapchainCounterCreateInfoEXT(v)
	end

	return ffi.new("struct VkSwapchainCounterCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.PipelineViewportWScalingStateCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportWScalingStateCreateInfoNV(v)
	end

	return ffi.new("struct VkPipelineViewportWScalingStateCreateInfoNV[?]", #tbl, tbl)
end

function library.s.ViewportWScalingNV(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkViewportWScalingNV", tbl)
end

function library.s.ViewportWScalingNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ViewportWScalingNV(v)
	end

	return ffi.new("struct VkViewportWScalingNV[?]", #tbl, tbl)
end

function library.s.Offset3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset3D", tbl)
end

function library.s.Offset3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset3D(v)
	end

	return ffi.new("struct VkOffset3D[?]", #tbl, tbl)
end

function library.s.DisplaySurfaceCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplaySurfaceCreateInfoKHR(v)
	end

	return ffi.new("struct VkDisplaySurfaceCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.DeviceGroupCommandBufferBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupCommandBufferBeginInfo(v)
	end

	return ffi.new("struct VkDeviceGroupCommandBufferBeginInfo[?]", #tbl, tbl)
end

function library.s.ViewportSwizzleNV(tbl, table_only)
	if type(tbl.x) == "string" then
		tbl.x = library.e.viewport_coordinate_swizzle[tbl.x]
	end

	if type(tbl.y) == "string" then
		tbl.y = library.e.viewport_coordinate_swizzle[tbl.y]
	end

	if type(tbl.z) == "string" then
		tbl.z = library.e.viewport_coordinate_swizzle[tbl.z]
	end

	if type(tbl.w) == "string" then
		tbl.w = library.e.viewport_coordinate_swizzle[tbl.w]
	end

	return table_only and tbl or ffi.new("struct VkViewportSwizzleNV", tbl)
end

function library.s.ViewportSwizzleNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ViewportSwizzleNV(v)
	end

	return ffi.new("struct VkViewportSwizzleNV[?]", #tbl, tbl)
end

function library.s.ImageMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageMemoryRequirementsInfo2", tbl)
end

function library.s.ImageMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkImageMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.ExportFenceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportFenceCreateInfo(v)
	end

	return ffi.new("struct VkExportFenceCreateInfo[?]", #tbl, tbl)
end

function library.s.QueueArray(tbl)
	return ffi.new("struct VkQueue_T *[?]", #tbl, tbl)
end

function library.s.SparseImageFormatProperties2(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.SparseImageFormatProperties(tbl.properties, true)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties2", tbl)
end

function library.s.SparseImageFormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties2(v)
	end

	return ffi.new("struct VkSparseImageFormatProperties2[?]", #tbl, tbl)
end

function library.s.PhysicalDevice16BitStorageFeatures(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDevice16BitStorageFeatures", tbl)
end

function library.s.PhysicalDevice16BitStorageFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevice16BitStorageFeatures(v)
	end

	return ffi.new("struct VkPhysicalDevice16BitStorageFeatures[?]", #tbl, tbl)
end

function library.s.SparseImageMemoryBind(tbl, table_only)
	if type(tbl.subresource) == "table" then
		tbl.subresource = library.s.ImageSubresource(tbl.subresource, true)
	end

	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset3D(tbl.offset, true)
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBind", tbl)
end

function library.s.SparseImageMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBind(v)
	end

	return ffi.new("struct VkSparseImageMemoryBind[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMemoryProperties2(tbl, table_only)
	if type(tbl.memoryProperties) == "table" then
		tbl.memoryProperties = library.s.PhysicalDeviceMemoryProperties(tbl.memoryProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties2", tbl)
end

function library.s.PhysicalDeviceMemoryProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties2(v)
	end

	return ffi.new("struct VkPhysicalDeviceMemoryProperties2[?]", #tbl, tbl)
end

function library.s.ObjectTablePushConstantEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end

	return table_only and tbl or ffi.new("struct VkObjectTablePushConstantEntryNVX", tbl)
end

function library.s.ObjectTablePushConstantEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTablePushConstantEntryNVX(v)
	end

	return ffi.new("struct VkObjectTablePushConstantEntryNVX[?]", #tbl, tbl)
end

function library.s.ObjectTableIndexBufferEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	if type(tbl.indexType) == "string" then
		tbl.indexType = library.e.index_type[tbl.indexType]
	end

	return table_only and tbl or ffi.new("struct VkObjectTableIndexBufferEntryNVX", tbl)
end

function library.s.ObjectTableIndexBufferEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableIndexBufferEntryNVX(v)
	end

	return ffi.new("struct VkObjectTableIndexBufferEntryNVX[?]", #tbl, tbl)
end

function library.s.DeviceGeneratedCommandsLimitsNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGeneratedCommandsLimitsNVX(v)
	end

	return ffi.new("struct VkDeviceGeneratedCommandsLimitsNVX[?]", #tbl, tbl)
end

function library.s.ObjectTableDescriptorSetEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkObjectTableDescriptorSetEntryNVX", tbl)
end

function library.s.ObjectTableDescriptorSetEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTableDescriptorSetEntryNVX(v)
	end

	return ffi.new("struct VkObjectTableDescriptorSetEntryNVX[?]", #tbl, tbl)
end

function library.s.ObjectTablePipelineEntryNVX(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.object_entry_type[tbl.type]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.object_entry_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.object_entry_usage[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkObjectTablePipelineEntryNVX", tbl)
end

function library.s.ObjectTablePipelineEntryNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ObjectTablePipelineEntryNVX(v)
	end

	return ffi.new("struct VkObjectTablePipelineEntryNVX[?]", #tbl, tbl)
end

function library.s.IndirectCommandsTokenNVX(tbl, table_only)
	if type(tbl.tokenType) == "string" then
		tbl.tokenType = library.e.indirect_commands_token_type[tbl.tokenType]
	end

	return table_only and tbl or ffi.new("struct VkIndirectCommandsTokenNVX", tbl)
end

function library.s.IndirectCommandsTokenNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.IndirectCommandsTokenNVX(v)
	end

	return ffi.new("struct VkIndirectCommandsTokenNVX[?]", #tbl, tbl)
end

function library.s.InstanceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.InstanceCreateInfo(v)
	end

	return ffi.new("struct VkInstanceCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineDynamicStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDynamicStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineDynamicStateCreateInfo[?]", #tbl, tbl)
end

function library.s.DeviceGeneratedCommandsFeaturesNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGeneratedCommandsFeaturesNVX(v)
	end

	return ffi.new("struct VkDeviceGeneratedCommandsFeaturesNVX[?]", #tbl, tbl)
end

function library.s.ImageBlit(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end

	if type(tbl.srcOffsets) == "table" then
		tbl.srcOffsets = library.s.Offset3D(tbl.srcOffsets, true)
	end

	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end

	if type(tbl.dstOffsets) == "table" then
		tbl.dstOffsets = library.s.Offset3D(tbl.dstOffsets, true)
	end

	return table_only and tbl or ffi.new("struct VkImageBlit", tbl)
end

function library.s.ImageBlitArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageBlit(v)
	end

	return ffi.new("struct VkImageBlit[?]", #tbl, tbl)
end

function library.s.CommandPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandPoolCreateInfo(v)
	end

	return ffi.new("struct VkCommandPoolCreateInfo[?]", #tbl, tbl)
end

function library.s.ImageMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryBarrier(v)
	end

	return ffi.new("struct VkImageMemoryBarrier[?]", #tbl, tbl)
end

function library.s.ImageFormatProperties2(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkImageFormatProperties2", tbl)
end

function library.s.ImageFormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties2(v)
	end

	return ffi.new("struct VkImageFormatProperties2[?]", #tbl, tbl)
end

function library.s.DisplayModePropertiesKHR(tbl, table_only)
	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplayModePropertiesKHR", tbl)
end

function library.s.DisplayModePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModePropertiesKHR(v)
	end

	return ffi.new("struct VkDisplayModePropertiesKHR[?]", #tbl, tbl)
end

function library.s.DebugUtilsLabelEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugUtilsLabelEXT(v)
	end

	return ffi.new("struct VkDebugUtilsLabelEXT[?]", #tbl, tbl)
end

function library.s.DebugUtilsMessengerEXTArray(tbl)
	return ffi.new("struct VkDebugUtilsMessengerEXT_T *[?]", #tbl, tbl)
end

function library.s.ValidationFlagsEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ValidationFlagsEXT(v)
	end

	return ffi.new("struct VkValidationFlagsEXT[?]", #tbl, tbl)
end

function library.s.FenceArray(tbl)
	return ffi.new("struct VkFence_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT[?]", #tbl, tbl)
end

function library.s.ExportMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfoNV(v)
	end

	return ffi.new("struct VkExportMemoryAllocateInfoNV[?]", #tbl, tbl)
end

function library.s.ExternalMemoryImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfoNV(v)
	end

	return ffi.new("struct VkExternalMemoryImageCreateInfoNV[?]", #tbl, tbl)
end

function library.s.PhysicalDevicePushDescriptorPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevicePushDescriptorPropertiesKHR(v)
	end

	return ffi.new("struct VkPhysicalDevicePushDescriptorPropertiesKHR[?]", #tbl, tbl)
end

function library.s.EventArray(tbl)
	return ffi.new("struct VkEvent_T *[?]", #tbl, tbl)
end

function library.s.ExternalBufferPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalBufferProperties(v)
	end

	return ffi.new("struct VkExternalBufferProperties[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionImageFormatProperties(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionImageFormatProperties[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSampleLocationsPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSampleLocationsPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceSampleLocationsPropertiesEXT[?]", #tbl, tbl)
end

function library.s.TextureLODGatherFormatPropertiesAMD(tbl, table_only)
	return table_only and
		tbl or
		ffi.new("struct VkTextureLODGatherFormatPropertiesAMD", tbl)
end

function library.s.TextureLODGatherFormatPropertiesAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.TextureLODGatherFormatPropertiesAMD(v)
	end

	return ffi.new("struct VkTextureLODGatherFormatPropertiesAMD[?]", #tbl, tbl)
end

function library.s.DedicatedAllocationBufferCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationBufferCreateInfoNV(v)
	end

	return ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV[?]", #tbl, tbl)
end

function library.s.ExternalMemoryBufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryBufferCreateInfo(v)
	end

	return ffi.new("struct VkExternalMemoryBufferCreateInfo[?]", #tbl, tbl)
end

function library.s.ImageSwapchainCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSwapchainCreateInfoKHR(v)
	end

	return ffi.new("struct VkImageSwapchainCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.ImageViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageViewCreateInfo(v)
	end

	return ffi.new("struct VkImageViewCreateInfo[?]", #tbl, tbl)
end

function library.s.Viewport(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkViewport", tbl)
end

function library.s.ViewportArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Viewport(v)
	end

	return ffi.new("struct VkViewport[?]", #tbl, tbl)
end

function library.s.PresentRegionsKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentRegionsKHR(v)
	end

	return ffi.new("struct VkPresentRegionsKHR[?]", #tbl, tbl)
end

function library.s.PipelineTessellationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineTessellationStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineTessellationStateCreateInfo[?]", #tbl, tbl)
end

function library.s.DebugReportCallbackCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugReportCallbackCreateInfoEXT(v)
	end

	return ffi.new("struct VkDebugReportCallbackCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSamplerYcbcrConversionFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSamplerYcbcrConversionFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceSamplerYcbcrConversionFeatures[?]", #tbl, tbl)
end

function library.s.InstanceArray(tbl)
	return ffi.new("struct VkInstance_T *[?]", #tbl, tbl)
end

function library.s.ImageSparseMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageSparseMemoryRequirementsInfo2", tbl)
end

function library.s.ImageSparseMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSparseMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkImageSparseMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.BindImageMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemoryInfo(v)
	end

	return ffi.new("struct VkBindImageMemoryInfo[?]", #tbl, tbl)
end

function library.s.BindBufferMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindBufferMemoryInfo(v)
	end

	return ffi.new("struct VkBindBufferMemoryInfo[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionImageFormatProperties(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionImageFormatProperties[?]", #tbl, tbl)
end

function library.s.ImagePlaneMemoryRequirementsInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImagePlaneMemoryRequirementsInfo(v)
	end

	return ffi.new("struct VkImagePlaneMemoryRequirementsInfo[?]", #tbl, tbl)
end

function library.s.ImageFormatListCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatListCreateInfoKHR(v)
	end

	return ffi.new("struct VkImageFormatListCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.DisplayPlanePropertiesKHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDisplayPlanePropertiesKHR", tbl)
end

function library.s.DisplayPlanePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlanePropertiesKHR(v)
	end

	return ffi.new("struct VkDisplayPlanePropertiesKHR[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceProperties2(tbl, table_only)
	if type(tbl.properties) == "table" then
		tbl.properties = library.s.PhysicalDeviceProperties(tbl.properties, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties2", tbl)
end

function library.s.PhysicalDeviceProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties2(v)
	end

	return ffi.new("struct VkPhysicalDeviceProperties2[?]", #tbl, tbl)
end

function library.s.SparseImageMemoryRequirements2(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.SparseImageMemoryRequirements(tbl.memoryRequirements, true)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements2", tbl)
end

function library.s.SparseImageMemoryRequirements2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements2(v)
	end

	return ffi.new("struct VkSparseImageMemoryRequirements2[?]", #tbl, tbl)
end

function library.s.MemoryRequirements2(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.MemoryRequirements(tbl.memoryRequirements, true)
	end

	return table_only and tbl or ffi.new("struct VkMemoryRequirements2", tbl)
end

function library.s.MemoryRequirements2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements2(v)
	end

	return ffi.new("struct VkMemoryRequirements2[?]", #tbl, tbl)
end

function library.s.ImageSparseMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkImageSparseMemoryRequirementsInfo2", tbl)
end

function library.s.ImageSparseMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSparseMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkImageSparseMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.BufferMemoryRequirementsInfo2(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferMemoryRequirementsInfo2", tbl)
end

function library.s.BufferMemoryRequirementsInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryRequirementsInfo2(v)
	end

	return ffi.new("struct VkBufferMemoryRequirementsInfo2[?]", #tbl, tbl)
end

function library.s.MemoryDedicatedAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedAllocateInfo(v)
	end

	return ffi.new("struct VkMemoryDedicatedAllocateInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDevicePointClippingPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevicePointClippingProperties(v)
	end

	return ffi.new("struct VkPhysicalDevicePointClippingProperties[?]", #tbl, tbl)
end

function library.s.SurfaceKHRArray(tbl)
	return ffi.new("struct VkSurfaceKHR_T *[?]", #tbl, tbl)
end

function library.s.ImageFormatProperties2(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkImageFormatProperties2", tbl)
end

function library.s.ImageFormatProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties2(v)
	end

	return ffi.new("struct VkImageFormatProperties2[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutBinding(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end

	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutBinding", tbl)
end

function library.s.DescriptorSetLayoutBindingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutBinding(v)
	end

	return ffi.new("struct VkDescriptorSetLayoutBinding[?]", #tbl, tbl)
end

function library.s.DeviceMemoryArray(tbl)
	return ffi.new("struct VkDeviceMemory_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceIDProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceIDProperties", tbl)
end

function library.s.PhysicalDeviceIDPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceIDProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceIDProperties[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateEntry(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorUpdateTemplateEntry", tbl)
end

function library.s.DescriptorUpdateTemplateEntryArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateEntry(v)
	end

	return ffi.new("struct VkDescriptorUpdateTemplateEntry[?]", #tbl, tbl)
end

function library.s.WriteDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.WriteDescriptorSet(v)
	end

	return ffi.new("struct VkWriteDescriptorSet[?]", #tbl, tbl)
end

function library.s.SurfaceFormat2KHR(tbl, table_only)
	if type(tbl.surfaceFormat) == "table" then
		tbl.surfaceFormat = library.s.SurfaceFormatKHR(tbl.surfaceFormat, true)
	end

	return table_only and tbl or ffi.new("struct VkSurfaceFormat2KHR", tbl)
end

function library.s.SurfaceFormat2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceFormat2KHR(v)
	end

	return ffi.new("struct VkSurfaceFormat2KHR[?]", #tbl, tbl)
end

function library.s.SurfaceCapabilities2KHR(tbl, table_only)
	if type(tbl.surfaceCapabilities) == "table" then
		tbl.surfaceCapabilities = library.s.SurfaceCapabilitiesKHR(tbl.surfaceCapabilities, true)
	end

	return table_only and tbl or ffi.new("struct VkSurfaceCapabilities2KHR", tbl)
end

function library.s.SurfaceCapabilities2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilities2KHR(v)
	end

	return ffi.new("struct VkSurfaceCapabilities2KHR[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSurfaceInfo2KHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSurfaceInfo2KHR", tbl)
end

function library.s.PhysicalDeviceSurfaceInfo2KHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSurfaceInfo2KHR(v)
	end

	return ffi.new("struct VkPhysicalDeviceSurfaceInfo2KHR[?]", #tbl, tbl)
end

function library.s.ImageViewUsageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageViewUsageCreateInfo(v)
	end

	return ffi.new("struct VkImageViewUsageCreateInfo[?]", #tbl, tbl)
end

function library.s.InputAttachmentAspectReference(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	return table_only and tbl or ffi.new("struct VkInputAttachmentAspectReference", tbl)
end

function library.s.InputAttachmentAspectReferenceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.InputAttachmentAspectReference(v)
	end

	return ffi.new("struct VkInputAttachmentAspectReference[?]", #tbl, tbl)
end

function library.s.RenderPassInputAttachmentAspectCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassInputAttachmentAspectCreateInfo(v)
	end

	return ffi.new("struct VkRenderPassInputAttachmentAspectCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineDiscardRectangleStateCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDiscardRectangleStateCreateInfoEXT(v)
	end

	return ffi.new("struct VkPipelineDiscardRectangleStateCreateInfoEXT[?]", #tbl, tbl)
end

function library.s.ImportFenceFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImportFenceFdInfoKHR(v)
	end

	return ffi.new("struct VkImportFenceFdInfoKHR[?]", #tbl, tbl)
end

function library.s.ExportFenceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportFenceCreateInfo(v)
	end

	return ffi.new("struct VkExportFenceCreateInfo[?]", #tbl, tbl)
end

function library.s.QueryPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueryPoolCreateInfo(v)
	end

	return ffi.new("struct VkQueryPoolCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineShaderStageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineShaderStageCreateInfo(v)
	end

	return ffi.new("struct VkPipelineShaderStageCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineVertexInputStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineVertexInputStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineVertexInputStateCreateInfo[?]", #tbl, tbl)
end

function library.s.Rect2D(tbl, table_only)
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset2D(tbl.offset, true)
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent2D(tbl.extent, true)
	end

	return table_only and tbl or ffi.new("struct VkRect2D", tbl)
end

function library.s.Rect2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Rect2D(v)
	end

	return ffi.new("struct VkRect2D[?]", #tbl, tbl)
end

function library.s.SparseImageOpaqueMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then tbl.bindCount = #tbl.pBinds end

		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageOpaqueMemoryBindInfo", tbl)
end

function library.s.SparseImageOpaqueMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageOpaqueMemoryBindInfo(v)
	end

	return ffi.new("struct VkSparseImageOpaqueMemoryBindInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalFenceInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalFenceInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalFenceInfo[?]", #tbl, tbl)
end

function library.s.BufferMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryBarrier(v)
	end

	return ffi.new("struct VkBufferMemoryBarrier[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateArray(tbl)
	return ffi.new("struct VkDescriptorUpdateTemplate_T *[?]", #tbl, tbl)
end

function library.s.BindBufferMemoryDeviceGroupInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindBufferMemoryDeviceGroupInfo(v)
	end

	return ffi.new("struct VkBindBufferMemoryDeviceGroupInfo[?]", #tbl, tbl)
end

function library.s.SharedPresentSurfaceCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SharedPresentSurfaceCapabilitiesKHR(v)
	end

	return ffi.new("struct VkSharedPresentSurfaceCapabilitiesKHR[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateCreateInfo(v)
	end

	return ffi.new("struct VkDescriptorUpdateTemplateCreateInfo[?]", #tbl, tbl)
end

function library.s.MemoryDedicatedAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedAllocateInfo(v)
	end

	return ffi.new("struct VkMemoryDedicatedAllocateInfo[?]", #tbl, tbl)
end

function library.s.ExternalMemoryBufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryBufferCreateInfo(v)
	end

	return ffi.new("struct VkExternalMemoryBufferCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineLayoutArray(tbl)
	return ffi.new("struct VkPipelineLayout_T *[?]", #tbl, tbl)
end

function library.s.MemoryAllocateFlagsInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateFlagsInfo(v)
	end

	return ffi.new("struct VkMemoryAllocateFlagsInfo[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateArray(tbl)
	return ffi.new("struct VkDescriptorUpdateTemplate_T *[?]", #tbl, tbl)
end

function library.s.ImageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCreateInfo(v)
	end

	return ffi.new("struct VkImageCreateInfo[?]", #tbl, tbl)
end

function library.s.SparseMemoryBind(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkSparseMemoryBind", tbl)
end

function library.s.SparseMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseMemoryBind(v)
	end

	return ffi.new("struct VkSparseMemoryBind[?]", #tbl, tbl)
end

function library.s.AllocationCallbacks(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkAllocationCallbacks", tbl)
end

function library.s.AllocationCallbacksArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AllocationCallbacks(v)
	end

	return ffi.new("struct VkAllocationCallbacks[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutCreateInfo(v)
	end

	return ffi.new("struct VkDescriptorSetLayoutCreateInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSparseProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSparseProperties", tbl)
end

function library.s.PhysicalDeviceSparsePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceSparseProperties[?]", #tbl, tbl)
end

function library.s.DebugUtilsMessengerCallbackDataEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugUtilsMessengerCallbackDataEXT(v)
	end

	return ffi.new("struct VkDebugUtilsMessengerCallbackDataEXT[?]", #tbl, tbl)
end

function library.s.PipelineColorBlendAttachmentState(tbl, table_only)
	tbl.blendEnable = tbl.blendEnable and 1 or 0

	if type(tbl.srcColorBlendFactor) == "string" then
		tbl.srcColorBlendFactor = library.e.blend_factor[tbl.srcColorBlendFactor]
	end

	if type(tbl.dstColorBlendFactor) == "string" then
		tbl.dstColorBlendFactor = library.e.blend_factor[tbl.dstColorBlendFactor]
	end

	if type(tbl.colorBlendOp) == "string" then
		tbl.colorBlendOp = library.e.blend_op[tbl.colorBlendOp]
	end

	if type(tbl.srcAlphaBlendFactor) == "string" then
		tbl.srcAlphaBlendFactor = library.e.blend_factor[tbl.srcAlphaBlendFactor]
	end

	if type(tbl.dstAlphaBlendFactor) == "string" then
		tbl.dstAlphaBlendFactor = library.e.blend_factor[tbl.dstAlphaBlendFactor]
	end

	if type(tbl.alphaBlendOp) == "string" then
		tbl.alphaBlendOp = library.e.blend_op[tbl.alphaBlendOp]
	end

	if type(tbl.colorWriteMask) == "table" then
		tbl.colorWriteMask = library.e.color_component.make_enums(tbl.colorWriteMask)
	elseif type(tbl.colorWriteMask) == "string" then
		tbl.colorWriteMask = library.e.color_component[tbl.colorWriteMask]
	end

	return table_only and tbl or ffi.new("struct VkPipelineColorBlendAttachmentState", tbl)
end

function library.s.PipelineColorBlendAttachmentStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendAttachmentState(v)
	end

	return ffi.new("struct VkPipelineColorBlendAttachmentState[?]", #tbl, tbl)
end

function library.s.ExternalSemaphorePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalSemaphoreProperties(v)
	end

	return ffi.new("struct VkExternalSemaphoreProperties[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalSemaphoreInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalSemaphoreInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalSemaphoreInfo[?]", #tbl, tbl)
end

function library.s.Extent2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent2D", tbl)
end

function library.s.Extent2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent2D(v)
	end

	return ffi.new("struct VkExtent2D[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceImageFormatInfo2(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end

	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceImageFormatInfo2", tbl)
end

function library.s.PhysicalDeviceImageFormatInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceImageFormatInfo2(v)
	end

	return ffi.new("struct VkPhysicalDeviceImageFormatInfo2[?]", #tbl, tbl)
end

function library.s.MemoryRequirements2(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.MemoryRequirements(tbl.memoryRequirements, true)
	end

	return table_only and tbl or ffi.new("struct VkMemoryRequirements2", tbl)
end

function library.s.MemoryRequirements2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements2(v)
	end

	return ffi.new("struct VkMemoryRequirements2[?]", #tbl, tbl)
end

function library.s.DeviceGroupCommandBufferBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupCommandBufferBeginInfo(v)
	end

	return ffi.new("struct VkDeviceGroupCommandBufferBeginInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceIDProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceIDProperties", tbl)
end

function library.s.PhysicalDeviceIDPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceIDProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceIDProperties[?]", #tbl, tbl)
end

function library.s.MemoryFdPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryFdPropertiesKHR(v)
	end

	return ffi.new("struct VkMemoryFdPropertiesKHR[?]", #tbl, tbl)
end

function library.s.ExportMemoryAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfo(v)
	end

	return ffi.new("struct VkExportMemoryAllocateInfo[?]", #tbl, tbl)
end

function library.s.BindImageMemoryDeviceGroupInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemoryDeviceGroupInfo(v)
	end

	return ffi.new("struct VkBindImageMemoryDeviceGroupInfo[?]", #tbl, tbl)
end

function library.s.ImageFormatProperties(tbl, table_only)
	if type(tbl.maxExtent) == "table" then
		tbl.maxExtent = library.s.Extent3D(tbl.maxExtent, true)
	end

	if type(tbl.sampleCounts) == "table" then
		tbl.sampleCounts = library.e.sample_count.make_enums(tbl.sampleCounts)
	elseif type(tbl.sampleCounts) == "string" then
		tbl.sampleCounts = library.e.sample_count[tbl.sampleCounts]
	end

	return table_only and tbl or ffi.new("struct VkImageFormatProperties", tbl)
end

function library.s.ImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties(v)
	end

	return ffi.new("struct VkImageFormatProperties[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMaintenance3Properties(tbl, table_only)
	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceMaintenance3Properties", tbl)
end

function library.s.PhysicalDeviceMaintenance3PropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMaintenance3Properties(v)
	end

	return ffi.new("struct VkPhysicalDeviceMaintenance3Properties[?]", #tbl, tbl)
end

function library.s.ExternalBufferPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalBufferProperties(v)
	end

	return ffi.new("struct VkExternalBufferProperties[?]", #tbl, tbl)
end

function library.s.ExternalImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatProperties(v)
	end

	return ffi.new("struct VkExternalImageFormatProperties[?]", #tbl, tbl)
end

function library.s.SpecializationInfo(tbl, table_only)
	if type(tbl.pMapEntries) == "table" then
		if not tbl.mapEntryCount then tbl.mapEntryCount = #tbl.pMapEntries end

		tbl.pMapEntries = library.s.SpecializationMapEntryArray(tbl.pMapEntries, false)
	end

	return table_only and tbl or ffi.new("struct VkSpecializationInfo", tbl)
end

function library.s.SpecializationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationInfo(v)
	end

	return ffi.new("struct VkSpecializationInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceFeatures2(tbl, table_only)
	if type(tbl.features) == "table" then
		tbl.features = library.s.PhysicalDeviceFeatures(tbl.features, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures2", tbl)
end

function library.s.PhysicalDeviceFeatures2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures2(v)
	end

	return ffi.new("struct VkPhysicalDeviceFeatures2[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalImageFormatInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalImageFormatInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalImageFormatInfo[?]", #tbl, tbl)
end

function library.s.FramebufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FramebufferCreateInfo(v)
	end

	return ffi.new("struct VkFramebufferCreateInfo[?]", #tbl, tbl)
end

function library.s.ExternalMemoryProperties(tbl, table_only)
	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature[tbl.externalMemoryFeatures]
	end

	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type[tbl.exportFromImportedHandleTypes]
	end

	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type[tbl.compatibleHandleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalMemoryProperties", tbl)
end

function library.s.ExternalMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryProperties(v)
	end

	return ffi.new("struct VkExternalMemoryProperties[?]", #tbl, tbl)
end

function library.s.DrawIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndirectCommand", tbl)
end

function library.s.DrawIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndirectCommand(v)
	end

	return ffi.new("struct VkDrawIndirectCommand[?]", #tbl, tbl)
end

function library.s.DeviceGroupDeviceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupDeviceCreateInfo(v)
	end

	return ffi.new("struct VkDeviceGroupDeviceCreateInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceGroupPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceGroupProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceGroupProperties[?]", #tbl, tbl)
end

function library.s.SparseImageMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then tbl.bindCount = #tbl.pBinds end

		tbl.pBinds = library.s.SparseImageMemoryBindArray(tbl.pBinds, false)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBindInfo", tbl)
end

function library.s.SparseImageMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBindInfo(v)
	end

	return ffi.new("struct VkSparseImageMemoryBindInfo[?]", #tbl, tbl)
end

function library.s.SamplerArray(tbl)
	return ffi.new("struct VkSampler_T *[?]", #tbl, tbl)
end

function library.s.DebugMarkerMarkerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerMarkerInfoEXT(v)
	end

	return ffi.new("struct VkDebugMarkerMarkerInfoEXT[?]", #tbl, tbl)
end

function library.s.ImageResolve(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end

	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end

	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end

	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end

	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end

	return table_only and tbl or ffi.new("struct VkImageResolve", tbl)
end

function library.s.ImageResolveArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageResolve(v)
	end

	return ffi.new("struct VkImageResolve[?]", #tbl, tbl)
end

function library.s.BindImageMemoryDeviceGroupInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemoryDeviceGroupInfo(v)
	end

	return ffi.new("struct VkBindImageMemoryDeviceGroupInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceProtectedMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProtectedMemoryProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceProtectedMemoryProperties[?]", #tbl, tbl)
end

function library.s.BindBufferMemoryDeviceGroupInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindBufferMemoryDeviceGroupInfo(v)
	end

	return ffi.new("struct VkBindBufferMemoryDeviceGroupInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupBindSparseInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupBindSparseInfo(v)
	end

	return ffi.new("struct VkDeviceGroupBindSparseInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupRenderPassBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupRenderPassBeginInfo(v)
	end

	return ffi.new("struct VkDeviceGroupRenderPassBeginInfo[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionInfo(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionInfo[?]", #tbl, tbl)
end

function library.s.DescriptorSetAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetAllocateInfo(v)
	end

	return ffi.new("struct VkDescriptorSetAllocateInfo[?]", #tbl, tbl)
end

function library.s.PipelineRasterizationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineRasterizationStateCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineCacheCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCacheCreateInfo(v)
	end

	return ffi.new("struct VkPipelineCacheCreateInfo[?]", #tbl, tbl)
end

function library.s.CmdReserveSpaceForCommandsInfoNVXArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CmdReserveSpaceForCommandsInfoNVX(v)
	end

	return ffi.new("struct VkCmdReserveSpaceForCommandsInfoNVX[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSparseImageFormatInfo2(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.type) == "string" then
		tbl.type = library.e.image_type[tbl.type]
	end

	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end

	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end

	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end

	return table_only and
		tbl or
		ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2", tbl)
end

function library.s.PhysicalDeviceSparseImageFormatInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseImageFormatInfo2(v)
	end

	return ffi.new("struct VkPhysicalDeviceSparseImageFormatInfo2[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMemoryProperties2(tbl, table_only)
	if type(tbl.memoryProperties) == "table" then
		tbl.memoryProperties = library.s.PhysicalDeviceMemoryProperties(tbl.memoryProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties2", tbl)
end

function library.s.PhysicalDeviceMemoryProperties2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties2(v)
	end

	return ffi.new("struct VkPhysicalDeviceMemoryProperties2[?]", #tbl, tbl)
end

function library.s.SubpassSampleLocationsEXT(tbl, table_only)
	if type(tbl.sampleLocationsInfo) == "table" then
		tbl.sampleLocationsInfo = library.s.SampleLocationsInfoEXT(tbl.sampleLocationsInfo, true)
	end

	return table_only and tbl or ffi.new("struct VkSubpassSampleLocationsEXT", tbl)
end

function library.s.SubpassSampleLocationsEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassSampleLocationsEXT(v)
	end

	return ffi.new("struct VkSubpassSampleLocationsEXT[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceFeatures2(tbl, table_only)
	if type(tbl.features) == "table" then
		tbl.features = library.s.PhysicalDeviceFeatures(tbl.features, true)
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures2", tbl)
end

function library.s.PhysicalDeviceFeatures2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures2(v)
	end

	return ffi.new("struct VkPhysicalDeviceFeatures2[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceMultiviewPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMultiviewProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceMultiviewProperties[?]", #tbl, tbl)
end

function library.s.RenderPassMultiviewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassMultiviewCreateInfo(v)
	end

	return ffi.new("struct VkRenderPassMultiviewCreateInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupBindSparseInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupBindSparseInfo(v)
	end

	return ffi.new("struct VkDeviceGroupBindSparseInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalFenceInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalFenceInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalFenceInfo[?]", #tbl, tbl)
end

function library.s.DisplayPresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPresentInfoKHR(v)
	end

	return ffi.new("struct VkDisplayPresentInfoKHR[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateEntry(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorUpdateTemplateEntry", tbl)
end

function library.s.DescriptorUpdateTemplateEntryArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateEntry(v)
	end

	return ffi.new("struct VkDescriptorUpdateTemplateEntry[?]", #tbl, tbl)
end

function library.s.DisplayPlaneCapabilitiesKHR(tbl, table_only)
	if type(tbl.supportedAlpha) == "table" then
		tbl.supportedAlpha = library.e.display_plane_alpha.make_enums(tbl.supportedAlpha)
	elseif type(tbl.supportedAlpha) == "string" then
		tbl.supportedAlpha = library.e.display_plane_alpha[tbl.supportedAlpha]
	end

	if type(tbl.minSrcPosition) == "table" then
		tbl.minSrcPosition = library.s.Offset2D(tbl.minSrcPosition, true)
	end

	if type(tbl.maxSrcPosition) == "table" then
		tbl.maxSrcPosition = library.s.Offset2D(tbl.maxSrcPosition, true)
	end

	if type(tbl.minSrcExtent) == "table" then
		tbl.minSrcExtent = library.s.Extent2D(tbl.minSrcExtent, true)
	end

	if type(tbl.maxSrcExtent) == "table" then
		tbl.maxSrcExtent = library.s.Extent2D(tbl.maxSrcExtent, true)
	end

	if type(tbl.minDstPosition) == "table" then
		tbl.minDstPosition = library.s.Offset2D(tbl.minDstPosition, true)
	end

	if type(tbl.maxDstPosition) == "table" then
		tbl.maxDstPosition = library.s.Offset2D(tbl.maxDstPosition, true)
	end

	if type(tbl.minDstExtent) == "table" then
		tbl.minDstExtent = library.s.Extent2D(tbl.minDstExtent, true)
	end

	if type(tbl.maxDstExtent) == "table" then
		tbl.maxDstExtent = library.s.Extent2D(tbl.maxDstExtent, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplayPlaneCapabilitiesKHR", tbl)
end

function library.s.DisplayPlaneCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlaneCapabilitiesKHR(v)
	end

	return ffi.new("struct VkDisplayPlaneCapabilitiesKHR[?]", #tbl, tbl)
end

function library.s.PipelineViewportStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineViewportStateCreateInfo[?]", #tbl, tbl)
end

function library.s.XYColorEXT(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkXYColorEXT", tbl)
end

function library.s.XYColorEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.XYColorEXT(v)
	end

	return ffi.new("struct VkXYColorEXT[?]", #tbl, tbl)
end

function library.s.CommandBufferArray(tbl)
	return ffi.new("struct VkCommandBuffer_T *[?]", #tbl, tbl)
end

function library.s.DescriptorImageInfo(tbl, table_only)
	if type(tbl.imageLayout) == "string" then
		tbl.imageLayout = library.e.image_layout[tbl.imageLayout]
	end

	return table_only and tbl or ffi.new("struct VkDescriptorImageInfo", tbl)
end

function library.s.DescriptorImageInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorImageInfo(v)
	end

	return ffi.new("struct VkDescriptorImageInfo[?]", #tbl, tbl)
end

function library.s.DisplayModeKHRArray(tbl)
	return ffi.new("struct VkDisplayModeKHR_T *[?]", #tbl, tbl)
end

function library.s.DisplayKHRArray(tbl)
	return ffi.new("struct VkDisplayKHR_T *[?]", #tbl, tbl)
end

function library.s.DescriptorSetLayoutSupportArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutSupport(v)
	end

	return ffi.new("struct VkDescriptorSetLayoutSupport[?]", #tbl, tbl)
end

function library.s.DeviceGroupSwapchainCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupSwapchainCreateInfoKHR(v)
	end

	return ffi.new("struct VkDeviceGroupSwapchainCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.ExportSemaphoreCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportSemaphoreCreateInfo(v)
	end

	return ffi.new("struct VkExportSemaphoreCreateInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupPresentCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupPresentCapabilitiesKHR(v)
	end

	return ffi.new("struct VkDeviceGroupPresentCapabilitiesKHR[?]", #tbl, tbl)
end

function library.s.BindSparseInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindSparseInfo(v)
	end

	return ffi.new("struct VkBindSparseInfo[?]", #tbl, tbl)
end

function library.s.BindImageMemorySwapchainInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemorySwapchainInfoKHR(v)
	end

	return ffi.new("struct VkBindImageMemorySwapchainInfoKHR[?]", #tbl, tbl)
end

function library.s.SwapchainCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SwapchainCreateInfoKHR(v)
	end

	return ffi.new("struct VkSwapchainCreateInfoKHR[?]", #tbl, tbl)
end

function library.s.ExternalImageFormatPropertiesNV(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end

	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature[tbl.externalMemoryFeatures]
	end

	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type[tbl.exportFromImportedHandleTypes]
	end

	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type[tbl.compatibleHandleTypes]
	end

	return table_only and tbl or ffi.new("struct VkExternalImageFormatPropertiesNV", tbl)
end

function library.s.ExternalImageFormatPropertiesNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatPropertiesNV(v)
	end

	return ffi.new("struct VkExternalImageFormatPropertiesNV[?]", #tbl, tbl)
end

function library.s.SwapchainKHRArray(tbl)
	return ffi.new("struct VkSwapchainKHR_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceProtectedMemoryFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProtectedMemoryFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceProtectedMemoryFeatures[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceShaderDrawParameterFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceShaderDrawParameterFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceShaderDrawParameterFeatures[?]", #tbl, tbl)
end

function library.s.DisplayModeParametersKHR(tbl, table_only)
	if type(tbl.visibleRegion) == "table" then
		tbl.visibleRegion = library.s.Extent2D(tbl.visibleRegion, true)
	end

	return table_only and tbl or ffi.new("struct VkDisplayModeParametersKHR", tbl)
end

function library.s.DisplayModeParametersKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeParametersKHR(v)
	end

	return ffi.new("struct VkDisplayModeParametersKHR[?]", #tbl, tbl)
end

function library.s.ExtensionProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtensionProperties", tbl)
end

function library.s.ExtensionPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExtensionProperties(v)
	end

	return ffi.new("struct VkExtensionProperties[?]", #tbl, tbl)
end

function library.s.BindImageMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImageMemoryInfo(v)
	end

	return ffi.new("struct VkBindImageMemoryInfo[?]", #tbl, tbl)
end

function library.s.SurfaceFormatKHR(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end

	if type(tbl.colorSpace) == "string" then
		tbl.colorSpace = library.e.colorspace[tbl.colorSpace]
	end

	return table_only and tbl or ffi.new("struct VkSurfaceFormatKHR", tbl)
end

function library.s.SurfaceFormatKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceFormatKHR(v)
	end

	return ffi.new("struct VkSurfaceFormatKHR[?]", #tbl, tbl)
end

function library.s.SurfaceCapabilitiesKHR(tbl, table_only)
	if type(tbl.currentExtent) == "table" then
		tbl.currentExtent = library.s.Extent2D(tbl.currentExtent, true)
	end

	if type(tbl.minImageExtent) == "table" then
		tbl.minImageExtent = library.s.Extent2D(tbl.minImageExtent, true)
	end

	if type(tbl.maxImageExtent) == "table" then
		tbl.maxImageExtent = library.s.Extent2D(tbl.maxImageExtent, true)
	end

	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end

	if type(tbl.currentTransform) == "table" then
		tbl.currentTransform = library.e.surface_transform.make_enums(tbl.currentTransform)
	elseif type(tbl.currentTransform) == "string" then
		tbl.currentTransform = library.e.surface_transform[tbl.currentTransform]
	end

	if type(tbl.supportedCompositeAlpha) == "table" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha.make_enums(tbl.supportedCompositeAlpha)
	elseif type(tbl.supportedCompositeAlpha) == "string" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha[tbl.supportedCompositeAlpha]
	end

	if type(tbl.supportedUsageFlags) == "table" then
		tbl.supportedUsageFlags = library.e.image_usage.make_enums(tbl.supportedUsageFlags)
	elseif type(tbl.supportedUsageFlags) == "string" then
		tbl.supportedUsageFlags = library.e.image_usage[tbl.supportedUsageFlags]
	end

	return table_only and tbl or ffi.new("struct VkSurfaceCapabilitiesKHR", tbl)
end

function library.s.SurfaceCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilitiesKHR(v)
	end

	return ffi.new("struct VkSurfaceCapabilitiesKHR[?]", #tbl, tbl)
end

function library.s.ExternalMemoryImageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfo(v)
	end

	return ffi.new("struct VkExternalMemoryImageCreateInfo[?]", #tbl, tbl)
end

function library.s.EventCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.EventCreateInfo(v)
	end

	return ffi.new("struct VkEventCreateInfo[?]", #tbl, tbl)
end

function library.s.VertexInputBindingDescription(tbl, table_only)
	if type(tbl.inputRate) == "string" then
		tbl.inputRate = library.e.vertex_input_rate[tbl.inputRate]
	end

	return table_only and tbl or ffi.new("struct VkVertexInputBindingDescription", tbl)
end

function library.s.VertexInputBindingDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputBindingDescription(v)
	end

	return ffi.new("struct VkVertexInputBindingDescription[?]", #tbl, tbl)
end

function library.s.MemoryRequirements(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkMemoryRequirements", tbl)
end

function library.s.MemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements(v)
	end

	return ffi.new("struct VkMemoryRequirements[?]", #tbl, tbl)
end

function library.s.DeviceQueueInfo2(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.device_queue_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.device_queue_create[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkDeviceQueueInfo2", tbl)
end

function library.s.DeviceQueueInfo2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceQueueInfo2(v)
	end

	return ffi.new("struct VkDeviceQueueInfo2[?]", #tbl, tbl)
end

function library.s.ExternalFencePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalFenceProperties(v)
	end

	return ffi.new("struct VkExternalFenceProperties[?]", #tbl, tbl)
end

function library.s.DedicatedAllocationImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationImageCreateInfoNV(v)
	end

	return ffi.new("struct VkDedicatedAllocationImageCreateInfoNV[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalBufferInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalBufferInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalBufferInfo[?]", #tbl, tbl)
end

function library.s.CommandBufferInheritanceInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferInheritanceInfo(v)
	end

	return ffi.new("struct VkCommandBufferInheritanceInfo[?]", #tbl, tbl)
end

function library.s.DeviceGroupRenderPassBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupRenderPassBeginInfo(v)
	end

	return ffi.new("struct VkDeviceGroupRenderPassBeginInfo[?]", #tbl, tbl)
end

function library.s.MemoryHostPointerPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryHostPointerPropertiesEXT(v)
	end

	return ffi.new("struct VkMemoryHostPointerPropertiesEXT[?]", #tbl, tbl)
end

function library.s.BindImagePlaneMemoryInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindImagePlaneMemoryInfo(v)
	end

	return ffi.new("struct VkBindImagePlaneMemoryInfo[?]", #tbl, tbl)
end

function library.s.PushConstantRange(tbl, table_only)
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end

	return table_only and tbl or ffi.new("struct VkPushConstantRange", tbl)
end

function library.s.PushConstantRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PushConstantRange(v)
	end

	return ffi.new("struct VkPushConstantRange[?]", #tbl, tbl)
end

function library.s.DescriptorBufferInfo(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDescriptorBufferInfo", tbl)
end

function library.s.DescriptorBufferInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorBufferInfo(v)
	end

	return ffi.new("struct VkDescriptorBufferInfo[?]", #tbl, tbl)
end

function library.s.MemoryDedicatedRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryDedicatedRequirements(v)
	end

	return ffi.new("struct VkMemoryDedicatedRequirements[?]", #tbl, tbl)
end

function library.s.ShaderResourceUsageAMD(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkShaderResourceUsageAMD", tbl)
end

function library.s.ShaderResourceUsageAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderResourceUsageAMD(v)
	end

	return ffi.new("struct VkShaderResourceUsageAMD[?]", #tbl, tbl)
end

function library.s.SparseImageMemoryRequirements(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.SparseImageFormatProperties(tbl.formatProperties, true)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements", tbl)
end

function library.s.SparseImageMemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements(v)
	end

	return ffi.new("struct VkSparseImageMemoryRequirements[?]", #tbl, tbl)
end

function library.s.DisplayPropertiesKHR(tbl, table_only)
	if type(tbl.physicalDimensions) == "table" then
		tbl.physicalDimensions = library.s.Extent2D(tbl.physicalDimensions, true)
	end

	if type(tbl.physicalResolution) == "table" then
		tbl.physicalResolution = library.s.Extent2D(tbl.physicalResolution, true)
	end

	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end

	return table_only and tbl or ffi.new("struct VkDisplayPropertiesKHR", tbl)
end

function library.s.DisplayPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPropertiesKHR(v)
	end

	return ffi.new("struct VkDisplayPropertiesKHR[?]", #tbl, tbl)
end

function library.s.CommandPoolArray(tbl)
	return ffi.new("struct VkCommandPool_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceVertexAttributeDivisorPropertiesEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceVertexAttributeDivisorPropertiesEXT(v)
	end

	return ffi.new("struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT[?]", #tbl, tbl)
end

function library.s.Offset2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset2D", tbl)
end

function library.s.Offset2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset2D(v)
	end

	return ffi.new("struct VkOffset2D[?]", #tbl, tbl)
end

function library.s.AcquireNextImageInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AcquireNextImageInfoKHR(v)
	end

	return ffi.new("struct VkAcquireNextImageInfoKHR[?]", #tbl, tbl)
end

function library.s.SemaphoreGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SemaphoreGetFdInfoKHR(v)
	end

	return ffi.new("struct VkSemaphoreGetFdInfoKHR[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceFeatures(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures", tbl)
end

function library.s.PhysicalDeviceFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceFeatures[?]", #tbl, tbl)
end

function library.s.PhysicalDevicePointClippingPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDevicePointClippingProperties(v)
	end

	return ffi.new("struct VkPhysicalDevicePointClippingProperties[?]", #tbl, tbl)
end

function library.s.ImageViewUsageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageViewUsageCreateInfo(v)
	end

	return ffi.new("struct VkImageViewUsageCreateInfo[?]", #tbl, tbl)
end

function library.s.SemaphoreArray(tbl)
	return ffi.new("struct VkSemaphore_T *[?]", #tbl, tbl)
end

function library.s.RenderPassCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassCreateInfo(v)
	end

	return ffi.new("struct VkRenderPassCreateInfo[?]", #tbl, tbl)
end

function library.s.SemaphoreCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SemaphoreCreateInfo(v)
	end

	return ffi.new("struct VkSemaphoreCreateInfo[?]", #tbl, tbl)
end

function library.s.PresentRegionKHR(tbl, table_only)
	if type(tbl.pRectangles) == "table" then
		if not tbl.rectangleCount then tbl.rectangleCount = #tbl.pRectangles end

		tbl.pRectangles = library.s.RectLayerKHRArray(tbl.pRectangles, false)
	end

	return table_only and tbl or ffi.new("struct VkPresentRegionKHR", tbl)
end

function library.s.PresentRegionKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentRegionKHR(v)
	end

	return ffi.new("struct VkPresentRegionKHR[?]", #tbl, tbl)
end

function library.s.BufferViewArray(tbl)
	return ffi.new("struct VkBufferView_T *[?]", #tbl, tbl)
end

function library.s.FramebufferArray(tbl)
	return ffi.new("struct VkFramebuffer_T *[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceSamplerYcbcrConversionFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSamplerYcbcrConversionFeatures(v)
	end

	return ffi.new("struct VkPhysicalDeviceSamplerYcbcrConversionFeatures[?]", #tbl, tbl)
end

function library.s.VertexInputBindingDivisorDescriptionEXT(tbl, table_only)
	return table_only and
		tbl or
		ffi.new("struct VkVertexInputBindingDivisorDescriptionEXT", tbl)
end

function library.s.VertexInputBindingDivisorDescriptionEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputBindingDivisorDescriptionEXT(v)
	end

	return ffi.new("struct VkVertexInputBindingDivisorDescriptionEXT[?]", #tbl, tbl)
end

function library.s.DeviceQueueCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceQueueCreateInfo(v)
	end

	return ffi.new("struct VkDeviceQueueCreateInfo[?]", #tbl, tbl)
end

function library.s.FenceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FenceCreateInfo(v)
	end

	return ffi.new("struct VkFenceCreateInfo[?]", #tbl, tbl)
end

function library.s.MemoryAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateInfo(v)
	end

	return ffi.new("struct VkMemoryAllocateInfo[?]", #tbl, tbl)
end

function library.s.PipelineColorBlendStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineColorBlendStateCreateInfo[?]", #tbl, tbl)
end

function library.s.PipelineLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineLayoutCreateInfo(v)
	end

	return ffi.new("struct VkPipelineLayoutCreateInfo[?]", #tbl, tbl)
end

function library.s.MemoryType(tbl, table_only)
	if type(tbl.propertyFlags) == "table" then
		tbl.propertyFlags = library.e.memory_property.make_enums(tbl.propertyFlags)
	elseif type(tbl.propertyFlags) == "string" then
		tbl.propertyFlags = library.e.memory_property[tbl.propertyFlags]
	end

	return table_only and tbl or ffi.new("struct VkMemoryType", tbl)
end

function library.s.MemoryTypeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryType(v)
	end

	return ffi.new("struct VkMemoryType[?]", #tbl, tbl)
end

function library.s.PipelineInputAssemblyStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineInputAssemblyStateCreateInfo(v)
	end

	return ffi.new("struct VkPipelineInputAssemblyStateCreateInfo[?]", #tbl, tbl)
end

function library.s.DrawIndexedIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndexedIndirectCommand", tbl)
end

function library.s.DrawIndexedIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndexedIndirectCommand(v)
	end

	return ffi.new("struct VkDrawIndexedIndirectCommand[?]", #tbl, tbl)
end

function library.s.PipelineRasterizationStateRasterizationOrderAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateRasterizationOrderAMD(v)
	end

	return ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD[?]", #tbl, tbl)
end

function library.s.MemoryGetFdInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryGetFdInfoKHR(v)
	end

	return ffi.new("struct VkMemoryGetFdInfoKHR[?]", #tbl, tbl)
end

function library.s.SamplerYcbcrConversionCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerYcbcrConversionCreateInfo(v)
	end

	return ffi.new("struct VkSamplerYcbcrConversionCreateInfo[?]", #tbl, tbl)
end

function library.s.QueryPoolArray(tbl)
	return ffi.new("struct VkQueryPool_T *[?]", #tbl, tbl)
end

function library.s.DeviceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceCreateInfo(v)
	end

	return ffi.new("struct VkDeviceCreateInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceLimits(tbl, table_only)
	if type(tbl.framebufferColorSampleCounts) == "table" then
		tbl.framebufferColorSampleCounts = library.e.sample_count.make_enums(tbl.framebufferColorSampleCounts)
	elseif type(tbl.framebufferColorSampleCounts) == "string" then
		tbl.framebufferColorSampleCounts = library.e.sample_count[tbl.framebufferColorSampleCounts]
	end

	if type(tbl.framebufferDepthSampleCounts) == "table" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count.make_enums(tbl.framebufferDepthSampleCounts)
	elseif type(tbl.framebufferDepthSampleCounts) == "string" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count[tbl.framebufferDepthSampleCounts]
	end

	if type(tbl.framebufferStencilSampleCounts) == "table" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count.make_enums(tbl.framebufferStencilSampleCounts)
	elseif type(tbl.framebufferStencilSampleCounts) == "string" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count[tbl.framebufferStencilSampleCounts]
	end

	if type(tbl.framebufferNoAttachmentsSampleCounts) == "table" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count.make_enums(tbl.framebufferNoAttachmentsSampleCounts)
	elseif type(tbl.framebufferNoAttachmentsSampleCounts) == "string" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count[tbl.framebufferNoAttachmentsSampleCounts]
	end

	if type(tbl.sampledImageColorSampleCounts) == "table" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageColorSampleCounts)
	elseif type(tbl.sampledImageColorSampleCounts) == "string" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count[tbl.sampledImageColorSampleCounts]
	end

	if type(tbl.sampledImageIntegerSampleCounts) == "table" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageIntegerSampleCounts)
	elseif type(tbl.sampledImageIntegerSampleCounts) == "string" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count[tbl.sampledImageIntegerSampleCounts]
	end

	if type(tbl.sampledImageDepthSampleCounts) == "table" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageDepthSampleCounts)
	elseif type(tbl.sampledImageDepthSampleCounts) == "string" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count[tbl.sampledImageDepthSampleCounts]
	end

	if type(tbl.sampledImageStencilSampleCounts) == "table" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageStencilSampleCounts)
	elseif type(tbl.sampledImageStencilSampleCounts) == "string" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count[tbl.sampledImageStencilSampleCounts]
	end

	if type(tbl.storageImageSampleCounts) == "table" then
		tbl.storageImageSampleCounts = library.e.sample_count.make_enums(tbl.storageImageSampleCounts)
	elseif type(tbl.storageImageSampleCounts) == "string" then
		tbl.storageImageSampleCounts = library.e.sample_count[tbl.storageImageSampleCounts]
	end

	return table_only and tbl or ffi.new("struct VkPhysicalDeviceLimits", tbl)
end

function library.s.PhysicalDeviceLimitsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceLimits(v)
	end

	return ffi.new("struct VkPhysicalDeviceLimits[?]", #tbl, tbl)
end

function library.s.ExportSemaphoreCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportSemaphoreCreateInfo(v)
	end

	return ffi.new("struct VkExportSemaphoreCreateInfo[?]", #tbl, tbl)
end

function library.s.BufferCopy(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferCopy", tbl)
end

function library.s.BufferCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCopy(v)
	end

	return ffi.new("struct VkBufferCopy[?]", #tbl, tbl)
end

function library.s.ShaderModuleCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderModuleCreateInfo(v)
	end

	return ffi.new("struct VkShaderModuleCreateInfo[?]", #tbl, tbl)
end

function library.s.ImageSubresource(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	return table_only and tbl or ffi.new("struct VkImageSubresource", tbl)
end

function library.s.ImageSubresourceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresource(v)
	end

	return ffi.new("struct VkImageSubresource[?]", #tbl, tbl)
end

function library.s.CommandBufferAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferAllocateInfo(v)
	end

	return ffi.new("struct VkCommandBufferAllocateInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalImageFormatInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalImageFormatInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalImageFormatInfo[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceGroupPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceGroupProperties(v)
	end

	return ffi.new("struct VkPhysicalDeviceGroupProperties[?]", #tbl, tbl)
end

function library.s.SparseImageMemoryRequirements2(tbl, table_only)
	if type(tbl.memoryRequirements) == "table" then
		tbl.memoryRequirements = library.s.SparseImageMemoryRequirements(tbl.memoryRequirements, true)
	end

	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements2", tbl)
end

function library.s.SparseImageMemoryRequirements2Array(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements2(v)
	end

	return ffi.new("struct VkSparseImageMemoryRequirements2[?]", #tbl, tbl)
end

function library.s.SpecializationMapEntry(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSpecializationMapEntry", tbl)
end

function library.s.SpecializationMapEntryArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationMapEntry(v)
	end

	return ffi.new("struct VkSpecializationMapEntry[?]", #tbl, tbl)
end

function library.s.MappedMemoryRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MappedMemoryRange(v)
	end

	return ffi.new("struct VkMappedMemoryRange[?]", #tbl, tbl)
end

function library.s.DescriptorUpdateTemplateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorUpdateTemplateCreateInfo(v)
	end

	return ffi.new("struct VkDescriptorUpdateTemplateCreateInfo[?]", #tbl, tbl)
end

function library.s.MemoryHeap(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.memory_heap.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.memory_heap[tbl.flags]
	end

	return table_only and tbl or ffi.new("struct VkMemoryHeap", tbl)
end

function library.s.MemoryHeapArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryHeap(v)
	end

	return ffi.new("struct VkMemoryHeap[?]", #tbl, tbl)
end

function library.s.PhysicalDeviceExternalBufferInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceExternalBufferInfo(v)
	end

	return ffi.new("struct VkPhysicalDeviceExternalBufferInfo[?]", #tbl, tbl)
end

function library.s.DeviceArray(tbl)
	return ffi.new("struct VkDevice_T *[?]", #tbl, tbl)
end

function library.s.SubresourceLayout(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSubresourceLayout", tbl)
end

function library.s.SubresourceLayoutArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubresourceLayout(v)
	end

	return ffi.new("struct VkSubresourceLayout[?]", #tbl, tbl)
end

function library.s.SamplerCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerCreateInfo(v)
	end

	return ffi.new("struct VkSamplerCreateInfo[?]", #tbl, tbl)
end

function library.s.RenderPassInputAttachmentAspectCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassInputAttachmentAspectCreateInfo(v)
	end

	return ffi.new("struct VkRenderPassInputAttachmentAspectCreateInfo[?]", #tbl, tbl)
end

function library.s.ImageSubresourceRange(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end

	return table_only and tbl or ffi.new("struct VkImageSubresourceRange", tbl)
end

function library.s.ImageSubresourceRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceRange(v)
	end

	return ffi.new("struct VkImageSubresourceRange[?]", #tbl, tbl)
end

function library.s.RenderPassArray(tbl)
	return ffi.new("struct VkRenderPass_T *[?]", #tbl, tbl)
end

function library.s.DescriptorPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolCreateInfo(v)
	end

	return ffi.new("struct VkDescriptorPoolCreateInfo[?]", #tbl, tbl)
end

function library.s.BufferImageCopy(tbl, table_only)
	if type(tbl.imageSubresource) == "table" then
		tbl.imageSubresource = library.s.ImageSubresourceLayers(tbl.imageSubresource, true)
	end

	if type(tbl.imageOffset) == "table" then
		tbl.imageOffset = library.s.Offset3D(tbl.imageOffset, true)
	end

	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent3D(tbl.imageExtent, true)
	end

	return table_only and tbl or ffi.new("struct VkBufferImageCopy", tbl)
end

function library.s.BufferImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferImageCopy(v)
	end

	return ffi.new("struct VkBufferImageCopy[?]", #tbl, tbl)
end

function library.s.MemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryBarrier(v)
	end

	return ffi.new("struct VkMemoryBarrier[?]", #tbl, tbl)
end

function library.s.DeviceGroupSubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceGroupSubmitInfo(v)
	end

	return ffi.new("struct VkDeviceGroupSubmitInfo[?]", #tbl, tbl)
end

function library.CreateBufferView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferViewCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkBufferView_T * [1]")
	local status = CLIB.vkCreateBufferView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then createInfoCount = #pCreateInfos end

		pCreateInfos = library.s.GraphicsPipelineCreateInfoArray(pCreateInfos, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfos
		return box[0], status
	end

	return nil, status
end

function library.CreateFramebuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FramebufferCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkFramebuffer_T * [1]")
	local status = CLIB.vkCreateFramebuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateValidationCache(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ValidationCacheCreateInfoEXT(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkValidationCacheEXT_T * [1]")
	local status = library.CreateValidationCacheEXT(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDebugUtilsMessenger(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DebugUtilsMessengerCreateInfoEXT(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDebugUtilsMessengerEXT_T * [1]")
	local status = library.CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then createInfoCount = #pCreateInfos end

		pCreateInfos = library.s.ComputePipelineCreateInfoArray(pCreateInfos, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfos
		return box[0], status
	end

	return nil, status
end

function library.CreateDescriptorSetLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorSetLayoutCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDescriptorSetLayout_T * [1]")
	local status = CLIB.vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateQueryPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.QueryPoolCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkQueryPool_T * [1]")
	local status = CLIB.vkCreateQueryPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateObjectTable(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ObjectTableCreateInfoNVX(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkObjectTableNVX_T * [1]")
	local status = library.CreateObjectTableNVX(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSampler(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SamplerCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSampler_T * [1]")
	local status = CLIB.vkCreateSampler(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateImage(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkImage_T * [1]")
	local status = CLIB.vkCreateImage(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.AllocateMemory(device, pAllocateInfo, pAllocator)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.MemoryAllocateInfo(pAllocateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDeviceMemory_T * [1]")
	local status = CLIB.vkAllocateMemory(device, pAllocateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDisplayMode(physicalDevice, display, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplayModeCreateInfoKHR(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDisplayModeKHR_T * [1]")
	local status = library.CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorUpdateTemplateCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDescriptorUpdateTemplate_T * [1]")
	local status = library.CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateCommandPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.CommandPoolCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkCommandPool_T * [1]")
	local status = CLIB.vkCreateCommandPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateIndirectCommandsLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.IndirectCommandsLayoutCreateInfoNVX(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkIndirectCommandsLayoutNVX_T * [1]")
	local status = library.CreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreatePipelineLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineLayoutCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkPipelineLayout_T * [1]")
	local status = CLIB.vkCreatePipelineLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SamplerYcbcrConversionCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSamplerYcbcrConversion_T * [1]")
	local status = CLIB.vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateShaderModule(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ShaderModuleCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkShaderModule_T * [1]")
	local status = CLIB.vkCreateShaderModule(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateEvent(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.EventCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkEvent_T * [1]")
	local status = CLIB.vkCreateEvent(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.AllocateCommandBuffers(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.CommandBufferAllocateInfo(pAllocateInfo, false)
	end

	local box = ffi.new("struct VkCommandBuffer_T * [1]")
	local status = CLIB.vkAllocateCommandBuffers(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDescriptorPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorPoolCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDescriptorPool_T * [1]")
	local status = CLIB.vkCreateDescriptorPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSemaphore(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SemaphoreCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSemaphore_T * [1]")
	local status = CLIB.vkCreateSemaphore(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreatePipelineCache(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineCacheCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkPipelineCache_T * [1]")
	local status = CLIB.vkCreatePipelineCache(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDebugReportCallback(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DebugReportCallbackCreateInfoEXT(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDebugReportCallbackEXT_T * [1]")
	local status = library.CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SamplerYcbcrConversionCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSamplerYcbcrConversion_T * [1]")
	local status = library.CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDisplayPlaneSurface(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplaySurfaceCreateInfoKHR(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSurfaceKHR_T * [1]")
	local status = library.CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateBuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkBuffer_T * [1]")
	local status = CLIB.vkCreateBuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateInstance(pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.InstanceCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkInstance_T * [1]")
	local status = CLIB.vkCreateInstance(pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateRenderPass(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.RenderPassCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkRenderPass_T * [1]")
	local status = CLIB.vkCreateRenderPass(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateImageView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageViewCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkImageView_T * [1]")
	local status = CLIB.vkCreateImageView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorUpdateTemplateCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDescriptorUpdateTemplate_T * [1]")
	local status = CLIB.vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSwapchain(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SwapchainCreateInfoKHR(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSwapchainKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateFence(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FenceCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkFence_T * [1]")
	local status = CLIB.vkCreateFence(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateDevice(physicalDevice, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DeviceCreateInfo(pCreateInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkDevice_T * [1]")
	local status = CLIB.vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfo
		return box[0], status
	end

	return nil, status
end

function library.CreateSharedSwapchains(device, swapchainCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not swapchainCount then swapchainCount = #pCreateInfos end

		pCreateInfos = library.s.SwapchainCreateInfoKHRArray(pCreateInfos, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pCreateInfos
		return box[0], status
	end

	return nil, status
end

function library.AllocateDescriptorSets(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.DescriptorSetAllocateInfo(pAllocateInfo, false)
	end

	local box = ffi.new("struct VkDescriptorSet_T * [1]")
	local status = CLIB.vkAllocateDescriptorSets(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[box] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end

function library.CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end

	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end

	return CLIB.vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
end

function library.CmdResolveImage(
	commandBuffer,
	srcImage,
	srcImageLayout,
	dstImage,
	dstImageLayout,
	regionCount,
	pRegions
)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end

	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end

	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.ImageResolveArray(pRegions, false)
	end

	return CLIB.vkCmdResolveImage(
		commandBuffer,
		srcImage,
		srcImageLayout,
		dstImage,
		dstImageLayout,
		regionCount,
		pRegions
	)
end

function library.DestroyObjectTable(device, objectTable, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyObjectTableNVX(device, objectTable, pAllocator)
end

function library.ResetEvent(device, event)
	return CLIB.vkResetEvent(device, event)
end

function library.SetDebugUtilsObjectTag(device, pTagInfo)
	if type(pTagInfo) == "table" then
		pTagInfo = library.s.DebugUtilsObjectTagInfoEXT(pTagInfo, false)
	end

	return library.SetDebugUtilsObjectTagEXT(device, pTagInfo)
end

function library.QueueWaitIdle(queue)
	return CLIB.vkQueueWaitIdle(queue)
end

function library.RegisterDisplayEvent(device, display, pDisplayEventInfo, pAllocator, pFence)
	if type(pDisplayEventInfo) == "table" then
		pDisplayEventInfo = library.s.DisplayEventInfoEXT(pDisplayEventInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)
end

function library.ImportFenceFd(device, pImportFenceFdInfo)
	if type(pImportFenceFdInfo) == "table" then
		pImportFenceFdInfo = library.s.ImportFenceFdInfoKHR(pImportFenceFdInfo, false)
	end

	return library.ImportFenceFdKHR(device, pImportFenceFdInfo)
end

function library.ResetFences(device, fenceCount, pFences)
	if type(pFences) == "table" then
		if not fenceCount then fenceCount = #pFences end

		pFences = library.s.FenceArray(pFences, false)
	end

	return CLIB.vkResetFences(device, fenceCount, pFences)
end

function library.SetDebugUtilsObjectName(device, pNameInfo)
	if type(pNameInfo) == "table" then
		pNameInfo = library.s.DebugUtilsObjectNameInfoEXT(pNameInfo, false)
	end

	return library.SetDebugUtilsObjectNameEXT(device, pNameInfo)
end

function library.BindBufferMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then bindInfoCount = #pBindInfos end

		pBindInfos = library.s.BindBufferMemoryInfoArray(pBindInfos, false)
	end

	return library.BindBufferMemory2KHR(device, bindInfoCount, pBindInfos)
end

function library.CmdResetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end

	return CLIB.vkCmdResetEvent(commandBuffer, event, stageMask)
end

function library.BindBufferMemory(device, buffer, memory, memoryOffset)
	return CLIB.vkBindBufferMemory(device, buffer, memory, memoryOffset)
end

function library.EndCommandBuffer(commandBuffer)
	return CLIB.vkEndCommandBuffer(commandBuffer)
end

function library.CmdDispatchIndirect(commandBuffer, buffer, offset)
	return CLIB.vkCmdDispatchIndirect(commandBuffer, buffer, offset)
end

function library.CmdNextSubpass(commandBuffer, contents)
	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end

	return CLIB.vkCmdNextSubpass(commandBuffer, contents)
end

function library.CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.BufferCopyArray(pRegions, false)
	end

	return CLIB.vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
end

function library.RegisterObjects(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)
	if type(ppObjectTableEntries) == "table" then
		objectCount = #ppObjectTableEntries
		ppObjectTableEntries = library.util.StringList(ppObjectTableEntries)
	end

	return library.RegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)
end

function library.CmdDrawIndirectCount(
	commandBuffer,
	buffer,
	offset,
	countBuffer,
	countBufferOffset,
	maxDrawCount,
	stride
)
	return library.CmdDrawIndirectCountAMD(
		commandBuffer,
		buffer,
		offset,
		countBuffer,
		countBufferOffset,
		maxDrawCount,
		stride
	)
end

function library.DestroyIndirectCommandsLayout(device, indirectCommandsLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)
end

function library.DestroyQueryPool(device, queryPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyQueryPool(device, queryPool, pAllocator)
end

function library.CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
	return CLIB.vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
end

function library.CmdSetStencilReference(commandBuffer, faceMask, reference)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end

	return CLIB.vkCmdSetStencilReference(commandBuffer, faceMask, reference)
end

function library.CmdDebugMarkerEnd(commandBuffer)
	return library.CmdDebugMarkerEndEXT(commandBuffer)
end

function library.DestroyDebugReportCallback(instance, callback, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyDebugReportCallbackEXT(instance, callback, pAllocator)
end

function library.CmdBeginQuery(commandBuffer, queryPool, query, flags)
	if type(flags) == "table" then
		flags = library.e.query_control.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_control[flags]
	end

	return CLIB.vkCmdBeginQuery(commandBuffer, queryPool, query, flags)
end

function library.CmdProcessCommands(commandBuffer, pProcessCommandsInfo)
	if type(pProcessCommandsInfo) == "table" then
		pProcessCommandsInfo = library.s.CmdProcessCommandsInfoNVX(pProcessCommandsInfo, false)
	end

	return library.CmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)
end

function library.QueueSubmit(queue, submitCount, pSubmits, fence)
	if type(pSubmits) == "table" then
		if not submitCount then submitCount = #pSubmits end

		pSubmits = library.s.SubmitInfoArray(pSubmits, false)
	end

	return CLIB.vkQueueSubmit(queue, submitCount, pSubmits, fence)
end

function library.CmdBlitImage(
	commandBuffer,
	srcImage,
	srcImageLayout,
	dstImage,
	dstImageLayout,
	regionCount,
	pRegions,
	filter
)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end

	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end

	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.ImageBlitArray(pRegions, false)
	end

	if type(filter) == "string" then filter = library.e.filter[filter] end

	return CLIB.vkCmdBlitImage(
		commandBuffer,
		srcImage,
		srcImageLayout,
		dstImage,
		dstImageLayout,
		regionCount,
		pRegions,
		filter
	)
end

function library.CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	return CLIB.vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
end

function library.CmdSetSampleLocations(commandBuffer, pSampleLocationsInfo)
	if type(pSampleLocationsInfo) == "table" then
		pSampleLocationsInfo = library.s.SampleLocationsInfoEXT(pSampleLocationsInfo, false)
	end

	return library.CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo)
end

function library.CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
	if type(stageFlags) == "table" then
		stageFlags = library.e.shader_stage.make_enums(stageFlags)
	elseif type(stageFlags) == "string" then
		stageFlags = library.e.shader_stage[stageFlags]
	end

	return CLIB.vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
end

function library.CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end

	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end

	return CLIB.vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
	if type(pBuffers) == "table" then
		if not bindingCount then bindingCount = #pBuffers end

		pBuffers = library.s.BufferArray(pBuffers, false)
	end

	return CLIB.vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
end

function library.DestroyCommandPool(device, commandPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyCommandPool(device, commandPool, pAllocator)
end

function library.CmdSetBlendConstants(commandBuffer, unknown_2)
	return CLIB.vkCmdSetBlendConstants(commandBuffer, unknown_2)
end

function library.DestroyImageView(device, imageView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyImageView(device, imageView, pAllocator)
end

function library.QueueEndDebugUtilsLabel(queue)
	return library.QueueEndDebugUtilsLabelEXT(queue)
end

function library.CmdSetDeviceMask(commandBuffer, deviceMask)
	return library.CmdSetDeviceMaskKHR(commandBuffer, deviceMask)
end

function library.CmdDebugMarkerInsert(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end

	return library.CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)
end

function library.CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
	return CLIB.vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
end

function library.CmdReserveSpaceForCommands(commandBuffer, pReserveSpaceInfo)
	if type(pReserveSpaceInfo) == "table" then
		pReserveSpaceInfo = library.s.CmdReserveSpaceForCommandsInfoNVX(pReserveSpaceInfo, false)
	end

	return library.CmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)
end

function library.CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end

	if type(pColor) == "table" then
		pColor = library.s.ClearColorValue(pColor, false)
	end

	if type(pRanges) == "table" then
		if not rangeCount then rangeCount = #pRanges end

		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end

	return CLIB.vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
end

function library.CmdBeginDebugUtilsLabel(commandBuffer, pLabelInfo)
	if type(pLabelInfo) == "table" then
		pLabelInfo = library.s.DebugUtilsLabelEXT(pLabelInfo, false)
	end

	return library.CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo)
end

function library.CmdDebugMarkerBegin(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end

	return library.CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)
end

function library.DebugMarkerSetObjectName(device, pNameInfo)
	if type(pNameInfo) == "table" then
		pNameInfo = library.s.DebugMarkerObjectNameInfoEXT(pNameInfo, false)
	end

	return library.DebugMarkerSetObjectNameEXT(device, pNameInfo)
end

function library.DestroyImage(device, image, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyImage(device, image, pAllocator)
end

function library.DebugMarkerSetObjectTag(device, pTagInfo)
	if type(pTagInfo) == "table" then
		pTagInfo = library.s.DebugMarkerObjectTagInfoEXT(pTagInfo, false)
	end

	return library.DebugMarkerSetObjectTagEXT(device, pTagInfo)
end

function library.CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)
	return CLIB.vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)
end

function library.ResetDescriptorPool(device, descriptorPool, flags)
	return CLIB.vkResetDescriptorPool(device, descriptorPool, flags)
end

function library.CmdPushDescriptorSet(
	commandBuffer,
	pipelineBindPoint,
	layout,
	set,
	descriptorWriteCount,
	pDescriptorWrites
)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end

	if type(pDescriptorWrites) == "table" then
		if not descriptorWriteCount then
			descriptorWriteCount = #pDescriptorWrites
		end

		pDescriptorWrites = library.s.WriteDescriptorSetArray(pDescriptorWrites, false)
	end

	return library.CmdPushDescriptorSetKHR(
		commandBuffer,
		pipelineBindPoint,
		layout,
		set,
		descriptorWriteCount,
		pDescriptorWrites
	)
end

function library.UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData)
	return library.UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData)
end

function library.DestroyDevice(device, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyDevice(device, pAllocator)
end

function library.BindImageMemory(device, image, memory, memoryOffset)
	return CLIB.vkBindImageMemory(device, image, memory, memoryOffset)
end

function library.ResetCommandPool(device, commandPool, flags)
	if type(flags) == "table" then
		flags = library.e.command_pool_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_pool_reset[flags]
	end

	return CLIB.vkResetCommandPool(device, commandPool, flags)
end

function library.DeviceWaitIdle(device)
	return CLIB.vkDeviceWaitIdle(device)
end

function library.BindImageMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then bindInfoCount = #pBindInfos end

		pBindInfos = library.s.BindImageMemoryInfoArray(pBindInfos, false)
	end

	return library.BindImageMemory2KHR(device, bindInfoCount, pBindInfos)
end

function library.CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end

	return CLIB.vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
end

function library.DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator)
end

function library.DestroyInstance(instance, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyInstance(instance, pAllocator)
end

function library.QueueInsertDebugUtilsLabel(queue, pLabelInfo)
	if type(pLabelInfo) == "table" then
		pLabelInfo = library.s.DebugUtilsLabelEXT(pLabelInfo, false)
	end

	return library.QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo)
end

function library.CmdSetDeviceMask(commandBuffer, deviceMask)
	return CLIB.vkCmdSetDeviceMask(commandBuffer, deviceMask)
end

function library.CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
	if type(pipelineStage) == "table" then
		pipelineStage = library.e.pipeline_stage.make_enums(pipelineStage)
	elseif type(pipelineStage) == "string" then
		pipelineStage = library.e.pipeline_stage[pipelineStage]
	end

	return CLIB.vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
end

function library.CmdSetViewportWScalin(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
	if type(pViewportWScalings) == "table" then
		if not viewportCount then viewportCount = #pViewportWScalings end

		pViewportWScalings = library.s.ViewportWScalingNVArray(pViewportWScalings, false)
	end

	return library.CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
end

function library.DestroySurface(instance, surface, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroySurfaceKHR(instance, surface, pAllocator)
end

function library.CmdCopyQueryPoolResults(
	commandBuffer,
	queryPool,
	firstQuery,
	queryCount,
	dstBuffer,
	dstOffset,
	stride,
	flags
)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end

	return CLIB.vkCmdCopyQueryPoolResults(
		commandBuffer,
		queryPool,
		firstQuery,
		queryCount,
		dstBuffer,
		dstOffset,
		stride,
		flags
	)
end

function library.MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
	if type(pSrcCaches) == "table" then
		if not srcCacheCount then srcCacheCount = #pSrcCaches end

		pSrcCaches = library.s.PipelineCacheArray(pSrcCaches, false)
	end

	return CLIB.vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
end

function library.CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end

	return CLIB.vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
end

function library.DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)
end

function library.ImportSemaphoreFd(device, pImportSemaphoreFdInfo)
	if type(pImportSemaphoreFdInfo) == "table" then
		pImportSemaphoreFdInfo = library.s.ImportSemaphoreFdInfoKHR(pImportSemaphoreFdInfo, false)
	end

	return library.ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)
end

function library.CmdBindDescriptorSets(
	commandBuffer,
	pipelineBindPoint,
	layout,
	firstSet,
	descriptorSetCount,
	pDescriptorSets,
	dynamicOffsetCount,
	pDynamicOffsets
)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end

	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then descriptorSetCount = #pDescriptorSets end

		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end

	return CLIB.vkCmdBindDescriptorSets(
		commandBuffer,
		pipelineBindPoint,
		layout,
		firstSet,
		descriptorSetCount,
		pDescriptorSets,
		dynamicOffsetCount,
		pDynamicOffsets
	)
end

function library.CmdDispatchBase(
	commandBuffer,
	baseGroupX,
	baseGroupY,
	baseGroupZ,
	groupCountX,
	groupCountY,
	groupCountZ
)
	return CLIB.vkCmdDispatchBase(
		commandBuffer,
		baseGroupX,
		baseGroupY,
		baseGroupZ,
		groupCountX,
		groupCountY,
		groupCountZ
	)
end

function library.CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
	return CLIB.vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
end

function library.DestroyEvent(device, event, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyEvent(device, event, pAllocator)
end

function library.BindBufferMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then bindInfoCount = #pBindInfos end

		pBindInfos = library.s.BindBufferMemoryInfoArray(pBindInfos, false)
	end

	return CLIB.vkBindBufferMemory2(device, bindInfoCount, pBindInfos)
end

function library.DestroyBuffer(device, buffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyBuffer(device, buffer, pAllocator)
end

function library.DestroyDebugUtilsMessenger(instance, messenger, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator)
end

function library.SubmitDebugUtilsMessage(instance, messageSeverity, messageTypes, pCallbackData)
	if type(messageSeverity) == "table" then
		messageSeverity = library.e.debug_utils_message_severity.make_enums(messageSeverity)
	elseif type(messageSeverity) == "string" then
		messageSeverity = library.e.debug_utils_message_severity[messageSeverity]
	end

	if type(messageTypes) == "table" then
		messageTypes = library.e.debug_utils_message_type.make_enums(messageTypes)
	elseif type(messageTypes) == "string" then
		messageTypes = library.e.debug_utils_message_type[messageTypes]
	end

	if type(pCallbackData) == "table" then
		pCallbackData = library.s.DebugUtilsMessengerCallbackDataEXT(pCallbackData, false)
	end

	return library.SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData)
end

function library.TrimCommandPool(device, commandPool, flags)
	return CLIB.vkTrimCommandPool(device, commandPool, flags)
end

function library.FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then commandBufferCount = #pCommandBuffers end

		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end

	return CLIB.vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
end

function library.DestroyPipeline(device, pipeline, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyPipeline(device, pipeline, pAllocator)
end

function library.CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.TrimCommandPool(device, commandPool, flags)
	return library.TrimCommandPoolKHR(device, commandPool, flags)
end

function library.DestroyShaderModule(device, shaderModule, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyShaderModule(device, shaderModule, pAllocator)
end

function library.DestroyPipelineLayout(device, pipelineLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)
end

function library.DestroySampler(device, sampler, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroySampler(device, sampler, pAllocator)
end

function library.DestroyFramebuffer(device, framebuffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyFramebuffer(device, framebuffer, pAllocator)
end

function library.CmdWriteBufferMarker(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)
	if type(pipelineStage) == "table" then
		pipelineStage = library.e.pipeline_stage.make_enums(pipelineStage)
	elseif type(pipelineStage) == "string" then
		pipelineStage = library.e.pipeline_stage[pipelineStage]
	end

	return library.CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)
end

function library.CmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
	return library.CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
end

function library.CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
	if type(indexType) == "string" then
		indexType = library.e.index_type[indexType]
	end

	return CLIB.vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
end

function library.DestroyValidationCache(device, validationCache, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroyValidationCacheEXT(device, validationCache, pAllocator)
end

function library.CmdInsertDebugUtilsLabel(commandBuffer, pLabelInfo)
	if type(pLabelInfo) == "table" then
		pLabelInfo = library.s.DebugUtilsLabelEXT(pLabelInfo, false)
	end

	return library.CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo)
end

function library.CmdEndDebugUtilsLabel(commandBuffer)
	return library.CmdEndDebugUtilsLabelEXT(commandBuffer)
end

function library.GetDeviceProcAddr(device, pName)
	return CLIB.vkGetDeviceProcAddr(device, pName)
end

function library.DestroyBufferView(device, bufferView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyBufferView(device, bufferView, pAllocator)
end

function library.ResetCommandBuffer(commandBuffer, flags)
	if type(flags) == "table" then
		flags = library.e.command_buffer_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_buffer_reset[flags]
	end

	return CLIB.vkResetCommandBuffer(commandBuffer, flags)
end

function library.CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
	if type(pViewports) == "table" then
		if not viewportCount then viewportCount = #pViewports end

		pViewports = library.s.ViewportArray(pViewports, false)
	end

	return CLIB.vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
end

function library.CmdSetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end

	return CLIB.vkCmdSetEvent(commandBuffer, event, stageMask)
end

function library.DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)
end

function library.CmdDispatchBase(
	commandBuffer,
	baseGroupX,
	baseGroupY,
	baseGroupZ,
	groupCountX,
	groupCountY,
	groupCountZ
)
	return library.CmdDispatchBaseKHR(
		commandBuffer,
		baseGroupX,
		baseGroupY,
		baseGroupZ,
		groupCountX,
		groupCountY,
		groupCountZ
	)
end

function library.CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
	return CLIB.vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
end

function library.QueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
	if type(pBindInfo) == "table" then
		if not bindInfoCount then bindInfoCount = #pBindInfo end

		pBindInfo = library.s.BindSparseInfoArray(pBindInfo, false)
	end

	return CLIB.vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
end

function library.SetEvent(device, event)
	return CLIB.vkSetEvent(device, event)
end

function library.CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
	if type(pScissors) == "table" then
		if not scissorCount then scissorCount = #pScissors end

		pScissors = library.s.Rect2DArray(pScissors, false)
	end

	return CLIB.vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
end

function library.CmdEndQuery(commandBuffer, queryPool, query)
	return CLIB.vkCmdEndQuery(commandBuffer, queryPool, query)
end

function library.CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end

	if type(pDepthStencil) == "table" then
		pDepthStencil = library.s.ClearDepthStencilValue(pDepthStencil, false)
	end

	if type(pRanges) == "table" then
		if not rangeCount then rangeCount = #pRanges end

		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end

	return CLIB.vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
end

function library.CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
	return CLIB.vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
end

function library.DestroySwapchain(device, swapchain, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.DestroySwapchainKHR(device, swapchain, pAllocator)
end

function library.CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	return CLIB.vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
end

function library.FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then descriptorSetCount = #pDescriptorSets end

		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end

	return CLIB.vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
end

function library.DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
end

function library.CmdWaitEvents(
	commandBuffer,
	eventCount,
	pEvents,
	srcStageMask,
	dstStageMask,
	memoryBarrierCount,
	pMemoryBarriers,
	bufferMemoryBarrierCount,
	pBufferMemoryBarriers,
	imageMemoryBarrierCount,
	pImageMemoryBarriers
)
	if type(pEvents) == "table" then
		if not eventCount then eventCount = #pEvents end

		pEvents = library.s.EventArray(pEvents, false)
	end

	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end

	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end

	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then memoryBarrierCount = #pMemoryBarriers end

		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end

	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end

		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end

	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end

		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end

	return CLIB.vkCmdWaitEvents(
		commandBuffer,
		eventCount,
		pEvents,
		srcStageMask,
		dstStageMask,
		memoryBarrierCount,
		pMemoryBarriers,
		bufferMemoryBarrierCount,
		pBufferMemoryBarriers,
		imageMemoryBarrierCount,
		pImageMemoryBarriers
	)
end

function library.CmdEndRenderPass(commandBuffer)
	return CLIB.vkCmdEndRenderPass(commandBuffer)
end

function library.DestroyDescriptorPool(device, descriptorPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyDescriptorPool(device, descriptorPool, pAllocator)
end

function library.DestroyFence(device, fence, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyFence(device, fence, pAllocator)
end

function library.CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end

	return CLIB.vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
end

function library.DestroyRenderPass(device, renderPass, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyRenderPass(device, renderPass, pAllocator)
end

function library.QueueBeginDebugUtilsLabel(queue, pLabelInfo)
	if type(pLabelInfo) == "table" then
		pLabelInfo = library.s.DebugUtilsLabelEXT(pLabelInfo, false)
	end

	return library.QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo)
end

function library.MergeValidationCaches(device, dstCache, srcCacheCount, pSrcCaches)
	if type(pSrcCaches) == "table" then
		if not srcCacheCount then srcCacheCount = #pSrcCaches end

		pSrcCaches = library.s.ValidationCacheEXTArray(pSrcCaches, false)
	end

	return library.MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches)
end

function library.BindImageMemory2(device, bindInfoCount, pBindInfos)
	if type(pBindInfos) == "table" then
		if not bindInfoCount then bindInfoCount = #pBindInfos end

		pBindInfos = library.s.BindImageMemoryInfoArray(pBindInfos, false)
	end

	return CLIB.vkBindImageMemory2(device, bindInfoCount, pBindInfos)
end

function library.CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
	if type(pAttachments) == "table" then
		if not attachmentCount then attachmentCount = #pAttachments end

		pAttachments = library.s.ClearAttachmentArray(pAttachments, false)
	end

	if type(pRects) == "table" then
		if not rectCount then rectCount = #pRects end

		pRects = library.s.ClearRectArray(pRects, false)
	end

	return CLIB.vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
end

function library.CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then commandBufferCount = #pCommandBuffers end

		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end

	return CLIB.vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
end

function library.CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
	if type(pRenderPassBegin) == "table" then
		pRenderPassBegin = library.s.RenderPassBeginInfo(pRenderPassBegin, false)
	end

	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end

	return CLIB.vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
end

function library.ReleaseDisplay(physicalDevice, display)
	return library.ReleaseDisplayEXT(physicalDevice, display)
end

function library.UnregisterObjects(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)
	if type(pObjectEntryTypes) == "string" then
		pObjectEntryTypes = library.e.object_entry_type[pObjectEntryTypes]
	end

	return library.UnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)
end

function library.CmdDrawIndexedIndirectCount(
	commandBuffer,
	buffer,
	offset,
	countBuffer,
	countBufferOffset,
	maxDrawCount,
	stride
)
	return library.CmdDrawIndexedIndirectCountAMD(
		commandBuffer,
		buffer,
		offset,
		countBuffer,
		countBufferOffset,
		maxDrawCount,
		stride
	)
end

function library.BeginCommandBuffer(commandBuffer, pBeginInfo)
	if type(pBeginInfo) == "table" then
		pBeginInfo = library.s.CommandBufferBeginInfo(pBeginInfo, false)
	end

	return CLIB.vkBeginCommandBuffer(commandBuffer, pBeginInfo)
end

function library.UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData)
	return CLIB.vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData)
end

function library.GetInstanceProcAddr(instance, pName)
	return CLIB.vkGetInstanceProcAddr(instance, pName)
end

function library.UnmapMemory(device, memory)
	return CLIB.vkUnmapMemory(device, memory)
end

function library.QueuePresent(queue, pPresentInfo)
	if type(pPresentInfo) == "table" then
		pPresentInfo = library.s.PresentInfoKHR(pPresentInfo, false)
	end

	return library.QueuePresentKHR(queue, pPresentInfo)
end

function library.SetHdrMetadata(device, swapchainCount, pSwapchains, pMetadata)
	if type(pSwapchains) == "table" then
		if not swapchainCount then swapchainCount = #pSwapchains end

		pSwapchains = library.s.SwapchainKHRArray(pSwapchains, false)
	end

	if type(pMetadata) == "table" then
		pMetadata = library.s.HdrMetadataEXT(pMetadata, false)
	end

	return library.SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)
end

function library.InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then memoryRangeCount = #pMemoryRanges end

		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end

	return CLIB.vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.WaitForFences(device, fenceCount, pFences, waitAll, timeout)
	if type(pFences) == "table" then
		if not fenceCount then fenceCount = #pFences end

		pFences = library.s.FenceArray(pFences, false)
	end

	tbl.waitAll = waitAll and 1 or 0
	return CLIB.vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)
end

function library.CmdSetLineWidth(commandBuffer, lineWidth)
	return CLIB.vkCmdSetLineWidth(commandBuffer, lineWidth)
end

function library.CmdSetDiscardRectangle(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
	if type(pDiscardRectangles) == "table" then
		if not discardRectangleCount then
			discardRectangleCount = #pDiscardRectangles
		end

		pDiscardRectangles = library.s.Rect2DArray(pDiscardRectangles, false)
	end

	return library.CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
end

function library.FreeMemory(device, memory, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkFreeMemory(device, memory, pAllocator)
end

function library.FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then memoryRangeCount = #pMemoryRanges end

		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end

	return CLIB.vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)
end

function library.DestroyPipelineCache(device, pipelineCache, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroyPipelineCache(device, pipelineCache, pAllocator)
end

function library.RegisterDeviceEvent(device, pDeviceEventInfo, pAllocator, pFence)
	if type(pDeviceEventInfo) == "table" then
		pDeviceEventInfo = library.s.DeviceEventInfoEXT(pDeviceEventInfo, false)
	end

	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return library.RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)
end

function library.DestroySemaphore(device, semaphore, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end

	return CLIB.vkDestroySemaphore(device, semaphore, pAllocator)
end

function library.CmdCopyImage(
	commandBuffer,
	srcImage,
	srcImageLayout,
	dstImage,
	dstImageLayout,
	regionCount,
	pRegions
)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end

	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end

	if type(pRegions) == "table" then
		if not regionCount then regionCount = #pRegions end

		pRegions = library.s.ImageCopyArray(pRegions, false)
	end

	return CLIB.vkCmdCopyImage(
		commandBuffer,
		srcImage,
		srcImageLayout,
		dstImage,
		dstImageLayout,
		regionCount,
		pRegions
	)
end

function library.UpdateDescriptorSets(
	device,
	descriptorWriteCount,
	pDescriptorWrites,
	descriptorCopyCount,
	pDescriptorCopies
)
	if type(pDescriptorWrites) == "table" then
		if not descriptorWriteCount then
			descriptorWriteCount = #pDescriptorWrites
		end

		pDescriptorWrites = library.s.WriteDescriptorSetArray(pDescriptorWrites, false)
	end

	if type(pDescriptorCopies) == "table" then
		if not descriptorCopyCount then descriptorCopyCount = #pDescriptorCopies end

		pDescriptorCopies = library.s.CopyDescriptorSetArray(pDescriptorCopies, false)
	end

	return CLIB.vkUpdateDescriptorSets(
		device,
		descriptorWriteCount,
		pDescriptorWrites,
		descriptorCopyCount,
		pDescriptorCopies
	)
end

function library.GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end

	return CLIB.vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
end

function library.CmdPipelineBarrier(
	commandBuffer,
	srcStageMask,
	dstStageMask,
	dependencyFlags,
	memoryBarrierCount,
	pMemoryBarriers,
	bufferMemoryBarrierCount,
	pBufferMemoryBarriers,
	imageMemoryBarrierCount,
	pImageMemoryBarriers
)
	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end

	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end

	if type(dependencyFlags) == "table" then
		dependencyFlags = library.e.dependency.make_enums(dependencyFlags)
	elseif type(dependencyFlags) == "string" then
		dependencyFlags = library.e.dependency[dependencyFlags]
	end

	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then memoryBarrierCount = #pMemoryBarriers end

		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end

	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end

		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end

	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end

		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end

	return CLIB.vkCmdPipelineBarrier(
		commandBuffer,
		srcStageMask,
		dstStageMask,
		dependencyFlags,
		memoryBarrierCount,
		pMemoryBarriers,
		bufferMemoryBarrierCount,
		pBufferMemoryBarriers,
		imageMemoryBarrierCount,
		pImageMemoryBarriers
	)
end

function library.DebugReportMessage(
	instance,
	flags,
	objectType,
	object,
	location,
	messageCode,
	pLayerPrefix,
	pMessage
)
	if type(flags) == "table" then
		flags = library.e.debug_report.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.debug_report[flags]
	end

	if type(objectType) == "string" then
		objectType = library.e.debug_report_object_type[objectType]
	end

	return library.DebugReportMessageEXT(
		instance,
		flags,
		objectType,
		object,
		location,
		messageCode,
		pLayerPrefix,
		pMessage
	)
end

function library.DisplayPowerControl(device, display, pDisplayPowerInfo)
	if type(pDisplayPowerInfo) == "table" then
		pDisplayPowerInfo = library.s.DisplayPowerInfoEXT(pDisplayPowerInfo, false)
	end

	return library.DisplayPowerControlEXT(device, display, pDisplayPowerInfo)
end

do
	local META = {
		BeginDebugUtilsLabel = library.QueueBeginDebugUtilsLabel,
		BindSparse = library.QueueBindSparse,
		InsertDebugUtilsLabel = library.QueueInsertDebugUtilsLabel,
		Submit = library.QueueSubmit,
		Present = library.QueuePresent,
		EndDebugUtilsLabel = library.QueueEndDebugUtilsLabel,
		WaitIdle = library.QueueWaitIdle,
	}
	META.__index = META
	ffi.metatype("struct VkQueue_T", META)
end

do
	local META = {
		CreateBufferView = library.CreateBufferView,
		DestroySemaphore = library.DestroySemaphore,
		CreateFramebuffer = library.CreateFramebuffer,
		DestroyPipelineLayout = library.DestroyPipelineLayout,
		LoadProcAddr = library.util.LoadDeviceProcAddr,
		GetEventStatus = library.GetEventStatus,
		GetImageSparseMemoryRequirements2 = library.GetImageSparseMemoryRequirements2,
		GetQueue = library.GetDeviceQueue,
		AllocateDescriptorSets = library.AllocateDescriptorSets,
		RegisterDisplayEvent = library.RegisterDisplayEvent,
		DestroySwapchain = library.DestroySwapchain,
		GetSwapchainCounter = library.GetSwapchainCounter,
		RegisterObjects = library.RegisterObjects,
		GetSwapchainImages = library.GetSwapchainImages,
		GetQueryPoolResults = library.GetQueryPoolResults,
		UpdateDescriptorSets = library.UpdateDescriptorSets,
		CreatePipelineLayout = library.CreatePipelineLayout,
		MergeValidationCaches = library.MergeValidationCaches,
		DestroyPipelineCache = library.DestroyPipelineCache,
		CreateIndirectCommandsLayout = library.CreateIndirectCommandsLayout,
		UpdateDescriptorSetWithTemplate = library.UpdateDescriptorSetWithTemplate,
		GetPipelineCacheData = library.GetPipelineCacheData,
		DestroyObjectTable = library.DestroyObjectTable,
		GetSemaphoreFd = library.GetSemaphoreFd,
		CreateDescriptorUpdateTemplate = library.CreateDescriptorUpdateTemplate,
		DestroyBufferView = library.DestroyBufferView,
		WaitIdle = library.DeviceWaitIdle,
		RegisterEvent = library.RegisterDeviceEvent,
		GetFenceFd = library.GetFenceFd,
		CreateDescriptorSetLayout = library.CreateDescriptorSetLayout,
		DestroyCommandPool = library.DestroyCommandPool,
		DestroyDescriptorUpdateTemplate = library.DestroyDescriptorUpdateTemplate,
		CreateFence = library.CreateFence,
		DestroyFence = library.DestroyFence,
		CreateObjectTable = library.CreateObjectTable,
		GetValidationCacheData = library.GetValidationCacheData,
		CreateGraphicsPipelines = library.CreateGraphicsPipelines,
		CreateSwapchain = library.CreateSwapchain,
		FreeCommandBuffers = library.FreeCommandBuffers,
		TrimCommandPool = library.TrimCommandPool,
		FlushMappedMemoryRanges = library.FlushMappedMemoryRanges,
		DestroyImage = library.DestroyImage,
		GetImageSubresourceLayout = library.GetImageSubresourceLayout,
		WaitForFences = library.WaitForFences,
		DestroyValidationCache = library.DestroyValidationCache,
		CreateImage = library.CreateImage,
		SetHdrMetadata = library.SetHdrMetadata,
		GetBufferMemoryRequirements = library.GetBufferMemoryRequirements,
		CreateSamplerYcbcrConversion = library.CreateSamplerYcbcrConversion,
		BindImageMemory = library.BindImageMemory,
		UnregisterObjects = library.UnregisterObjects,
		Destroy = library.DestroyDevice,
		ImportSemaphoreFd = library.ImportSemaphoreFd,
		DestroyShaderModule = library.DestroyShaderModule,
		UnmapMemory = library.UnmapMemory,
		DestroyDescriptorSetLayout = library.DestroyDescriptorSetLayout,
		GetSwapchainStatus = library.GetSwapchainStatus,
		CreateSampler = library.CreateSampler,
		ImportFenceFd = library.ImportFenceFd,
		FreeDescriptorSets = library.FreeDescriptorSets,
		DestroyDescriptorPool = library.DestroyDescriptorPool,
		GetGroupPeerMemoryFeatures = library.GetDeviceGroupPeerMemoryFeatures,
		CreateQueryPool = library.CreateQueryPool,
		DestroySampler = library.DestroySampler,
		CreateCommandPool = library.CreateCommandPool,
		ResetCommandPool = library.ResetCommandPool,
		BindBufferMemory = library.BindBufferMemory,
		GetImageMemoryRequirements = library.GetImageMemoryRequirements,
		GetMemoryFd = library.GetMemoryFd,
		DebugMarkerSetObjectName = library.DebugMarkerSetObjectName,
		SetDebugUtilsObjectTag = library.SetDebugUtilsObjectTag,
		ResetDescriptorPool = library.ResetDescriptorPool,
		DestroySamplerYcbcrConversion = library.DestroySamplerYcbcrConversion,
		GetProcAddr = library.GetDeviceProcAddr,
		CreateImageView = library.CreateImageView,
		GetDescriptorSetLayoutSupport = library.GetDescriptorSetLayoutSupport,
		GetShaderInfo = library.GetShaderInfo,
		CreateDescriptorPool = library.CreateDescriptorPool,
		DestroyFramebuffer = library.DestroyFramebuffer,
		DestroyIndirectCommandsLayout = library.DestroyIndirectCommandsLayout,
		AllocateMemory = library.AllocateMemory,
		GetImageMemoryRequirements2 = library.GetImageMemoryRequirements2,
		AllocateCommandBuffers = library.AllocateCommandBuffers,
		ResetEvent = library.ResetEvent,
		BindImageMemory2 = library.BindImageMemory2,
		InvalidateMappedMemoryRanges = library.InvalidateMappedMemoryRanges,
		GetImageSparseMemoryRequirements = library.GetImageSparseMemoryRequirements,
		DebugMarkerSetObjectTag = library.DebugMarkerSetObjectTag,
		GetBufferMemoryRequirements2 = library.GetBufferMemoryRequirements2,
		DisplayPowerControl = library.DisplayPowerControl,
		GetMemoryFdProperties = library.GetMemoryFdProperties,
		FreeMemory = library.FreeMemory,
		CreateRenderPass = library.CreateRenderPass,
		ResetFences = library.ResetFences,
		AcquireNextImage2 = library.AcquireNextImage2,
		CreateBuffer = library.CreateBuffer,
		DestroyImageView = library.DestroyImageView,
		GetPastPresentationTimingGOO = library.GetPastPresentationTimingGOO,
		AcquireNextImage = library.AcquireNextImage,
		GetMemoryCommitment = library.GetDeviceMemoryCommitment,
		SetEvent = library.SetEvent,
		MergePipelineCaches = library.MergePipelineCaches,
		GetFenceStatus = library.GetFenceStatus,
		DestroyBuffer = library.DestroyBuffer,
		DestroyQueryPool = library.DestroyQueryPool,
		GetRenderAreaGranularity = library.GetRenderAreaGranularity,
		BindBufferMemory2 = library.BindBufferMemory2,
		DestroyEvent = library.DestroyEvent,
		CreateEvent = library.CreateEvent,
		GetQueue2 = library.GetDeviceQueue2,
		CreateComputePipelines = library.CreateComputePipelines,
		GetRefreshCycleDurationGOO = library.GetRefreshCycleDurationGOO,
		CreateSemaphore = library.CreateSemaphore,
		GetGroupPresentCapabilities = library.GetDeviceGroupPresentCapabilities,
		DestroyPipeline = library.DestroyPipeline,
		GetGroupSurfacePresentModes = library.GetDeviceGroupSurfacePresentModes,
		CreatePipelineCache = library.CreatePipelineCache,
		SetDebugUtilsObjectName = library.SetDebugUtilsObjectName,
		MapMemory = library.MapMemory,
		DestroyRenderPass = library.DestroyRenderPass,
		GetMemoryHostPointerProperties = library.GetMemoryHostPointerProperties,
		CreateSharedSwapchains = library.CreateSharedSwapchains,
		CreateShaderModule = library.CreateShaderModule,
		CreateValidationCache = library.CreateValidationCache,
	}
	META.__index = META
	ffi.metatype("struct VkDevice_T", META)
end

do
	local META = {
		GetDisplayPlaneProperties = library.GetPhysicalDeviceDisplayPlaneProperties,
		GetQueueFamilyProperties = library.GetPhysicalDeviceQueueFamilyProperties,
		GetFeatures2 = library.GetPhysicalDeviceFeatures2,
		GetExternalSemaphoreProperties = library.GetPhysicalDeviceExternalSemaphoreProperties,
		GetSurfaceFormats2 = library.GetPhysicalDeviceSurfaceFormats2,
		GetSurfaceCapabilities = library.GetPhysicalDeviceSurfaceCapabilities,
		GetSurfacePresentModes = library.GetPhysicalDeviceSurfacePresentModes,
		GetFormatProperties2 = library.GetPhysicalDeviceFormatProperties2,
		GetMemoryProperties2 = library.GetPhysicalDeviceMemoryProperties2,
		CreateDevice = library.CreateDevice,
		GetFeatures = library.GetPhysicalDeviceFeatures,
		GetSurfaceSupport = library.GetPhysicalDeviceSurfaceSupport,
		GetDisplayPlaneCapabilities = library.GetDisplayPlaneCapabilities,
		GetExternalBufferProperties = library.GetPhysicalDeviceExternalBufferProperties,
		GetMultisampleProperties = library.GetPhysicalDeviceMultisampleProperties,
		GetProperties2 = library.GetPhysicalDeviceProperties2,
		GetDeviceExtensionProperties = library.GetDeviceExtensionProperties,
		GetDisplayPlaneSupportedDisplays = library.GetDisplayPlaneSupportedDisplays,
		GetPresentRectangles = library.GetPhysicalDevicePresentRectangles,
		GetSurfaceCapabilities2 = library.GetPhysicalDeviceSurfaceCapabilities2,
		GetSparseImageFormatProperties2 = library.GetPhysicalDeviceSparseImageFormatProperties2,
		GetDeviceLayerProperties = library.GetDeviceLayerProperties,
		GetDisplayProperties = library.GetPhysicalDeviceDisplayProperties,
		GetDisplayModeProperties = library.GetDisplayModeProperties,
		GetQueueFamilyProperties2 = library.GetPhysicalDeviceQueueFamilyProperties2,
		ReleaseDisplay = library.ReleaseDisplay,
		GetFormatProperties = library.GetPhysicalDeviceFormatProperties,
		GetSparseImageFormatProperties = library.GetPhysicalDeviceSparseImageFormatProperties,
		GetImageFormatProperties = library.GetPhysicalDeviceImageFormatProperties,
		CreateDisplayMode = library.CreateDisplayMode,
		GetSurfaceFormats = library.GetPhysicalDeviceSurfaceFormats,
		GetImageFormatProperties2 = library.GetPhysicalDeviceImageFormatProperties2,
		GetExternalFenceProperties = library.GetPhysicalDeviceExternalFenceProperties,
		GetProperties = library.GetPhysicalDeviceProperties,
		GetGeneratedCommandsProperties = library.GetPhysicalDeviceGeneratedCommandsProperties,
		GetExternalImageFormatPropertie = library.GetPhysicalDeviceExternalImageFormatPropertie,
		GetMemoryProperties = library.GetPhysicalDeviceMemoryProperties,
	}
	META.__index = META
	ffi.metatype("struct VkPhysicalDevice_T", META)
end

do
	local META = {
		DestroySurface = library.DestroySurface,
		CreateDisplayPlaneSurface = library.CreateDisplayPlaneSurface,
		SubmitDebugUtilsMessage = library.SubmitDebugUtilsMessage,
		GetPhysicalDeviceGroups = library.GetPhysicalDeviceGroups,
		DestroyDebugReportCallback = library.DestroyDebugReportCallback,
		DestroyDebugUtilsMessenger = library.DestroyDebugUtilsMessenger,
		LoadProcAddr = library.util.LoadInstanceProcAddr,
		DebugReportMessage = library.DebugReportMessage,
		GetPhysicalDevices = library.GetPhysicalDevices,
		Destroy = library.DestroyInstance,
		GetProcAddr = library.GetInstanceProcAddr,
		CreateDebugReportCallback = library.CreateDebugReportCallback,
		CreateDebugUtilsMessenger = library.CreateDebugUtilsMessenger,
	}
	META.__index = META
	ffi.metatype("struct VkInstance_T", META)
end

do
	local META = {
		CopyBufferToImage = library.CmdCopyBufferToImage,
		DrawIndirectCount = library.CmdDrawIndirectCount,
		InsertDebugUtilsLabel = library.CmdInsertDebugUtilsLabel,
		CopyBuffer = library.CmdCopyBuffer,
		BindPipeline = library.CmdBindPipeline,
		SetDepthBounds = library.CmdSetDepthBounds,
		PushConstants = library.CmdPushConstants,
		DispatchIndirect = library.CmdDispatchIndirect,
		ClearColorImage = library.CmdClearColorImage,
		PushDescriptorSet = library.CmdPushDescriptorSet,
		ResolveImage = library.CmdResolveImage,
		WriteTimestamp = library.CmdWriteTimestamp,
		BeginDebugUtilsLabel = library.CmdBeginDebugUtilsLabel,
		FillBuffer = library.CmdFillBuffer,
		SetViewport = library.CmdSetViewport,
		End = library.EndCommandBuffer,
		SetStencilWriteMask = library.CmdSetStencilWriteMask,
		DrawIndexedIndirectCount = library.CmdDrawIndexedIndirectCount,
		BindDescriptorSets = library.CmdBindDescriptorSets,
		BlitImage = library.CmdBlitImage,
		SetViewportWScalin = library.CmdSetViewportWScalin,
		ClearDepthStencilImage = library.CmdClearDepthStencilImage,
		DispatchBase = library.CmdDispatchBase,
		DrawIndexed = library.CmdDrawIndexed,
		CopyImage = library.CmdCopyImage,
		SetDiscardRectangle = library.CmdSetDiscardRectangle,
		Begin = library.BeginCommandBuffer,
		BindIndexBuffer = library.CmdBindIndexBuffer,
		Draw = library.CmdDraw,
		DrawIndexedIndirect = library.CmdDrawIndexedIndirect,
		ProcessCommands = library.CmdProcessCommands,
		WriteBufferMarker = library.CmdWriteBufferMarker,
		SetLineWidth = library.CmdSetLineWidth,
		ResetQueryPool = library.CmdResetQueryPool,
		DebugMarkerInsert = library.CmdDebugMarkerInsert,
		SetScissor = library.CmdSetScissor,
		SetStencilReference = library.CmdSetStencilReference,
		DrawIndirect = library.CmdDrawIndirect,
		ClearAttachments = library.CmdClearAttachments,
		SetDepthBias = library.CmdSetDepthBias,
		WaitEvents = library.CmdWaitEvents,
		PushDescriptorSetWithTemplate = library.CmdPushDescriptorSetWithTemplate,
		Dispatch = library.CmdDispatch,
		CopyQueryPoolResults = library.CmdCopyQueryPoolResults,
		SetEvent = library.CmdSetEvent,
		ResetEvent = library.CmdResetEvent,
		SetBlendConstants = library.CmdSetBlendConstants,
		NextSubpass = library.CmdNextSubpass,
		SetDeviceMask = library.CmdSetDeviceMask,
		EndQuery = library.CmdEndQuery,
		CopyImageToBuffer = library.CmdCopyImageToBuffer,
		UpdateBuffer = library.CmdUpdateBuffer,
		SetStencilCompareMask = library.CmdSetStencilCompareMask,
		BeginRenderPass = library.CmdBeginRenderPass,
		SetSampleLocations = library.CmdSetSampleLocations,
		EndDebugUtilsLabel = library.CmdEndDebugUtilsLabel,
		ExecuteCommands = library.CmdExecuteCommands,
		DebugMarkerEnd = library.CmdDebugMarkerEnd,
		ReserveSpaceForCommands = library.CmdReserveSpaceForCommands,
		Reset = library.ResetCommandBuffer,
		EndRenderPass = library.CmdEndRenderPass,
		DebugMarkerBegin = library.CmdDebugMarkerBegin,
		BeginQuery = library.CmdBeginQuery,
		PipelineBarrier = library.CmdPipelineBarrier,
		BindVertexBuffers = library.CmdBindVertexBuffers,
	}
	META.__index = META
	ffi.metatype("struct VkCommandBuffer_T", META)
end

library.clib = CLIB
return library