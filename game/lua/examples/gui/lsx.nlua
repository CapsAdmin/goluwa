local type list = table
local DEPTH = 0

local function Panel(type: string, node, key, props: Table, panel, parent)
	local tabs = string.rep("\t", DEPTH)
	utility.SafeRemove(panel)
	local pnl = gui.CreatePanel(type)

	--llog("%slocal %s = %s", tabs, type, pnl)
	for _, kv in pairs(props) do
		local k = kv.k
		local v = kv.v
		k = k:transform_case("foo_bar", "FooBar")

		if k:starts_with("On") then
			pnl[k] = v
		--llog("%s%s.%s = %s", tabs, type, k, v)
		elseif pnl["Set" .. k] then
			pnl["Set" .. k](pnl, v)
		--llog("%s%s:Set%s(%s)", tabs, type, k, v)
		elseif _G.type(pnl[k]) == "function" then
			pnl[k](pnl, v)
		--llog("%s%s:%s(%s)", tabs, type, k, v)
		end
	end

	pnl:SetParent(parent)
	return pnl
end

local base_elements = {}

for k, v in pairs(prototype.GetRegisteredSubTypes("panel")) do
	local name = k:transform_case("foo_bar", "FooBar")
	_G[name] = function(...)
		return Panel(k, ...)
	end
	base_elements[_G[name]] = name
end

do
	local META = prototype.CreateTemplate("lsx_node", "base")
	META.Kind = "node"
	runfile("lua/libraries/prototype/parenting_template.lua", META)

	function META:OnRemove()
		self:UnParent()
	end

	do
		local function normalize_children(children)
			local out = {}

			if #children == 1 and list.is_list(children[1]) then children = children[1] end

			local last_type

			for i, v in ipairs(children) do
				local t = type(v)

				if t == "number" then
					v = tostring(v)
					t = "string"
				end

				if t == "string" and last_type == t then
					out[#out] = out[#out] .. v
				else
					table.insert(out, v)
				end

				last_type = t
			end

			for i, v in ipairs(out) do
				if type(v) == "string" then
					local self = META:CreateObject()
					self.Kind = "text"
					self.Value = v
					out[i] = self
				end
			end

			return out
		end

		local function cleanup_name(name)
			if not name then return "unknown" end

			return name:gsub("%b()", ""):trim()
		end

		local function Node(render: Function, props: Table, children: List<|string | Table|>)
			assert(render, "render function is nil")
			children = normalize_children(children or {})
			local self = META:CreateObject()
			self.props = props

			for i, v in ipairs(children) do
				self:AddChild(v)
			end

			if base_elements[render] then
				self.build_panel = render
			else
				do
					local map = {}

					for _, kv in ipairs(props) do
						map[kv.k] = kv.v
					end

					map.children = children
					self.props_evaluate = map
				end

				self.evaluate = render
			end

			self.name = base_elements[render] or cleanup_name(debug.get_name(render))
			return self
		end

		-- the xml syntax will be transformed to call LSX(render, props, children)
		_G.LSX = Node
	end

	function META:Evaluate()
		self.persistent_state_index = 0

		-- nodes with evaluate are nodes that are custom functions
		-- for example a wrapper contaier that takes in children and renders them
		-- so we have to discard their initial children, ie:
		-- local function Wrapper(props) return <Base>{props.children}</Base> end
		-- <Wrapper>foo</Wrapper> 
		-- >> <Base>foo</Base>
		if self.evaluate then
			self:RemoveChildren()
			self:AddChild(self.evaluate(self.props_evaluate, self))
		end

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				child:Evaluate()
				child:SetParent(self)
			end
		end

		return self
	end

	function META:BuildPanels(parent)
		if self.build_panel then
			if self:HasParent() then self:GetParent():OnUnmount(parent) end

			self.panel = self.build_panel(self, "nokey", self.props, self.panel, parent)
		else
			self.panel = parent
		end

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				DEPTH = DEPTH + 1
				child:BuildPanels(self.panel)
				DEPTH = DEPTH - 1
			elseif self.panel then
				local str = tostring(child.Value):gsub("%s+", " ")
				self.panel:SetText(str)
				local tabs = string.rep("\t", DEPTH)
			--llog("%s%s:SetText(%s)", tabs, self.panel.ClassName, str)
			end
		end

		if self:HasParent() then self:GetParent():OnMount(self.panel) end
	end

	function META:PersistentState(init)
		self.persistent_states = self.persistent_states or {}
		self.persistent_state_index = self.persistent_state_index + 1

		if self.persistent_states[self.persistent_state_index] == nil then
			self.persistent_states[self.persistent_state_index] = init()
		end

		return self.persistent_states[self.persistent_state_index],
		function(state)
			self.persistent_states[self.persistent_state_index] = state
		end
	end

	function META:ReRender()
		self:Evaluate()

		if self:HasParent() then
			self:BuildPanels(self:GetParent().panel)
		else
			self:BuildPanels(self.root_panel)
		end
	end

	function META:OnMount(parent) end

	function META:OnUnmount() end

	function META:useEffect(func, deps)
		self.effects = self.effects or {}
		local state, update = self:PersistentState(function()
			return {
				effect = true,
				dependencies = deps,
				func = func,
			}
		end)
	end

	function META:memo(val, deps)
		local state, update = self:PersistentState({value = val(), deps = deps})

		if not table.equal(state.deps, deps) then
			state.value = val()
			state.deps = deps
			update(state)
		end

		return state.value
	end

	function META:useState(init)
		local state, update
		state, update = self:PersistentState(function()
			local function set(new_state)
				if not table.equal(state.value, new_state) then
					update({
						value = new_state,
						set = set,
					})
					self:ReRender()
				end
			end

			return {
				value = init,
				set = set,
			}
		end)
		return state.value, state.set
	end

	function META:Dump()
		local str = ""
		str = "<" .. self.name

		if next(self.props) then str = str .. " " end

		for _, kv in pairs(self.props) do
			str = str .. kv.k .. "=" .. kv.v
		end

		str = str .. ">"

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				str = str .. child:Dump()
			else
				str = str .. "\"" .. child.Value .. "\""
			end
		end

		str = str .. "<" .. self.name .. "/>"
		return str
	end

	META:Register()
end

do
	local function eq(a, b)
		local x = a
		x:Evaluate()
		test(x.Dump, x).expect(b)
	end

	eq(<Base/>, "<Base><Base/>")
	eq(<Base foo=1/>, "<Base foo=1><Base/>")
	eq(<Base>
		"foo"
	</Base>
	, "<Base>\"foo\"<Base/>")
	eq(<Base>
		"foo""bar"
	</Base>
	, "<Base>\"foobar\"<Base/>")
	eq(<Base>
		<Base/>
	</Base>
	, "<Base><Base><Base/><Base/>")
	eq(<Base>
		<Base/><Base/>
	</Base>
	, "<Base><Base><Base/><Base><Base/><Base/>")

	do
		local function Custom(props)
			return <Base>
				{props.children}
			</Base>
			
		end

		eq(<Custom>
			<Base/>
		</Custom>
		, "<Custom><Base><Base><Base/><Base/><Custom/>")
	end

	do
		local function Custom()
			return <Text/>
		end

		eq(<Custom>
			<Base/>
		</Custom>
		, "<Custom><Text><Text/><Custom/>")
	end

	do
		local function Custom(props)
			return <Base>
				{props.children}
			</Base>
			
		end

		local x = <Custom>
			<Base/>
		</Custom>
		
		x:Evaluate()
	end
end

if true then
	local function Random()
		return <Text setup_layout={"top"} is_text=1>
			{math.random()}
		</Text>
		
	end

	local function Container(props, node)
		local state, setState = node:useState(0)

		function node:OnMount(panel)
			panel:SetColor(Color(1, 0.5, 0.5, 1))
		end

		return <Base size={Vec2() + 200} setup_layout={"center_simple"} is_view=1 from_container={props.is_container}>
			<Button some_state={state} is_button=1 size={Vec2() + 100 + state} on_press={function()
				setState(state + 1)
			end}>
				{props.children}
			</Button>
			<Base>
				<Base>
					<Base/>
				</Base>
				
			</Base>
			<Random/>
		</Base>
		
	end

	local function App()
		return <Container is_container=1>
			<Text setup_layout={"top"} is_text=1>
				"Hello world"{math.random()}
			</Text>
			<Text setup_layout={"top"} is_text=1>
				"Hello world"
			</Text>
			
		</Container>
		
	end

	local base = gui.CreatePanel("base", nil, "lol")
	base:SetSize(window.GetSize() * 0.5)
	base:CenterSimple()
	base:SetResizable(true)
	base:SetDraggable(true)
	base:SetColor(Color(0.1, 0.1, 0.1, 1))
	base:SetName("base")
	base:SetMargin(Rect(0, 0, 0, 0))
	local x = <App/>
	x:Evaluate():BuildPanels(base)
end

if false then
	local scoreboard_title = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 17,
			shadow = 1,
		}
	)
	local scoreboard_title_2 = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 11,
			shadow = 5,
		}
	)

	local function Info(props, node)
		function node:OnMount(info)
			if props.expanded then
				info:SetVisible(true)
				info:Animate("Size", {Vec2(1, 0), Vec2(1, 1)}, 0.25, "*", 0.25, true)
			else
				info:Animate(
					"Size",
					{Vec2(1, 1), Vec2(1, 0)},
					0.25,
					"*",
					0.25,
					true,
					function()
						info:SetVisible(false)
						title:SetState(false)
					end
				)
			end
		end

		return <Base set_visible={false} set_height={30} set_style={"frame2"} setup_layout={{"top", "fill_x"}} set_clipping={true} set_minimum_size={Vec2()} layout_size={nil}>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"gm_metrostroi_b47 with 3 players"
			</Text>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"tickrate: 67"
			</Text>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"curtime: 1:24h"
			</Text>
			
		</Base>
		
	end

	local function Title(props, node)
		function node:OnMount(title)
			-- TODO: not sure how to solve this yet
			-- this is called after all children are "mounted" so we have the text
			-- the layout stuff is dependent on the prop order
			title:SetMargin(Rect() + 7)
			title:SizeToText()
			title:SetupLayout("top", "fill_x")
			title.label:SetupLayout("left")
		end

		return <TextButton mode="toggle" font={scoreboard_title} on_state_changed={function(_, b)
			props.on_expand(b)
		end}>
			"Bubu's Server - Subway Simulator"
		</TextButton>
		
	end

	local function Scoreboard(props, node)
		local expanded, setExpanded = node:useState(false)
		-- TODO: title will re-render resetting the state
		return <Base size={window.GetSize() * 0.5} setup_layout={{
			"layout_children",
			"size_to_children_height",
			"center_x_simple",
			"center_y_simple",
		}}>
			<Title on_expand={function(b)
				setExpanded(b)
			end}/><Info expanded={expanded}/>
		</Base>
		
	end

	local base = gui.CreatePanel("base", nil, "lol")
	base:SetSize(window.GetSize() * 0.5)
	base:CenterSimple()
	base:SetResizable(true)
	base:SetDraggable(true)
	base:SetColor(Color(0.1, 0.1, 0.1, 1))
	base:SetName("base")
	base:SetMargin(Rect(0, 0, 0, 0))
	local x = <Scoreboard/>
	x.root_panel = base
	x:Evaluate():BuildPanels(base)
end