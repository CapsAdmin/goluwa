local DEPTH = 0

local function Panel(type: string, props: Table)
	local tabs = string.rep("\t", DEPTH)
	local pnl = gui.CreatePanel(type)
	llog("%slocal %s = %s", tabs, type, pnl)

	for _, kv in pairs(props) do
		local k = kv.k
		local v = kv.v
		k = k:transform_case("foo_bar", "FooBar")

		if k:starts_with("On") then
			pnl[k] = v
			llog("%s%s.%s = %s", tabs, type, k, v)
		elseif pnl["Set" .. k] then
			pnl["Set" .. k](pnl, v)
			llog("%s%s:Set%s(%s)", tabs, type, k, v)
		elseif _G.type(pnl[k]) == "function" then
			pnl[k](pnl, v)
			llog("%s%s:%s(%s)", tabs, type, k, v)
		end
	end

	return pnl
end

local base_elements = {}

for k, v in pairs(prototype.GetRegisteredSubTypes("panel")) do
	local name = k:transform_case("foo_bar", "FooBar")
	_G[name] = function(props: Table)
		return Panel(k, props)
	end
	base_elements[_G[name]] = name
end

do
	local function equal(a, b)
		return a == b
	end

	local function expand_children(children)
		if #children == 1 and list.is_list(children[1]) then return children[1] end

		return children
	end

	local function merge_children_with_props(props, children)
		local new_props = {
			children = children,
		}

		for k, v in pairs(props) do
			new_props[k] = v
		end

		return new_props
	end

	local META = prototype.CreateTemplate("lsx_node", "base")
	runfile("lua/libraries/prototype/parenting_template.lua", META)

	local function Node(render: Function, props: Table, children: List<|string | number | Table|>)
		assert(render, "render function is nil")
		children = expand_children(children or {})
		local self = META:CreateObject()
		self.props = props
		self.children = children
		self.original_children = children
		self.original_props = props
		self.rerender = render
		self.name = base_elements[render] or debug.get_name(render) or "unknown"
		return self
	end

	-- the xml syntax will be transformed to call LSX(render, props, children)
	_G.LSX = Node

	function META:build()
		self.state_index = 0
		self.persistent_state_index = 0

		if not base_elements[self.rerender] then
			local new_props = merge_children_with_props(self.original_props, self.original_children)
			local res = self.rerender(new_props, self)
			res:build()
			res.parent = self
			self.children = {res}

			for _, child in ipairs(res.children) do
				if type(child) == "table" then
					child:build()
					child.parent = res
				end
			end
		end

		return self
	end

	function META:render(parent)
		if base_elements[self.rerender] then
			if self.parent then self.parent:OnUnmount(parent) end

			prototype.SafeRemove(self.panel)
			self.panel = self.rerender(self.props)
			self.panel:SetParent(parent)
		else
			self.panel = parent
		end

		for _, child in ipairs(self.children) do
			if type(child) == "table" then
				DEPTH = DEPTH + 1
				child:render(self.panel)
				DEPTH = DEPTH - 1
			elseif self.panel then
				local str = self.panel:GetText() .. tostring(child):gsub("%s+", " ")
				self.panel:SetText(str)
				local tabs = string.rep("\t", DEPTH)
				llog("%s%s:SetText(%s)", tabs, self.panel.ClassName, str)
			end
		end

		if self.parent then self.parent:OnMount(self.panel) end
	end

	function META:PersistentState(init)
		self.persistent_states = self.persistent_states or {}
		self.persistent_state_index = self.persistent_state_index + 1

		if self.persistent_states[self.persistent_state_index] == nil then
			self.persistent_states[self.persistent_state_index] = init()
		end

		return self.persistent_states[self.persistent_state_index],
		function(state)
			self.persistent_states[self.persistent_state_index] = state
		end
	end

	function META:ReRender()
		self:build()
		self:render(self.parent.panel)
	end

	function META:OnMount(parent) end

	function META:OnUnmount() end

	function META:useEffect(func, deps)
		self.effects = self.effects or {}
		local state, update = self:PersistentState(function()
			return {
				effect = true,
				dependencies = deps,
				func = func,
			}
		end)
	end

	function META:memo(val, deps)
		local state, update = self:PersistentState({value = val(), deps = deps})

		if not equal(state.deps, deps) then
			state.value = val()
			state.deps = deps
			update(state)
		end

		return state.value
	end

	function META:useState(init)
		local state, update
		state, update = self:PersistentState(function()
			local function set(new_state)
				if not equal(state.value, new_state) then
					update({
						value = new_state,
						set = set,
					})
					self:ReRender()
				end
			end

			return {
				value = init,
				set = set,
			}
		end)
		return state.value, state.set
	end

	META:Register()
end

do
	local function Random()
		return <Text setup_layout={"top"} is_text=1>
			{math.random()}
		</Text>
		
	end

	local function Container(props, node)
		local state, setState = node:useState(0)

		function node:OnMount(panel)
			panel:SetColor(Color(1, 0.5, 0.5, 1))
		end

		return <Base size={Vec2() + 200} setup_layout={"center_simple"} is_view=1 from_container={props.is_container}>
			<Button some_state={state} is_button=1 size={Vec2() + 100 + state} on_press={function()
				setState(state + 1)
			end}>
				{props.children}
			</Button>
			<Random/>
		</Base>
		
	end

	local function App()
		return <Container is_container=1>
			<Text setup_layout={"top"} is_text=1>
				"Hello world"{math.random()}
			</Text>
			<Text setup_layout={"top"} is_text=1>
				"Hello world"
			</Text>
			
		</Container>
		
	end

	local base = gui.CreatePanel("base", nil, "lol")
	base:SetSize(window.GetSize() * 0.5)
	base:CenterSimple()
	base:SetResizable(true)
	base:SetDraggable(true)
	base:SetColor(Color(0.1, 0.1, 0.1, 1))
	base:SetName("base")
	base:SetMargin(Rect(0, 0, 0, 0))
	local x = <App/>
	x:build():render(base)
end

if false then
	local scoreboard_title = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 17,
			shadow = 1,
		}
	)
	local scoreboard_title_2 = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 11,
			shadow = 5,
		}
	)

	local function Info(props, node)
		function node:OnMount(panel)
			panel:SetLayoutSize()
		end

		return <Base set_visible={false} set_height={30} set_style={"frame2"} setup_layout={{"top", "fill_x"}} set_clipping={true} set_minimum_size={Vec2()}>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"gm_metrostroi_b47 with 3 players"
			</Text>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"tickrate: 67"
			</Text>
			<Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
				"curtime: 1:24h"
			</Text>
			
		</Base>
		
	end

	local function Title(props, node)
		function node:OnMount(title)
			-- TODO: not sure how to solve this yet
			-- this is called after all children are "mounted" so we have the text
			-- the layout stuff is dependent on the prop order
			title:SetMargin(Rect() + 7)
			title:SizeToText()
			title:SetupLayout("top", "fill_x")
			title.label:SetupLayout("left")
		end

		return <TextButton mode="toggle" font={scoreboard_title} on_state_changed={function(_, b)
			do
				return
			end

			if b then
				info:SetVisible(true)
				info:Animate("Size", {Vec2(1, 0), Vec2(1, 1)}, 0.25, "*", 0.25, true)
			else
				info:Animate(
					"Size",
					{Vec2(1, 1), Vec2(1, 0)},
					0.25,
					"*",
					0.25,
					true,
					function()
						info:SetVisible(false)
						title:SetState(false)
					end
				)
			end
		end}>
			"Bubu's Server - Subway Simulator"
		</TextButton>
		
	end

	local function Scoreboard(props, node)
		return <Base size={window.GetSize() * 0.5} setup_layout={{
			"layout_children",
			"size_to_children_height",
			"center_x_simple",
			"center_y_simple",
		}}>
			<Title/><Info/>
		</Base>
		
	end

	local base = gui.CreatePanel("base", nil, "lol")
	base:SetSize(window.GetSize() * 0.5)
	base:CenterSimple()
	base:SetResizable(true)
	base:SetDraggable(true)
	base:SetColor(Color(0.1, 0.1, 0.1, 1))
	base:SetName("base")
	base:SetMargin(Rect(0, 0, 0, 0))
	local x = <Scoreboard/>
	x:build():render(base)
end