local type list = table
local DEPTH = 0

local function create_world()
	local base = gui.CreatePanel("base", nil, "lol")
	base:SetSize(window.GetSize() * 0.5)
	base:CenterSimple()
	base:SetResizable(true)
	base:SetDraggable(true)
	base:SetColor(Color(0.1, 0.1, 0.1, 1))
	base:SetName("base")
	base:SetMargin(Rect(0, 0, 0, 0))
	return base
end

local function Panel(type: string, node, key, props: Table, panel, parent)
	local tabs = string.rep("\t", DEPTH)
	local pnl = panel or gui.CreatePanel(type)

	--llog("%slocal %s = %s", tabs, type, pnl)
	for _, kv in pairs(props) do
		local k = kv.k
		local v = kv.v
		k = k:transform_case("foo_bar", "FooBar")

		if k:starts_with("On") then
			pnl[k] = v
		--llog("%s%s.%s = %s", tabs, type, k, v)
		elseif pnl["Set" .. k] then
			pnl["Set" .. k](pnl, v)
		--llog("%s%s:Set%s(%s)", tabs, type, k, v)
		elseif _G.type(pnl[k]) == "function" then
			if k == "SetupLayout" then
				pnl[k](pnl, unpack(v))
			else
				pnl[k](pnl, v)
			end
		--llog("%s%s:%s(%s)", tabs, type, k, v)
		end
	end

	if not panel then pnl:SetParent(parent) end

	return pnl
end

local base_elements = {}

for k, v in pairs(prototype.GetRegisteredSubTypes("panel")) do
	local name = k:transform_case("foo_bar", "FooBar")
	_G[name] = function(...)
		return Panel(k, ...)
	end
	base_elements[_G[name]] = name
end

do
	local META = prototype.CreateTemplate("lsx_node", "base")
	META.Kind = "node"
	runfile("lua/libraries/prototype/parenting_template.lua", META)

	function META:OnRemove()
		self:UnParent()
		prototype.MakeNULL(self)
	end

	do
		local function unpack_children(children, out): List<|any|>
			out = out or {}

			for i, v in ipairs(children) do
				if list.is_list(v) then
					unpack_children(v, out)
				else
					table.insert(out, v)
				end
			end

			return out
		end

		local function normalize_children(children)
			children = unpack_children(children)
			local out = {}
			local last_type

			for i, v in ipairs(children) do
				local t = type(v)

				if t == "number" then
					v = tostring(v)
					t = "string"
				end

				if t == "string" and last_type == t then
					out[#out] = out[#out] .. v
				else
					table.insert(out, v)
				end

				last_type = t
			end

			for i, v in ipairs(out) do
				if type(v) == "string" then
					local self = META:CreateObject()
					self.Kind = "text"
					self.Value = v
					out[i] = self
				end
			end

			return out
		end

		local function cleanup_name(name)
			if not name then return "unknown" end

			return name:gsub("%b()", ""):trim()
		end

		local function Node(render: Function, props: Table, children: List<|string | Table|>)
			assert(render, "render function is nil")
			children = normalize_children(children or {})
			local self = META:CreateObject()
			self.props = props

			for i, v in ipairs(children) do
				if not v:IsValid() then error("invalid child", 2) end

				self:AddChild(v)
			end

			if base_elements[render] then
				self.build_panel = render
			else
				do
					local map = {}

					for _, kv in ipairs(props) do
						map[kv.k] = kv.v
					end

					map.children = children
					self.props_evaluate = map
				end

				self.evaluate = render
			end

			self.name = base_elements[render] or cleanup_name(debug.get_name(render))
			return self
		end

		-- the xml syntax will be transformed to call LSX(render, props, children)
		_G.LSX = Node
	end

	function META:Evaluate()
		self.persistent_state_index = 0

		-- nodes with evaluate are nodes that are custom functions
		-- for example a wrapper contaier that takes in children and renders them
		-- so we have to discard their initial children, ie:
		-- local function Wrapper(props) return <Base>{props.children}</Base> end
		-- <Wrapper>foo</Wrapper> 
		-- >> <Base>foo</Base>
		if self.evaluate then
			-- a function component only returns 1 node
			local prev_child = self:GetChildren()[1]
			local panel = prev_child and prev_child.panel
			local child_list = self:GetChildrenList()
			local panel_list = {}

			for i, v in ipairs(child_list) do
				panel_list[i] = {
					panel = v.panel,
					persistent_states = v.persistent_states,
					persistent_state_index = v.persistent_state_index,
				}
			end

			--self:RemoveChildren() TODO
			self.Children = {} -- maybe don't remove but just unparent children?
			local test = self.evaluate(self.props_evaluate, self)

			if test then
				test.panel = panel
				test:Evaluate()
				self:AddChild(test)

				for _, child in ipairs(self:GetChildren()) do
					if child.Kind == "node" then
						child:Evaluate()
						child:SetParent(self)
					end
				end

				table.remove(panel_list, 1)

				for i, v in ipairs(test:GetChildrenList()) do
					if v.Kind == "node" then
						if panel_list[i] then
							v.panel = panel_list[i].panel
							v.persistent_states = panel_list[i].persistent_states
							v.persistent_state_index = panel_list[i].persistent_state_index
						end
					end
				end

				return self
			else
				utility.SafeRemove(panel)
			end
		end

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				child:Evaluate()
				child:SetParent(self)
			end
		end

		return self
	end

	function META:BuildPanels(parent)
		local mounted = false

		if self.build_panel then
			if not self.panel then
				mounted = true

				if self:HasParent() then self:GetParent():OnUnmount(parent) end
			end

			self.panel = self.build_panel(self, "nokey", self.props, self.panel, parent)
		else
			self.panel = parent
		end

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				DEPTH = DEPTH + 1
				child:BuildPanels(self.panel)
				DEPTH = DEPTH - 1
			elseif self.panel then
				local str = tostring(child.Value)
				self.panel:SetText(str)
				local tabs = string.rep("\t", DEPTH)
			--llog("%s%s:SetText(%s)", tabs, self.panel.ClassName, str)
			end
		end

		if mounted then
			if self:HasParent() then self:GetParent():OnMount(self.panel) end
		end

		if self:HasParent() then self:GetParent():OnRender(self.panel) end
	end

	function META:PersistentTable(state)
		self.persistent_states = self.persistent_states or {}
		self.persistent_state_index = self.persistent_state_index + 1

		if self.persistent_states[self.persistent_state_index] == nil then
			self.persistent_states[self.persistent_state_index] = state
		end

		return self.persistent_states[self.persistent_state_index]
	end

	function META:ReRender()
		self:Evaluate()

		if self:HasParent() then
			self:BuildPanels(self:GetParent().panel)
		else
			self:BuildPanels(self.root_panel)
		end
	end

	function META:OnMount(parent) end

	function META:OnRender(parent) end

	function META:OnUnmount() end

	function META:useEffect(func, deps)
		self.effects = self.effects or {}
		local state = self:PersistentTable({
			effect = true,
			dependencies = deps,
			func = func,
		})
	end

	function META:memo(val, deps)
		local state = self:PersistentTable({value = val(), deps = deps})

		if not table.equal(state.deps, deps) then
			state.value = val()
			state.deps = deps
		end

		return state.value
	end

	function META:useState(init)
		local state

		local function set(new_state)
			if not table.equal(state.value, new_state) then
				state.value = new_state
				state.set = set
				self:ReRender()
			end
		end

		state = self:PersistentTable({value = init, set = set})
		return state.value, state.set
	end

	function META:useRef(init)
		local state = self:PersistentTable({current = init})
		return state.current
	end

	function META:Dump()
		local str = ""
		str = "<" .. self.name

		if next(self.props) then str = str .. " " end

		for _, kv in pairs(self.props) do
			str = str .. kv.k .. "=" .. tostring(kv.v)
		end

		str = str .. ">"

		for _, child in ipairs(self:GetChildren()) do
			if child.Kind == "node" then
				str = str .. child:Dump()
			else
				str = str .. "\"" .. child.Value .. "\""
			end
		end

		str = str .. "<" .. self.name .. "/>"
		return str
	end

	META:Register()
end

if true then
	local function eq(a, b)
		local x = a
		x:Evaluate()
		test(x.Dump, x).expect(b)
	end

	eq(<Base/>, "<Base><Base/>")
	eq(<Base foo=1/>, "<Base foo=1><Base/>")
	eq(<Base>
		"foo"
	</Base>, "<Base>\"foo\"<Base/>")
	eq(<Base>
		"foo"
		"bar"
	</Base>, "<Base>\"foobar\"<Base/>")
	eq(<Base>
		<Base/>
	</Base>, "<Base><Base><Base/><Base/>")
	eq(<Base>
		<Base/>
		<Base/>
	</Base>, "<Base><Base><Base/><Base><Base/><Base/>")

	do
		local function Custom(props)
			return <Base>
				{props.children}
			</Base>
		end

		eq(<Custom>
			<Base/>
		</Custom>, "<Custom><Base><Base><Base/><Base/><Custom/>")
	end

	do
		local function Custom()
			return <Text/>
		end

		eq(<Custom>
			<Base/>
		</Custom>, "<Custom><Text><Text/><Custom/>")
	end

	do
		local function Test()
			return <Text>
				"1"
			</Text>
		end

		local function Custom(props)
			return <Base>
				{props.children}
				<Test/>
			</Base>
		end

		eq(
			<Custom>
				<Base/>
			</Custom>,
			"<Custom><Base><Base><Base/><Test><Text>\"1\"<Text/><Test/><Base/><Custom/>"
		)
	end

	do
		local function Test2()
			return <Text>
				"2"
			</Text>
		end

		local function Test()
			return <Text>
				"1"
				<Test2/>
			</Text>
		end

		local function Custom(props)
			return <Base>
				{props.children}
				<Test/>
			</Base>
		end

		eq(
			<Custom>
				<Base/>
			</Custom>,
			"<Custom><Base><Base><Base/><Test><Text>\"1\"<Test2><Text>\"2\"<Text/><Test2/><Text/><Test/><Base/><Custom/>"
		)
	end
end

if false then
	local test = 0

	local function Test(props)
		test = test + 1

		if test % 3 == 0 then return nil end

		if test % 3 == 1 then
			return <Text position={Vec2() + 5}>
				"1"
			</Text>
		end

		return <Text position={Vec2() + 10}>
			{math.random()}
		</Text>
	end

	local function Custom(props)
		return <Base size={Vec2() + 50} color={Color(0, 0, 0.3, 1)}>
			{props.children}
			<Test/>
		</Base>
	end

	local function App()
		return <Custom>
			<Base position={Vec2() + 10} size={Vec2() + 20} color={Color(0.2, 0, 0, 1)}/>
		</Custom>
	end

	local base = create_world()
	local x = <App/>
	x = x:Evaluate()
	x:BuildPanels(base)
	local test_node = x:GetChildren()[1]:GetChildren()[1]:GetChildren()[2]

	timer.Repeat("test", 0.5, 0, function()
		test_node:ReRender()
	end)

	return
end

if false then
	local function Random()
		return <Text setup_layout={"top"} is_text=1>
			{math.random()}
		</Text>
	end

	local function Container(props, node)
		local state, setState = node:useState(0)

		function node:OnRender(panel)
			panel:SetColor(Color(1, 0.5, 0.5, 1))
		end

		return <Base
			size={Vec2() + 200}
			setup_layout={"center_simple"}
			is_view=1
			from_container={props.is_container}
		>
			<Button
				some_state={state}
				is_button=1
				size={Vec2() + 100 + state}
				on_release={function()
					setState(state + 1)
				end}
			/>
			<Random/>
		</Base>
	end

	local function App()
		return <Container is_container=1/>
	end

	local base = create_world()
	local x = <App/>
	x:Evaluate():BuildPanels(base)
end

if true then
	local scoreboard_title = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 17,
			shadow = 1,
		}
	)
	local scoreboard_title_2 = fonts.CreateFont(
		{
			path = "Oswald",
			fallback = gfx.GetDefaultFont(),
			size = 11,
			shadow = 5,
		}
	)

	local function Friend()
		return <Base
			cursor="hand"
			texture={render.CreateTextureFromPath("textures/silkicons/user.png")}
			size={Rect() + 16}
			padding={Rect() + 5}
			setup_layout={{"left", "center_y_simple"}}
		/>
	end

	local function Avatar(props, node)
		function node:OnRender(avatar)
			prototype.AddPropertyLink(avatar, props.client, "Path", "AvatarPath")
		end

		return <Image size={Vec2() + 30} padding={Rect()} setup_layout={{"left", "center_y_simple"}}/>
	end

	local function Info2()
		return <Base
			height=30
			style="tab_frame"
			setup_layout={{"left", "fill_x"}}
			on_right_click={function()
				gui.CreateMenu(
					{
						{
							"goto",
							{{"bring", nil, "textures/silkicons/arrow_in.png"}},
							"textures/silkicons/arrow_right.png",
						},
						{},
						{
							"spawn",
							{{"revive", nil, "textures/silkicons/heart.png"}},
							"textures/silkicons/heart_add.png",
						},
						{
							"cleanup",
							{{"kick", nil, "textures/silkicons/connect.png"}},
							"textures/silkicons/bin.png",
						},
						{},
						{
							"admin menu",
							{
								{"ban weapons", nil, "textures/silkicons/gun.png"},
								{"kick", nil, "textures/silkicons/door_out.png"},
								{"ban", nil, "textures/silkicons/delete.png"},
							},
							"textures/silkicons/lock.png",
						},
						{
							"mute",
							{{"gag", nil, "textures/silkicons/comment_delete.png"}},
							"textures/silkicons/sound_mute.png",
						},
					},
					info
				)
			end}
		/>
	end

	local function TeamContainer(props, node)
		--local player_panel, set_player_panel = node:PersistentState(nil)
		return <Base
			style="text_edit"
			margin={Rect()}
			setup_layout={{"layout_children", "top", "size_to_children_height", "fill_x"}}
			no_draw={true}
			minimum_size={Vec2()}
			layout_size={nil}
			width={200}
		>
			<TextButton
				font={scoreboard_title_2}
				mode="toggle"
				margin={Rect() + 5}
				text={props.id}
				size_to_text={nil}
				width={512}
				color={Color(0.25, 0.5, 1, 1) * 3.75}
				setup_layout={{"top", "fill_x"}}
				state={true}
				text={props.team_name}
				on_state_changed={function(_, b)
					do
						return
					end

					if b then
						team:SetVisible(true)
						team:Animate("DrawScaleOffset", {Vec2(1, 0), Vec2(1, 1)}, 0.25, "*", 0.25, true)
					else
						team:Animate(
							"DrawScaleOffset",
							{Vec2(1, 1), Vec2(1, 0)},
							0.25,
							"*",
							0.25,
							true,
							function()
								team:SetVisible(false)
								title:SetState(false)
								scoreboard.panel:Layout(true)
							end
						)
					end
				end}
			/>
			<Base
				margin={Rect()}
				setup_layout={{"top", "size_to_children_height", "fill_x"}}
				no_draw={false}
			>
				{props.children}
			</Base>
		</Base>
	end

	local function Client()
		return <Base height={30} setup_layout={{"top", "fill_x"}} no_draw={true} margin={Rect()}>
			<Friend/>
			<Avatar client={clients.GetLocalClient()}/>
			<Info2/>
		</Base>
	end

	local function ServerInfoText(props)
		return <Text padding={Rect(10, 5, 10, 5)} setup_layout={{"left", "top"}}>
			{props.children}
		</Text>
	end

	local function TitleInfoBar(props, node)
		function node:OnRender(info)
			if props.expanded then
				info:SetVisible(true)
				info:Animate("Size", {Vec2(1, 0), Vec2(1, 1)}, 0.25, "*", 0.25, true)
			else
				info:Animate(
					"Size",
					{Vec2(1, 1), Vec2(1, 0)},
					0.25,
					"*",
					0.25,
					true,
					function()
						info:SetVisible(false)
					end
				)
			end
		end

		return <Base
			visibile={false}
			height={30}
			style={"frame2"}
			setup_layout={{"top", "fill_x"}}
			clipping={true}
			minimum_size={Vec2()}
			layout_size={nil}
		>
			<ServerInfoText>
				"gm_metrostroi_b47 with 3 players"
			</ServerInfoText>
			<ServerInfoText>
				"tickrate: 67"
			</ServerInfoText>
			<ServerInfoText>
				"curtime: 1:24h"
			</ServerInfoText>
		</Base>
	end

	local function TitleButton(props, node)
		function node:OnRender(title)
			-- TODO: not sure how to solve this yet
			-- this is called after all children are "mounted" so we have the text
			-- the layout stuff is dependent on the prop order
			title:SetMargin(Rect() + 7)
			title:SizeToText()
			title:SetupLayout("top", "fill_x")
			title.label:SetupLayout("left")
		end

		return <TextButton
			mode="toggle"
			font={scoreboard_title}
			on_state_changed={function(_, b)
				props.on_expand(b)
			end}
		>
			{props.children}
		</TextButton>
	end

	local function ScoreboardTitle(props, node)
		local expanded, setExpanded = node:useState(false)
		return <Base setup_layout={{"size_to_children_height", "fill_x"}}>
			<TitleButton on_expand={function(b)
				setExpanded(b)
			end}>
				"Bubu's Server - Subway Simulator"
			</TitleButton>
			<TitleInfoBar expanded={expanded}/>
		</Base>
	end

	local function Scoreboard(props, node)
		return <Base
			size={window.GetSize() * 0.5}
			setup_layout={{
				"layout_children",
				"size_to_children_height",
				"center_x_simple",
				"center_y_simple",
			}}
		>
			<ScoreboardTitle/>
			<TeamContainer team_name="players">
				<Client/>
			</TeamContainer>
		</Base>
	end

	local base = create_world()
	local x = <Scoreboard/>
	x.root_panel = base
	x:Evaluate():BuildPanels(base)
end