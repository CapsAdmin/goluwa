local function Panel(type: string, props: Table)
	local pnl = gui.CreatePanel(type)

	for k, v in pairs(props) do
		if k:starts_with("On") then
			pnl[k] = v
		elseif pnl["Set" .. k] then
			pnl["Set" .. k](pnl, v)
		elseif _G.type(pnl[k]) == "function" then
			pnl[k](pnl, v)
		end
	end

	return pnl
end

local function View(props: Table)
	return Panel("base", props)
end
local function Text(props: Table)
	return Panel("text", props)
end
local function Button(props: Table)
	return Panel("button", props)
end
local base_elements = {
	[View] = View,
	[Text] = Text,
	[Button] = Button,
}

local function equal(a, b)
	return a == b
end

local function expand_children(children)
	if #children == 1 and list.is_list(children[1]) then return children[1] end

	return children
end

local function merge_children_with_props(props, children)
	local new_props = {
		children = children,
	}

	for k, v in pairs(props) do
		new_props[k] = v
	end

	return new_props
end

local function LSX(render: Function, props: Table, children: List<|string, number, Table|>)
	children = expand_children(children or {})
	local node = {}
	node.props = props
	node.children = children
	node.rerender = render
	node.name = debug.get_name(render)
	node.state_index = 0

	function node:build()
		self.state_index = 0
		
		if not base_elements[self.rerender] then
			local new_props = merge_children_with_props(props, children)
			local res = self.rerender(new_props, self)
			res:build()
			res.parent = self
			self.children = {
				res
			}

			for _, child in ipairs(res.children) do
				if type(child) == "table" then
					child:build()
					child.parent = res
				end
			end
		end

		return self
	end

	function node:render(parent)
		if base_elements[render] then
			prototype.SafeRemove(self.panel)
			self.panel = render(self.props)
			self.panel:SetParent(parent)
		else
			self.panel = parent
		end

		for _, child in ipairs(self.children) do
			if type(child) == "table" then
				child:render(self.panel)
			elseif self.panel then
				self.panel:SetText(self.panel:GetText() .. tostring(child):gsub("%s+", " "))
			end
		end
	end

	
	function node:useState(init)
		self.states = self.states or {}
		self.state_index = self.state_index + 1
		
		if self.states[self.state_index] == nil then
			self.states[self.state_index] = {
				value = init,
				set = function(new_state)
					if not equal(state, new_state) then
						self.states[self.state_index].value = new_state
						self:build()
						self:render(self.parent.panel)
					end
				end
			}
		end

		local state = self.states[self.state_index]
		return state.value, state.set
	end

	return node
end

local function Random()
	return <Text SetupLayout={"top"} is_text=1>
		{math.random()}
	</Text>
	
end

local function Container(props, node)
	local state, setState = node:useState(0)

	return <View Size={Vec2() + 200} Color={Color(0, 0, 0, 1)} is_view=1 from_container={props.is_container}>
		<Button some_state={state} is_button=1 Size={Vec2() + 100 + state} OnPress={function()
			setState(state + 1)
		end}>
			{props.children}
		</Button>
		<Random/>
	</View>
	
end

local function App()
	return <Container is_container=1>
		<Text SetupLayout={"top"} is_text=1>
			Hello world {math.random()}
		</Text>
		<Text SetupLayout={"top"} is_text=1>
			Hello world 
		</Text>
		
	</Container>
	
end

local base = gui.CreatePanel("base", nil, "lol")
base:SetSize(window.GetSize() * 0.5)
base:CenterSimple()
base:SetResizable(true)
base:SetDraggable(true)
base:SetColor(Color(0.1, 0.1, 0.1, 1))
base:SetName("base")
base:SetMargin(Rect(0, 0, 0, 0))

<App/>:build():render(base)
