#include "btBulletCollisionCommon.h"
#include "btBulletDynamicsCommon.h"

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGCFFI


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif




#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>

EXPORT int _wrap_btGetVersion () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)btGetVersion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGetInfinityMask () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)btGetInfinityMask();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSqrt (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSqrt(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFabs (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btFabs(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btCos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btTan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAcos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAcos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAsin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAsin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAtan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2 (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btExp (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btExp(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btLog (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btLog(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPow (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btPow(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFmod (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btFmod(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2Fast (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2Fast(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btFuzzyZero (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)btFuzzyZero(arg1);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGreaterEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btGreaterEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btIsNegative (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)btIsNegative(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRadians (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btRadians(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDegrees (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btDegrees(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFsel (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btFsel(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btMachineIsLittleEndian () {
  int lresult = (int)0 ;
  bool result;
  
  try {
    result = (bool)btMachineIsLittleEndian();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT unsigned int _wrap_btSelect__SWIG_0 (unsigned int larg1, unsigned int larg2, unsigned int larg3) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (unsigned int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT int _wrap_btSelect__SWIG_1 (unsigned int larg1, int larg2, int larg3) {
  int lresult = (int)0 ;
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_btSelect__SWIG_2 (unsigned int larg1, float larg2, float larg3) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (float)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndian__SWIG_0 (unsigned int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_btSwapEndian__SWIG_1 (unsigned short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  unsigned short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndian__SWIG_2 (int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_btSwapEndian__SWIG_3 (short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndianFloat (float larg1) {
  unsigned int lresult = (unsigned int)0 ;
  float arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT float _wrap_btUnswapEndianFloat (unsigned int larg1) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)btUnswapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void _wrap_btSwapEndianDouble (double larg1, unsigned char *larg2) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapEndianDouble(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT double _wrap_btUnswapEndianDouble (unsigned char *larg1) {
  double lresult = (double)0 ;
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


EXPORT btScalar _wrap_btLargeDot (btScalar *larg1, btScalar *larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btNormalizeAngle (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btNormalizeAngle(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void *_wrap_btAlignedAllocInternal (size_t *larg1, int larg2) {
  void * lresult = (void *)0 ;
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = *larg1;
  arg2 = larg2;
  try {
    result = (void *)btAlignedAllocInternal(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btAlignedFreeInternal (void *larg1) {
  void *arg1 = (void *) 0 ;
  
  arg1 = larg1;
  try {
    btAlignedFreeInternal(arg1);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAlignedAllocSetCustom (btAllocFunc *larg1, btFreeFunc *larg2) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  btFreeFunc *arg2 = (btFreeFunc *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btAlignedAllocSetCustom(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAlignedAllocSetCustomAligned (btAlignedAllocFunc *larg1, btAlignedFreeFunc *larg2) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  btAlignedFreeFunc *arg2 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btAlignedAllocSetCustomAligned(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_m_floats_set (btVector3 *larg1, btScalar *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btScalar *b = (btScalar *) arg1->m_floats;
      for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_m_floats_get (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *)(btScalar *) ((arg1)->m_floats);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3__SWIG_0 () {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *result = 0 ;
  
  try {
    result = (btVector3 *)new btVector3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___add_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator +=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___sub_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator -=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___mul_assign____SWIG_0 (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___div_assign__ (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_dot (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_length2 (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_length (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_norm (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->norm();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_safeNormalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->safeNormalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalized (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->normalized();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_rotate (btVector3 *larg1, btVector3 *larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_angle (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_absolute (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->absolute();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_cross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_triple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector3_minAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->minAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_maxAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->maxAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_furthestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->furthestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_closestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->closestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setInterpolate3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btVector3_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___mul_assign____SWIG_1 (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getX (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getY (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getZ (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btVector3_setX (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setY (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZ (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setW (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_x (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_y (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_z (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_w (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btVector3___eq__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator ==((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3___ne__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator !=((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setMax (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setMin (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setValue (btVector3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_getSkewSymmetricMatrix (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZero (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setZero();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btVector3_isZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->isZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_fuzzyZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->fuzzyZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_serialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeDouble(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT long _wrap_btVector3_maxDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT long _wrap_btVector3_minDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_dot3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_delete_btVector3 (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDot (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle__SWIG_0 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btCross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btTriple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4__SWIG_0 () {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *result = 0 ;
  
  try {
    result = (btVector4 *)new btVector4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector4 * lresult = (btVector4 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_btVector4_absolute4 (btVector4 *larg1) {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  
  arg1 = larg1;
  try {
    result = ((btVector4 const *)arg1)->absolute4();
    lresult = new btVector4(result);
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btScalar _wrap_btVector4_getW (btVector4 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector4 const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector4_maxAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->maxAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_minAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->minAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_closestAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->closestAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector4_setValue (btVector4 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btVector4 (btVector4 *larg1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapScalarEndian (btScalar *larg1, btScalar *larg2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapScalarEndian((float const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapVector3Endian (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUnSwapVector3Endian (btVector3 *larg1) {
  btVector3 *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    btUnSwapVector3Endian(*arg1);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_getX (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getY (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getZ (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btQuadWord_setX (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setY (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setZ (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setW (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_x (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_y (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_z (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_w (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btQuadWord___eq__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator ==((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btQuadWord___ne__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator !=((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_0 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_1 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_0 () {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btQuadWord *result = 0 ;
  
  try {
    result = (btQuadWord *)new btQuadWord();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_2 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT void _wrap_btQuadWord_setMax (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setMin (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btQuadWord (btQuadWord *larg1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_0 () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *)new btQuaternion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_2 (btVector3 *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_3 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btQuaternion_setRotation (btQuaternion *larg1, btVector3 *larg2, btScalar *larg3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEuler (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEulerZYX (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator +=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator -=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul_assign____SWIG_0 (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul_assign____SWIG_1 (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_length2 (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_length (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalize (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btQuaternion *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator *((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator /((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div_assign__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalized (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->normalized();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angle (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angleShortestPath (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngle (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngleShortestPath (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btQuaternion_getAxis (btQuaternion *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->getAxis();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->inverse();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator +((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator -((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___neg__ (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->operator -();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_farthest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_nearest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_getIdentity () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *) &btQuaternion::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar *_wrap_btQuaternion_getW (btQuaternion *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuaternion const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_delete_btQuaternion (btQuaternion *larg1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_length (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)length((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle__SWIG_1 (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = inverse((btQuaternion const &)*arg1);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btVector3 *_wrap_quatRotate (btQuaternion *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuat (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuatNormalize2 (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuatNormalize2(*arg1,*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_0 () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *)new btMatrix3x3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_1 (btQuaternion *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_2 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_3 (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator =((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getColumn (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getRow (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3___aref____SWIG_0 (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3___aref____SWIG_1 (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___mul_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator *=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___add_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator +=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___sub_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator -=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_setFromOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setValue (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9, btScalar *larg10) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerZYX (btMatrix3x3 *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setIdentity (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_getIdentity () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_getOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX__SWIG_0 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, unsigned int larg5) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX__SWIG_1 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_scaled (btMatrix3x3 *larg1, btVector3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_determinant (btMatrix3x3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_adjoint (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->adjoint();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_absolute (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->absolute();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transpose (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->transpose();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_inverse (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->inverse();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotx (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdoty (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotz (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_diagonalize (btMatrix3x3 *larg1, btMatrix3x3 *larg2, btScalar larg3, int larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->diagonalize(*arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btMatrix3x3_cofac (btMatrix3x3 *larg1, int larg2, int larg3, int larg4, int larg5) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_serialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_serializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeDouble (btMatrix3x3 *larg1, btMatrix3x3DoubleData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMatrix3x3 (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_0 () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *)new btTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_1 (btQuaternion *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_2 (btQuaternion *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_3 (btMatrix3x3 *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_4 (btMatrix3x3 *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_5 (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btTransform const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform___assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator =((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_mult (btTransform *larg1, btTransform *larg2, btTransform *larg3) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform___funcall__ (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator ()((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform___mul____SWIG_0 (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform___mul____SWIG_1 (btTransform *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_0 (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &(arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_1 (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_getOrigin__SWIG_0 (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_getOrigin__SWIG_1 (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform_getRotation (btTransform *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->getRotation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btTransform_setFromOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_getOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setOrigin (btTransform *larg1, btVector3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOrigin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform_invXform (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTransform_setBasis (btTransform *larg1, btMatrix3x3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBasis((btMatrix3x3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setRotation (btTransform *larg1, btQuaternion *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setIdentity (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btTransform___mul_assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator *=((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverse (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->inverse();
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverseTimes (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform___mul____SWIG_2 (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_getIdentity () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *) &btTransform::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_serialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_serializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeDouble (btTransform *larg1, btTransformDoubleData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTransform (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMotionState (btMotionState *larg1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_getWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMotionState const *)arg1)->getWorldTransform(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_setWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_mergesSimulationIslands (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getAnisotropicFriction (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, btVector3 *larg2, int larg3) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1 (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, int larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1 (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setContactProcessingThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setContactProcessingThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getContactProcessingThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticOrKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasContactResponse (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btCollisionObject *_wrap_new_btCollisionObject () {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btCollisionObject *result = 0 ;
  
  try {
    result = (btCollisionObject *)new btCollisionObject();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT void _wrap_delete_btCollisionObject (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionShape (btCollisionObject *larg1, btCollisionShape *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void *_wrap_btCollisionObject_internalGetExtensionPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionObject_internalSetExtensionPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetExtensionPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getActivationState (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getActivationState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->setActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setDeactivationTime (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDeactivationTime(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getDeactivationTime (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_forceActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->forceActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_0 (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    ((btCollisionObject const *)arg1)->activate(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_1 (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    ((btCollisionObject const *)arg1)->activate();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_isActive (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isActive();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRestitution (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRestitution (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRollingFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRollingFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRollingFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_getInternalType (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getInternalType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setBroadphaseHandle (btCollisionObject *larg1, btBroadphaseProxy *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphaseHandle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationLinearVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationAngularVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getIslandTag (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getIslandTag();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setIslandTag (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setIslandTag(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCompanionId (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCompanionId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCompanionId (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCompanionId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getHitFraction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setHitFraction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setHitFraction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCollisionFlags (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionFlags (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSweptSphereRadius (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdSweptSphereRadius (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdSweptSphereRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSquareMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdMotionThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdMotionThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionObject_getUserPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getUserIndex (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUserIndex();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setUserPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setUserIndex (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getUpdateRevisionInternal (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_checkCollideWith (btCollisionObject *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_calculateSerializeBufferSize (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionObject_serialize (btCollisionObject *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionObject_serializeSingleObject (btCollisionObject *larg1, btSerializer *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDispatcher (btDispatcher *larg1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithm *_wrap_btDispatcher_findAlgorithm__SWIG_0 (btDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btPersistentManifold *larg4) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btCollisionAlgorithm *_wrap_btDispatcher_findAlgorithm__SWIG_1 (btDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btDispatcher_getNewManifold (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btDispatcher_releaseManifold (btDispatcher *larg1, btPersistentManifold *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDispatcher_clearManifold (btDispatcher *larg1, btPersistentManifold *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDispatcher_needsCollision (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDispatcher_needsResponse (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDispatcher_dispatchAllCollisionPairs (btDispatcher *larg1, btOverlappingPairCache *larg2, btDispatcherInfo *larg3, btDispatcher *larg4) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDispatcher_getNumManifolds (btDispatcher *larg1) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDispatcher const *)arg1)->getNumManifolds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold *_wrap_btDispatcher_getManifoldByIndexInternal (btDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold **_wrap_btDispatcher_getInternalManifoldPointer (btDispatcher *larg1) {
  btPersistentManifold ** lresult = (btPersistentManifold **)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold **)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_0 (btDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_1 (btDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)((btDispatcher const *)arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT void *_wrap_btDispatcher_allocateCollisionAlgorithm (btDispatcher *larg1, int larg2) {
  void * lresult = (void *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btDispatcher_freeCollisionAlgorithm (btDispatcher *larg1, void *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->freeCollisionAlgorithm(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btAabbSupport (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = btAabbSupport((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTransformUtil_integrateTransform (btTransform *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4, btTransform *larg5) {
  btTransform *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btTransform *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    btTransformUtil::integrateTransform((btTransform const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransformUtil_calculateVelocityQuaternion (btVector3 *larg1, btVector3 *larg2, btQuaternion *larg3, btQuaternion *larg4, btScalar larg5, btVector3 *larg6, btVector3 *larg7) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion *arg3 = 0 ;
  btQuaternion *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    btTransformUtil::calculateVelocityQuaternion((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btQuaternion const &)*arg3,(btQuaternion const &)*arg4,arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransformUtil_calculateDiffAxisAngleQuaternion (btQuaternion *larg1, btQuaternion *larg2, btVector3 *larg3, btScalar *larg4) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    btTransformUtil::calculateDiffAxisAngleQuaternion((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransformUtil_calculateVelocity (btTransform *larg1, btTransform *larg2, btScalar larg3, btVector3 *larg4, btVector3 *larg5) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    btTransformUtil::calculateVelocity((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransformUtil_calculateDiffAxisAngle (btTransform *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    btTransformUtil::calculateDiffAxisAngle((btTransform const &)*arg1,(btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btTransformUtil *_wrap_new_btTransformUtil () {
  btTransformUtil * lresult = (btTransformUtil *)0 ;
  btTransformUtil *result = 0 ;
  
  try {
    result = (btTransformUtil *)new btTransformUtil();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransformUtil *)0;
  }
}


EXPORT void _wrap_delete_btTransformUtil (btTransformUtil *larg1) {
  btTransformUtil *arg1 = (btTransformUtil *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConvexSeparatingDistanceUtil *_wrap_new_btConvexSeparatingDistanceUtil (btScalar larg1, btScalar larg2) {
  btConvexSeparatingDistanceUtil * lresult = (btConvexSeparatingDistanceUtil *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btConvexSeparatingDistanceUtil *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConvexSeparatingDistanceUtil *)new btConvexSeparatingDistanceUtil(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexSeparatingDistanceUtil *)0;
  }
}


EXPORT btScalar _wrap_btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance (btConvexSeparatingDistanceUtil *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getConservativeSeparatingDistance();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConvexSeparatingDistanceUtil_updateSeparatingDistance (btConvexSeparatingDistanceUtil *larg1, btTransform *larg2, btTransform *larg3) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->updateSeparatingDistance((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexSeparatingDistanceUtil_initSeparatingDistance (btConvexSeparatingDistanceUtil *larg1, btVector3 *larg2, btScalar larg3, btTransform *larg4, btTransform *larg5) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->initSeparatingDistance((btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,(btTransform const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexSeparatingDistanceUtil (btConvexSeparatingDistanceUtil *larg1) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btManifoldPoint *_wrap_new_btManifoldPoint__SWIG_0 () {
  btManifoldPoint * lresult = (btManifoldPoint *)0 ;
  btManifoldPoint *result = 0 ;
  
  try {
    result = (btManifoldPoint *)new btManifoldPoint();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldPoint *)0;
  }
}


EXPORT btManifoldPoint *_wrap_new_btManifoldPoint__SWIG_1 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btManifoldPoint * lresult = (btManifoldPoint *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btManifoldPoint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btManifoldPoint *)new btManifoldPoint((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldPoint *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_localPointA_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_localPointA = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_localPointA_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_localPointA);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_localPointB_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_localPointB = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_localPointB_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_localPointB);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_positionWorldOnB_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_positionWorldOnB = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_positionWorldOnB_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_positionWorldOnB);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_positionWorldOnA_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_positionWorldOnA = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_positionWorldOnA_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_positionWorldOnA);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_normalWorldOnB_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalWorldOnB = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_normalWorldOnB_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_normalWorldOnB);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_distance1_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_distance1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_distance1_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_distance1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_combinedFriction_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_combinedFriction = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_combinedFriction_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_combinedFriction);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_combinedRollingFriction_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_combinedRollingFriction = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_combinedRollingFriction_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_combinedRollingFriction);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_combinedRestitution_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_combinedRestitution = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_combinedRestitution_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_combinedRestitution);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_partId0_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_partId0 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_partId0_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_partId0);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_partId1_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_partId1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_partId1_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_partId1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_index0_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_index0 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_index0_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_index0);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_index1_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_index1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_index1_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_index1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_userPersistentData_set (btManifoldPoint *larg1, void *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_userPersistentData = arg2;
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btManifoldPoint_m_userPersistentData_get (btManifoldPoint *larg1) {
  void * lresult = (void *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *) ((arg1)->m_userPersistentData);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_lateralFrictionInitialized_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_lateralFrictionInitialized = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_lateralFrictionInitialized_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_lateralFrictionInitialized);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_appliedImpulse_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_appliedImpulse = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_appliedImpulse_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_appliedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_appliedImpulseLateral1_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_appliedImpulseLateral1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_appliedImpulseLateral1_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_appliedImpulseLateral1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_appliedImpulseLateral2_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_appliedImpulseLateral2 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_appliedImpulseLateral2_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_appliedImpulseLateral2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_contactMotion1_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactMotion1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_contactMotion1_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_contactMotion1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_contactMotion2_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactMotion2 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_contactMotion2_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_contactMotion2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_contactCFM1_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactCFM1 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_contactCFM1_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_contactCFM1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_contactCFM2_set (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactCFM2 = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_m_contactCFM2_get (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_contactCFM2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_lifeTime_set (btManifoldPoint *larg1, int larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lifeTime = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btManifoldPoint_m_lifeTime_get (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_lifeTime);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_lateralFrictionDir1_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lateralFrictionDir1 = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_lateralFrictionDir1_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_lateralFrictionDir1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_m_lateralFrictionDir2_set (btManifoldPoint *larg1, btVector3 *larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lateralFrictionDir2 = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_m_lateralFrictionDir2_get (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_lateralFrictionDir2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btManifoldPoint_getDistance (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btManifoldPoint const *)arg1)->getDistance();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btManifoldPoint_getLifeTime (btManifoldPoint *larg1) {
  int lresult = (int)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btManifoldPoint const *)arg1)->getLifeTime();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_getPositionWorldOnA (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btManifoldPoint const *)arg1)->getPositionWorldOnA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btManifoldPoint_getPositionWorldOnB (btManifoldPoint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btManifoldPoint const *)arg1)->getPositionWorldOnB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btManifoldPoint_setDistance (btManifoldPoint *larg1, btScalar larg2) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDistance(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btManifoldPoint_getAppliedImpulse (btManifoldPoint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btManifoldPoint const *)arg1)->getAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btManifoldPoint (btManifoldPoint *larg1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPersistentManifold_m_companionIdA_set (btPersistentManifold *larg1, int larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_companionIdA = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_m_companionIdA_get (btPersistentManifold *larg1) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_companionIdA);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPersistentManifold_m_companionIdB_set (btPersistentManifold *larg1, int larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_companionIdB = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_m_companionIdB_get (btPersistentManifold *larg1) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_companionIdB);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPersistentManifold_m_index1a_set (btPersistentManifold *larg1, int larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_index1a = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_m_index1a_get (btPersistentManifold *larg1) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_index1a);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_0 () {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btPersistentManifold *result = 0 ;
  
  try {
    result = (btPersistentManifold *)new btPersistentManifold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_1 (btCollisionObject *larg1, btCollisionObject *larg2, int larg3, btScalar larg4, btScalar larg5) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btPersistentManifold *)new btPersistentManifold((btCollisionObject const *)arg1,(btCollisionObject const *)arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btCollisionObject *_wrap_btPersistentManifold_getBody0 (btPersistentManifold *larg1) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody0();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT btCollisionObject *_wrap_btPersistentManifold_getBody1 (btPersistentManifold *larg1) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT void _wrap_btPersistentManifold_setBodies (btPersistentManifold *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setBodies((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPersistentManifold_clearUserCache (btPersistentManifold *larg1, btManifoldPoint *larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearUserCache(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_getNumContacts (btPersistentManifold *larg1) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPersistentManifold const *)arg1)->getNumContacts();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPersistentManifold_setNumContacts (btPersistentManifold *larg1, int larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumContacts(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_0 (btPersistentManifold *larg1, int larg2) {
  btManifoldPoint * lresult = (btManifoldPoint *)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btManifoldPoint *) &((btPersistentManifold const *)arg1)->getContactPoint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldPoint *)0;
  }
}


EXPORT btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_1 (btPersistentManifold *larg1, int larg2) {
  btManifoldPoint * lresult = (btManifoldPoint *)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btManifoldPoint *) &(arg1)->getContactPoint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldPoint *)0;
  }
}


EXPORT btScalar _wrap_btPersistentManifold_getContactBreakingThreshold (btPersistentManifold *larg1) {
  btScalar lresult = (btScalar)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btPersistentManifold const *)arg1)->getContactBreakingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPersistentManifold_getContactProcessingThreshold (btPersistentManifold *larg1) {
  btScalar lresult = (btScalar)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btPersistentManifold const *)arg1)->getContactProcessingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btPersistentManifold_setContactBreakingThreshold (btPersistentManifold *larg1, btScalar larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setContactBreakingThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPersistentManifold_setContactProcessingThreshold (btPersistentManifold *larg1, btScalar larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setContactProcessingThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_getCacheEntry (btPersistentManifold *larg1, btManifoldPoint *larg2) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)((btPersistentManifold const *)arg1)->getCacheEntry((btManifoldPoint const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPersistentManifold_addManifoldPoint__SWIG_0 (btPersistentManifold *larg1, btManifoldPoint *larg2, int larg3) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPersistentManifold_addManifoldPoint__SWIG_1 (btPersistentManifold *larg1, btManifoldPoint *larg2) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPersistentManifold_removeContactPoint (btPersistentManifold *larg1, int larg2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeContactPoint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPersistentManifold_replaceContactPoint (btPersistentManifold *larg1, btManifoldPoint *larg2, int larg3) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->replaceContactPoint((btManifoldPoint const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPersistentManifold_validContactDistance (btPersistentManifold *larg1, btManifoldPoint *larg2) {
  int lresult = (int)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btPersistentManifold const *)arg1)->validContactDistance((btManifoldPoint const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPersistentManifold_refreshContactPoints (btPersistentManifold *larg1, btTransform *larg2, btTransform *larg3) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->refreshContactPoints((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPersistentManifold_clearManifold (btPersistentManifold *larg1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearManifold();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPersistentManifold (btPersistentManifold *larg1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btManifoldResult *_wrap_new_btManifoldResult__SWIG_0 () {
  btManifoldResult * lresult = (btManifoldResult *)0 ;
  btManifoldResult *result = 0 ;
  
  try {
    result = (btManifoldResult *)new btManifoldResult();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldResult *)0;
  }
}


EXPORT btManifoldResult *_wrap_new_btManifoldResult__SWIG_1 (btCollisionObjectWrapper *larg1, btCollisionObjectWrapper *larg2) {
  btManifoldResult * lresult = (btManifoldResult *)0 ;
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btManifoldResult *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btManifoldResult *)new btManifoldResult((btCollisionObjectWrapper const *)arg1,(btCollisionObjectWrapper const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btManifoldResult *)0;
  }
}


EXPORT void _wrap_delete_btManifoldResult (btManifoldResult *larg1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btManifoldResult_setPersistentManifold (btManifoldResult *larg1, btPersistentManifold *larg2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPersistentManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_0 (btManifoldResult *larg1) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold *)((btManifoldResult const *)arg1)->getPersistentManifold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_1 (btManifoldResult *larg1) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold *)(arg1)->getPersistentManifold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btManifoldResult_setShapeIdentifiersA (btManifoldResult *larg1, int larg2, int larg3) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setShapeIdentifiersA(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btManifoldResult_setShapeIdentifiersB (btManifoldResult *larg1, int larg2, int larg3) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setShapeIdentifiersB(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btManifoldResult_addContactPoint (btManifoldResult *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btManifoldResult_refreshContactPoints (btManifoldResult *larg1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->refreshContactPoints();
    
  } catch (...) {
    
  }
}


EXPORT btCollisionObjectWrapper *_wrap_btManifoldResult_getBody0Wrap (btManifoldResult *larg1) {
  btCollisionObjectWrapper * lresult = (btCollisionObjectWrapper *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody0Wrap();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectWrapper *)0;
  }
}


EXPORT btCollisionObjectWrapper *_wrap_btManifoldResult_getBody1Wrap (btManifoldResult *larg1) {
  btCollisionObjectWrapper * lresult = (btCollisionObjectWrapper *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody1Wrap();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectWrapper *)0;
  }
}


EXPORT void _wrap_btManifoldResult_setBody0Wrap (btManifoldResult *larg1, btCollisionObjectWrapper *larg2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBody0Wrap((btCollisionObjectWrapper const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btManifoldResult_setBody1Wrap (btManifoldResult *larg1, btCollisionObjectWrapper *larg2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBody1Wrap((btCollisionObjectWrapper const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionObject *_wrap_btManifoldResult_getBody0Internal (btManifoldResult *larg1) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody0Internal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT btCollisionObject *_wrap_btManifoldResult_getBody1Internal (btManifoldResult *larg1) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody1Internal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT btScalar _wrap_btManifoldResult_calculateCombinedRestitution (btCollisionObject *larg1, btCollisionObject *larg2) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btManifoldResult::calculateCombinedRestitution((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btManifoldResult_calculateCombinedFriction (btCollisionObject *larg1, btCollisionObject *larg2) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btManifoldResult::calculateCombinedFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btBroadphasePairSortPredicate___funcall__ (btBroadphasePairSortPredicate *larg1, btBroadphasePair *larg2, btBroadphasePair *larg3) {
  int lresult = (int)0 ;
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btBroadphasePair *arg3 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBroadphasePairSortPredicate const *)arg1)->operator ()((btBroadphasePair const &)*arg2,(btBroadphasePair const &)*arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphasePairSortPredicate *_wrap_new_btBroadphasePairSortPredicate () {
  btBroadphasePairSortPredicate * lresult = (btBroadphasePairSortPredicate *)0 ;
  btBroadphasePairSortPredicate *result = 0 ;
  
  try {
    result = (btBroadphasePairSortPredicate *)new btBroadphasePairSortPredicate();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairSortPredicate *)0;
  }
}


EXPORT void _wrap_delete_btBroadphasePairSortPredicate (btBroadphasePairSortPredicate *larg1) {
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getDispatcherFlags (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getDispatcherFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setDispatcherFlags (btCollisionDispatcher *larg1, int larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDispatcherFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_registerCollisionCreateFunc (btCollisionDispatcher *larg1, int larg2, int larg3, btCollisionAlgorithmCreateFunc *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *arg4 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->registerCollisionCreateFunc(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getNumManifolds (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getNumManifolds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold **_wrap_btCollisionDispatcher_getInternalManifoldPointer (btCollisionDispatcher *larg1) {
  btPersistentManifold ** lresult = (btPersistentManifold **)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold **)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_0 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_1 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)((btCollisionDispatcher const *)arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btCollisionDispatcher *_wrap_new_btCollisionDispatcher (btCollisionConfiguration *larg1) {
  btCollisionDispatcher * lresult = (btCollisionDispatcher *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btCollisionDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionDispatcher *)new btCollisionDispatcher(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionDispatcher *)0;
  }
}


EXPORT void _wrap_delete_btCollisionDispatcher (btCollisionDispatcher *larg1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getNewManifold (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_releaseManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_clearManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_0 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btPersistentManifold *larg4) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_1 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsCollision (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsResponse (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_dispatchAllCollisionPairs (btCollisionDispatcher *larg1, btOverlappingPairCache *larg2, btDispatcherInfo *larg3, btDispatcher *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_setNearCallback (btCollisionDispatcher *larg1, btNearCallback larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback arg2 = (btNearCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNearCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btNearCallback _wrap_btCollisionDispatcher_getNearCallback (btCollisionDispatcher *larg1) {
  btNearCallback lresult = (btNearCallback)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback result;
  
  arg1 = larg1;
  try {
    result = (btNearCallback)((btCollisionDispatcher const *)arg1)->getNearCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btNearCallback)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_defaultNearCallback (btBroadphasePair *larg1, btCollisionDispatcher *larg2, btDispatcherInfo *larg3) {
  btBroadphasePair *arg1 = 0 ;
  btCollisionDispatcher *arg2 = 0 ;
  btDispatcherInfo *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btCollisionDispatcher::defaultNearCallback(*arg1,*arg2,(btDispatcherInfo const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionDispatcher_allocateCollisionAlgorithm (btCollisionDispatcher *larg1, int larg2) {
  void * lresult = (void *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_freeCollisionAlgorithm (btCollisionDispatcher *larg1, void *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->freeCollisionAlgorithm(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_0 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)(arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_1 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)((btCollisionDispatcher const *)arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setCollisionConfiguration (btCollisionDispatcher *larg1, btCollisionConfiguration *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *arg2 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionConfiguration(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_0 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_1 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)((btCollisionDispatcher const *)arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btBroadphaseInterface *_wrap_new_btBroadphaseInterface() {
	btBroadphaseInterface * lresult = (btBroadphaseInterface *)0;
	btBroadphaseInterface *result = 0;

	try {
		result = (btBroadphaseInterface *)new btDbvtBroadphase();
		lresult = result;
		return lresult;
	}
	catch (...) {
		return (btBroadphaseInterface *)0;
	}
}


EXPORT void _wrap_delete_btBroadphaseInterface (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btBroadphaseInterface_createProxy (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_destroyProxy (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_setAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_getAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBroadphaseInterface const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_0 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_1 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_2 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_aabbTest (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseAabbCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_calculateOverlappingPairs (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_0 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_1 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btBroadphaseInterface const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_getBroadphaseAabb (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBroadphaseInterface const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_resetPool (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->resetPool(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_printStats (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btOverlappingPairCallback (btOverlappingPairCallback *larg1) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btOverlappingPairCallback_addOverlappingPair (btOverlappingPairCallback *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT void *_wrap_btOverlappingPairCallback_removeOverlappingPair (btOverlappingPairCallback *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3, btDispatcher *larg4) {
  void * lresult = (void *)0 ;
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btOverlappingPairCallback_removeOverlappingPairsContainingProxy (btOverlappingPairCallback *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btOverlappingPairCache (btOverlappingPairCache *larg1) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0 (btOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1 (btOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)((btOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btOverlappingPairCache_getOverlappingPairArray (btOverlappingPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT void _wrap_btOverlappingPairCache_cleanOverlappingPair (btOverlappingPairCache *larg1, btBroadphasePair *larg2, btDispatcher *larg3) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanOverlappingPair(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btOverlappingPairCache_getNumOverlappingPairs (btOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btOverlappingPairCache_cleanProxyFromPairs (btOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanProxyFromPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOverlappingPairCache_setOverlapFilterCallback (btOverlappingPairCache *larg1, btOverlapFilterCallback *larg2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverlapFilterCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOverlappingPairCache_processAllOverlappingPairs (btOverlappingPairCache *larg1, btOverlapCallback *larg2, btDispatcher *larg3) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processAllOverlappingPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btOverlappingPairCache_findPair (btOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT int _wrap_btOverlappingPairCache_hasDeferredRemoval (btOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->hasDeferredRemoval();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btOverlappingPairCache_setInternalGhostPairCallback (btOverlappingPairCache *larg1, btOverlappingPairCallback *larg2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalGhostPairCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOverlappingPairCache_sortOverlappingPairs (btOverlappingPairCache *larg1, btDispatcher *larg2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->sortOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btHashedOverlappingPairCache *_wrap_new_btHashedOverlappingPairCache () {
  btHashedOverlappingPairCache * lresult = (btHashedOverlappingPairCache *)0 ;
  btHashedOverlappingPairCache *result = 0 ;
  
  try {
    result = (btHashedOverlappingPairCache *)new btHashedOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHashedOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_delete_btHashedOverlappingPairCache (btHashedOverlappingPairCache *larg1) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btHashedOverlappingPairCache_removeOverlappingPair (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3, btDispatcher *larg4) {
  void * lresult = (void *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btHashedOverlappingPairCache_needsBroadphaseCollision (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  int lresult = (int)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btHashedOverlappingPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphasePair *_wrap_btHashedOverlappingPairCache_addOverlappingPair (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT void _wrap_btHashedOverlappingPairCache_cleanProxyFromPairs (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanProxyFromPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHashedOverlappingPairCache_processAllOverlappingPairs (btHashedOverlappingPairCache *larg1, btOverlapCallback *larg2, btDispatcher *larg3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processAllOverlappingPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btHashedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0 (btHashedOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btHashedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1 (btHashedOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)((btHashedOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_0 (btHashedOverlappingPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_1 (btHashedOverlappingPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &((btHashedOverlappingPairCache const *)arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT void _wrap_btHashedOverlappingPairCache_cleanOverlappingPair (btHashedOverlappingPairCache *larg1, btBroadphasePair *larg2, btDispatcher *larg3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanOverlappingPair(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btHashedOverlappingPairCache_findPair (btHashedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT int _wrap_btHashedOverlappingPairCache_GetCount (btHashedOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHashedOverlappingPairCache const *)arg1)->GetCount();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btOverlapFilterCallback *_wrap_btHashedOverlappingPairCache_getOverlapFilterCallback (btHashedOverlappingPairCache *larg1) {
  btOverlapFilterCallback * lresult = (btOverlapFilterCallback *)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlapFilterCallback *)0;
  }
}


EXPORT void _wrap_btHashedOverlappingPairCache_setOverlapFilterCallback (btHashedOverlappingPairCache *larg1, btOverlapFilterCallback *larg2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverlapFilterCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btHashedOverlappingPairCache_getNumOverlappingPairs (btHashedOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHashedOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btSortedOverlappingPairCache *_wrap_new_btSortedOverlappingPairCache () {
  btSortedOverlappingPairCache * lresult = (btSortedOverlappingPairCache *)0 ;
  btSortedOverlappingPairCache *result = 0 ;
  
  try {
    result = (btSortedOverlappingPairCache *)new btSortedOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSortedOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_delete_btSortedOverlappingPairCache (btSortedOverlappingPairCache *larg1) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_processAllOverlappingPairs (btSortedOverlappingPairCache *larg1, btOverlapCallback *larg2, btDispatcher *larg3) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processAllOverlappingPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btSortedOverlappingPairCache_removeOverlappingPair (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3, btDispatcher *larg4) {
  void * lresult = (void *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_cleanOverlappingPair (btSortedOverlappingPairCache *larg1, btBroadphasePair *larg2, btDispatcher *larg3) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanOverlappingPair(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btSortedOverlappingPairCache_addOverlappingPair (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btSortedOverlappingPairCache_findPair (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_cleanProxyFromPairs (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanProxyFromPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSortedOverlappingPairCache_needsBroadphaseCollision (btSortedOverlappingPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  int lresult = (int)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btSortedOverlappingPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_0 (btSortedOverlappingPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_1 (btSortedOverlappingPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &((btSortedOverlappingPairCache const *)arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btSortedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0 (btSortedOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btSortedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1 (btSortedOverlappingPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)((btSortedOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT int _wrap_btSortedOverlappingPairCache_getNumOverlappingPairs (btSortedOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSortedOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btOverlapFilterCallback *_wrap_btSortedOverlappingPairCache_getOverlapFilterCallback (btSortedOverlappingPairCache *larg1) {
  btOverlapFilterCallback * lresult = (btOverlapFilterCallback *)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlapFilterCallback *)0;
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_setOverlapFilterCallback (btSortedOverlappingPairCache *larg1, btOverlapFilterCallback *larg2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverlapFilterCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSortedOverlappingPairCache_hasDeferredRemoval (btSortedOverlappingPairCache *larg1) {
  int lresult = (int)0 ;
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->hasDeferredRemoval();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_setInternalGhostPairCallback (btSortedOverlappingPairCache *larg1, btOverlappingPairCallback *larg2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalGhostPairCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSortedOverlappingPairCache_sortOverlappingPairs (btSortedOverlappingPairCache *larg1, btDispatcher *larg2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->sortOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btNullPairCache_getOverlappingPairArrayPtr__SWIG_0 (btNullPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePair *_wrap_btNullPairCache_getOverlappingPairArrayPtr__SWIG_1 (btNullPairCache *larg1) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePair *)((btNullPairCache const *)arg1)->getOverlappingPairArrayPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT btBroadphasePairArray *_wrap_btNullPairCache_getOverlappingPairArray (btNullPairCache *larg1) {
  btBroadphasePairArray * lresult = (btBroadphasePairArray *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairArray *)0;
  }
}


EXPORT void _wrap_btNullPairCache_cleanOverlappingPair (btNullPairCache *larg1, btBroadphasePair *larg2, btDispatcher *larg3) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanOverlappingPair(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btNullPairCache_getNumOverlappingPairs (btNullPairCache *larg1) {
  int lresult = (int)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btNullPairCache const *)arg1)->getNumOverlappingPairs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btNullPairCache_cleanProxyFromPairs (btNullPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->cleanProxyFromPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btNullPairCache_setOverlapFilterCallback (btNullPairCache *larg1, btOverlapFilterCallback *larg2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverlapFilterCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btNullPairCache_processAllOverlappingPairs (btNullPairCache *larg1, btOverlapCallback *larg2, btDispatcher *larg3) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processAllOverlappingPairs(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btNullPairCache_findPair (btNullPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT int _wrap_btNullPairCache_hasDeferredRemoval (btNullPairCache *larg1) {
  int lresult = (int)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->hasDeferredRemoval();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btNullPairCache_setInternalGhostPairCallback (btNullPairCache *larg1, btOverlappingPairCallback *larg2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalGhostPairCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btNullPairCache_addOverlappingPair (btNullPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT void *_wrap_btNullPairCache_removeOverlappingPair (btNullPairCache *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3, btDispatcher *larg4) {
  void * lresult = (void *)0 ;
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btNullPairCache_removeOverlappingPairsContainingProxy (btNullPairCache *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btNullPairCache_sortOverlappingPairs (btNullPairCache *larg1, btDispatcher *larg2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->sortOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btNullPairCache *_wrap_new_btNullPairCache () {
  btNullPairCache * lresult = (btNullPairCache *)0 ;
  btNullPairCache *result = 0 ;
  
  try {
    result = (btNullPairCache *)new btNullPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btNullPairCache *)0;
  }
}


EXPORT void _wrap_delete_btNullPairCache (btNullPairCache *larg1) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionWorld *_wrap_new_btCollisionWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btCollisionConfiguration *larg3) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btCollisionConfiguration *arg3 = (btCollisionConfiguration *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionWorld *)new btCollisionWorld(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_delete_btCollisionWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setBroadphase (btCollisionWorld *larg1, btBroadphaseInterface *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_0 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)((btCollisionWorld const *)arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_1 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)(arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btCollisionWorld_getPairCache (btCollisionWorld *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)(arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)((btCollisionWorld const *)arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_updateSingleAabb (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateSingleAabb(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_updateAabbs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_computeOverlappingPairs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->computeOverlappingPairs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setDebugDrawer (btCollisionWorld *larg1, btIDebugDraw *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDebugDrawer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btIDebugDraw *_wrap_btCollisionWorld_getDebugDrawer (btCollisionWorld *larg1) {
  btIDebugDraw * lresult = (btIDebugDraw *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btIDebugDraw *)(arg1)->getDebugDrawer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btIDebugDraw *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawObject (btCollisionWorld *larg1, btTransform *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionWorld_getNumCollisionObjects (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionWorld const *)arg1)->getNumCollisionObjects();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_rayTest (btCollisionWorld *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_0 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_1 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionWorld::ContactResultCallback *larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->contactTest(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactPairTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionObject *larg3, btCollisionWorld::ContactResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->contactPairTest(arg2,arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingle (btTransform *larg1, btTransform *larg2, btCollisionObject *larg3, btCollisionShape *larg4, btTransform *larg5, btCollisionWorld::RayResultCallback *larg6) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingleInternal (btTransform *larg1, btTransform *larg2, btCollisionObjectWrapper *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingle (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObject *larg4, btCollisionShape *larg5, btTransform *larg6, btCollisionWorld::ConvexResultCallback *larg7, btScalar larg8) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingleInternal (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObjectWrapper *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_0 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_1 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_2 (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_0 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &(arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_1 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &((btCollisionWorld const *)arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_removeCollisionObject (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_performDiscreteCollisionDetection (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->performDiscreteCollisionDetection();
    
  } catch (...) {
    
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &(arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &((btCollisionWorld const *)arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT int _wrap_btCollisionWorld_getForceUpdateAllAabbs (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionWorld const *)arg1)->getForceUpdateAllAabbs();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_setForceUpdateAllAabbs (btCollisionWorld *larg1, int larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setForceUpdateAllAabbs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_serialize (btCollisionWorld *larg1, btSerializer *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionShape (btCollisionShape *larg1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getBoundingSphere (btCollisionShape *larg1, btVector3 *larg2, btScalar *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getAngularMotionDisc (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionShape_getContactBreakingThreshold (btCollisionShape *larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateTemporalAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btVector3 *larg6, btVector3 *larg7) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionShape_isPolyhedral (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex2d (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isNonMoving (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConcave (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConcave();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isCompound (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isCompound();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isSoftBody (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isInfinite (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isInfinite();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionShape_setLocalScaling (btCollisionShape *larg1, btVector3 *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getLocalScaling (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateLocalInertia (btCollisionShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCollisionShape_getName (btCollisionShape *larg1) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCollisionShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCollisionShape_getShapeType (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->getShapeType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_setMargin (btCollisionShape *larg1, btScalar larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getMargin (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_setUserPointer (btCollisionShape *larg1, void *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionShape_getUserPointer (btCollisionShape *larg1) {
  void * lresult = (void *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btCollisionShape_calculateSerializeBufferSize (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionShape_serialize (btCollisionShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionShape_serializeSingleShape (btCollisionShape *larg1, btSerializer *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexShape (btConvexShape *larg1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertex (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btConvexShape_getMarginNonVirtual (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConvexShape_getAabbNonVirtual (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_project (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabb (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabbSlow (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_setLocalScaling (btConvexShape *larg1, btVector3 *larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_getLocalScaling (btConvexShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexShape_setMargin (btConvexShape *larg1, btScalar larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexShape_getMargin (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexShape_getNumPreferredPenetrationDirections (btConvexShape *larg1) {
  int lresult = (int)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexShape_getPreferredPenetrationDirection (btConvexShape *larg1, int larg2, btVector3 *larg3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_AabbExpand (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    AabbExpand(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_TestPointAgainstAabb2 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  int lresult = (int)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)TestPointAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_TestAabbAgainstAabb2 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  int lresult = (int)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bool)TestAabbAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_TestTriangleAgainstAabb2 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)TestTriangleAgainstAabb2((btVector3 const *)arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btOutcode (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)btOutcode((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRayAabb2 (btVector3 *larg1, btVector3 *larg2, unsigned int *larg3, btVector3 *larg4, btScalar *larg5, btScalar larg6, btScalar larg7) {
  int lresult = (int)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int *arg3 ;
  btVector3 *arg4 ;
  btScalar *arg5 = 0 ;
  btScalar arg6 ;
  btScalar arg7 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    result = (bool)btRayAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(unsigned int const (*))arg3,(btVector3 const (*))arg4,*arg5,arg6,arg7);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRayAabb (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar *larg5, btVector3 *larg6) {
  int lresult = (int)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (bool)btRayAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,*arg5,*arg6);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTransformAabb__SWIG_0 (btVector3 *larg1, btScalar larg2, btTransform *larg3, btVector3 *larg4, btVector3 *larg5) {
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    btTransformAabb((btVector3 const &)*arg1,arg2,(btTransform const &)*arg3,*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransformAabb__SWIG_1 (btVector3 *larg1, btVector3 *larg2, btScalar larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btTransformAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT unsigned int _wrap_testQuantizedAabbAgainstQuantizedAabb (unsigned short *larg1, unsigned short *larg2, unsigned short *larg3, unsigned short *larg4) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned short *arg1 = (unsigned short *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  unsigned short *arg3 = (unsigned short *) 0 ;
  unsigned short *arg4 = (unsigned short *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (unsigned int)testQuantizedAabbAgainstQuantizedAabb((unsigned short const *)arg1,(unsigned short const *)arg2,(unsigned short const *)arg3,(unsigned short const *)arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT void _wrap_delete_btConvexInternalShape (btConvexInternalShape *larg1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex (btConvexInternalShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setImplicitShapeDimensions (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0 (btConvexInternalShape *larg1, btScalar larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1 (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2 (btConvexInternalShape *larg1, btVector3 *larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3 (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabb (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabbSlow (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setLocalScaling (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScaling (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setMargin (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMargin (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMarginNV (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_getPreferredPenetrationDirection (btConvexInternalShape *larg1, int larg2, btVector3 *larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexInternalShape_calculateSerializeBufferSize (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexInternalShape_serialize (btConvexInternalShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_setLocalScaling (btConvexInternalAabbCachingShape *larg1, btVector3 *larg2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_getAabb (btConvexInternalAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexInternalAabbCachingShape (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexShape (btPolyhedralConvexShape *larg1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0 (btPolyhedralConvexShape *larg1, int larg2) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1 (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron (btPolyhedralConvexShape *larg1) {
  btConvexPolyhedron * lresult = (btConvexPolyhedron *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexPolyhedron *)0;
  }
}


EXPORT btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_calculateLocalInertia (btPolyhedralConvexShape *larg1, btScalar larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumVertices (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumEdges (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getEdge (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getVertex (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumPlanes (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getPlane (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_isInside (btPolyhedralConvexShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling (btPolyhedralConvexAabbCachingShape *larg1, btVector3 *larg2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexAabbCachingShape (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertex (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btBoxShape *_wrap_new_btBoxShape (btVector3 *larg1) {
  btBoxShape * lresult = (btBoxShape *)0 ;
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBoxShape *)0;
  }
}


EXPORT void _wrap_btBoxShape_setMargin (btBoxShape *larg1, btScalar larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_setLocalScaling (btBoxShape *larg1, btVector3 *larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getAabb (btBoxShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_calculateLocalInertia (btBoxShape *larg1, btScalar larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlane (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_getNumPlanes (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumVertices (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumEdges (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getVertex (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlaneEquation (btBoxShape *larg1, btVector4 *larg2, int larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getEdge (btBoxShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_isInside (btBoxShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btBoxShape_getName (btBoxShape *larg1) {
  char * lresult = (char *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btBoxShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumPreferredPenetrationDirections (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getPreferredPenetrationDirection (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBoxShape (btBoxShape *larg1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSphereShape *_wrap_new_btSphereShape (btScalar larg1) {
  btSphereShape * lresult = (btSphereShape *)0 ;
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSphereShape *)new btSphereShape(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSphereShape *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertex (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_calculateLocalInertia (btSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_getAabb (btSphereShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getRadius (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSphereShape_setUnscaledRadius (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUnscaledRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btSphereShape_getName (btSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btSphereShape_setMargin (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getMargin (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btSphereShape (btSphereShape *larg1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShape *_wrap_new_btCapsuleShape__SWIG_1 (btScalar larg1, btScalar larg2) {
  btCapsuleShape * lresult = (btCapsuleShape *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShape *)new btCapsuleShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShape *)0;
  }
}


EXPORT void _wrap_btCapsuleShape_calculateLocalInertia (btCapsuleShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCapsuleShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCapsuleShape_localGetSupportingVertexWithoutMargin (btCapsuleShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCapsuleShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btCapsuleShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCapsuleShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCapsuleShape_setMargin (btCapsuleShape *larg1, btScalar larg2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCapsuleShape_getAabb (btCapsuleShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCapsuleShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCapsuleShape_getName (btCapsuleShape *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCapsuleShape_getUpAxis (btCapsuleShape *larg1) {
  int lresult = (int)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCapsuleShape const *)arg1)->getUpAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btCapsuleShape_getRadius (btCapsuleShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCapsuleShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCapsuleShape_getHalfHeight (btCapsuleShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCapsuleShape const *)arg1)->getHalfHeight();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCapsuleShape_setLocalScaling (btCapsuleShape *larg1, btVector3 *larg2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCapsuleShape_getAnisotropicRollingFrictionDirection (btCapsuleShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCapsuleShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCapsuleShape_calculateSerializeBufferSize (btCapsuleShape *larg1) {
  int lresult = (int)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCapsuleShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCapsuleShape_serialize (btCapsuleShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCapsuleShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShape (btCapsuleShape *larg1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShapeX *_wrap_new_btCapsuleShapeX (btScalar larg1, btScalar larg2) {
  btCapsuleShapeX * lresult = (btCapsuleShapeX *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeX *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShapeX *)new btCapsuleShapeX(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShapeX *)0;
  }
}


EXPORT char *_wrap_btCapsuleShapeX_getName (btCapsuleShapeX *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShapeX const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShapeX (btCapsuleShapeX *larg1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShapeZ *_wrap_new_btCapsuleShapeZ (btScalar larg1, btScalar larg2) {
  btCapsuleShapeZ * lresult = (btCapsuleShapeZ *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeZ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShapeZ *)new btCapsuleShapeZ(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShapeZ *)0;
  }
}


EXPORT char *_wrap_btCapsuleShapeZ_getName (btCapsuleShapeZ *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShapeZ const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShapeZ (btCapsuleShapeZ *larg1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCylinderShape_getHalfExtentsWithMargin (btCylinderShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCylinderShape const *)arg1)->getHalfExtentsWithMargin();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btCylinderShape_getHalfExtentsWithoutMargin (btCylinderShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCylinderShape const *)arg1)->getHalfExtentsWithoutMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btCylinderShape *_wrap_new_btCylinderShape (btVector3 *larg1) {
  btCylinderShape * lresult = (btCylinderShape *)0 ;
  btVector3 *arg1 = 0 ;
  btCylinderShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCylinderShape *)new btCylinderShape((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCylinderShape *)0;
  }
}


EXPORT void _wrap_btCylinderShape_getAabb (btCylinderShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCylinderShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCylinderShape_calculateLocalInertia (btCylinderShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCylinderShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCylinderShape_localGetSupportingVertexWithoutMargin (btCylinderShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCylinderShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCylinderShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btCylinderShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCylinderShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCylinderShape_setMargin (btCylinderShape *larg1, btScalar larg2) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCylinderShape_localGetSupportingVertex (btCylinderShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCylinderShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCylinderShape_getUpAxis (btCylinderShape *larg1) {
  int lresult = (int)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCylinderShape const *)arg1)->getUpAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCylinderShape_getAnisotropicRollingFrictionDirection (btCylinderShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCylinderShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btCylinderShape_getRadius (btCylinderShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCylinderShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCylinderShape_setLocalScaling (btCylinderShape *larg1, btVector3 *larg2) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCylinderShape_getName (btCylinderShape *larg1) {
  char * lresult = (char *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCylinderShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCylinderShape_calculateSerializeBufferSize (btCylinderShape *larg1) {
  int lresult = (int)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCylinderShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCylinderShape_serialize (btCylinderShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCylinderShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCylinderShape (btCylinderShape *larg1) {
  btCylinderShape *arg1 = (btCylinderShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCylinderShapeX *_wrap_new_btCylinderShapeX (btVector3 *larg1) {
  btCylinderShapeX * lresult = (btCylinderShapeX *)0 ;
  btVector3 *arg1 = 0 ;
  btCylinderShapeX *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCylinderShapeX *)new btCylinderShapeX((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCylinderShapeX *)0;
  }
}


EXPORT btVector3 *_wrap_btCylinderShapeX_localGetSupportingVertexWithoutMargin (btCylinderShapeX *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShapeX *arg1 = (btCylinderShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCylinderShapeX const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCylinderShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin (btCylinderShapeX *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btCylinderShapeX *arg1 = (btCylinderShapeX *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCylinderShapeX const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCylinderShapeX_getName (btCylinderShapeX *larg1) {
  char * lresult = (char *)0 ;
  btCylinderShapeX *arg1 = (btCylinderShapeX *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCylinderShapeX const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btScalar _wrap_btCylinderShapeX_getRadius (btCylinderShapeX *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCylinderShapeX *arg1 = (btCylinderShapeX *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCylinderShapeX const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btCylinderShapeX (btCylinderShapeX *larg1) {
  btCylinderShapeX *arg1 = (btCylinderShapeX *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCylinderShapeZ *_wrap_new_btCylinderShapeZ (btVector3 *larg1) {
  btCylinderShapeZ * lresult = (btCylinderShapeZ *)0 ;
  btVector3 *arg1 = 0 ;
  btCylinderShapeZ *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCylinderShapeZ *)new btCylinderShapeZ((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCylinderShapeZ *)0;
  }
}


EXPORT btVector3 *_wrap_btCylinderShapeZ_localGetSupportingVertexWithoutMargin (btCylinderShapeZ *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCylinderShapeZ *arg1 = (btCylinderShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCylinderShapeZ const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCylinderShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin (btCylinderShapeZ *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btCylinderShapeZ *arg1 = (btCylinderShapeZ *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCylinderShapeZ const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCylinderShapeZ_getName (btCylinderShapeZ *larg1) {
  char * lresult = (char *)0 ;
  btCylinderShapeZ *arg1 = (btCylinderShapeZ *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCylinderShapeZ const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btScalar _wrap_btCylinderShapeZ_getRadius (btCylinderShapeZ *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCylinderShapeZ *arg1 = (btCylinderShapeZ *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCylinderShapeZ const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btCylinderShapeZ (btCylinderShapeZ *larg1) {
  btCylinderShapeZ *arg1 = (btCylinderShapeZ *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeShape *_wrap_new_btConeShape (btScalar larg1, btScalar larg2) {
  btConeShape * lresult = (btConeShape *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btConeShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeShape *)new btConeShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeShape *)0;
  }
}


EXPORT btVector3 *_wrap_btConeShape_localGetSupportingVertex (btConeShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConeShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConeShape_localGetSupportingVertexWithoutMargin (btConeShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConeShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConeShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConeShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConeShape *arg1 = (btConeShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConeShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeShape_getRadius (btConeShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConeShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeShape_getHeight (btConeShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConeShape const *)arg1)->getHeight();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeShape_calculateLocalInertia (btConeShape *larg1, btScalar larg2, btVector3 *larg3) {
  btConeShape *arg1 = (btConeShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConeShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btConeShape_getName (btConeShape *larg1) {
  char * lresult = (char *)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConeShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btConeShape_setConeUpIndex (btConeShape *larg1, int larg2) {
  btConeShape *arg1 = (btConeShape *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConeUpIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConeShape_getConeUpIndex (btConeShape *larg1) {
  int lresult = (int)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConeShape const *)arg1)->getConeUpIndex();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btConeShape_getAnisotropicRollingFrictionDirection (btConeShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btConeShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConeShape_setLocalScaling (btConeShape *larg1, btVector3 *larg2) {
  btConeShape *arg1 = (btConeShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConeShape_calculateSerializeBufferSize (btConeShape *larg1) {
  int lresult = (int)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConeShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConeShape_serialize (btConeShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConeShape *arg1 = (btConeShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConeShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeShape (btConeShape *larg1) {
  btConeShape *arg1 = (btConeShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeShapeX *_wrap_new_btConeShapeX (btScalar larg1, btScalar larg2) {
  btConeShapeX * lresult = (btConeShapeX *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btConeShapeX *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeShapeX *)new btConeShapeX(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeShapeX *)0;
  }
}


EXPORT btVector3 *_wrap_btConeShapeX_getAnisotropicRollingFrictionDirection (btConeShapeX *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeShapeX *arg1 = (btConeShapeX *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btConeShapeX const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT char *_wrap_btConeShapeX_getName (btConeShapeX *larg1) {
  char * lresult = (char *)0 ;
  btConeShapeX *arg1 = (btConeShapeX *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConeShapeX const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeShapeX (btConeShapeX *larg1) {
  btConeShapeX *arg1 = (btConeShapeX *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeShapeZ *_wrap_new_btConeShapeZ (btScalar larg1, btScalar larg2) {
  btConeShapeZ * lresult = (btConeShapeZ *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btConeShapeZ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeShapeZ *)new btConeShapeZ(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeShapeZ *)0;
  }
}


EXPORT btVector3 *_wrap_btConeShapeZ_getAnisotropicRollingFrictionDirection (btConeShapeZ *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeShapeZ *arg1 = (btConeShapeZ *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btConeShapeZ const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT char *_wrap_btConeShapeZ_getName (btConeShapeZ *larg1) {
  char * lresult = (char *)0 ;
  btConeShapeZ *arg1 = (btConeShapeZ *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConeShapeZ const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeShapeZ (btConeShapeZ *larg1) {
  btConeShapeZ *arg1 = (btConeShapeZ *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTriangleCallback (btTriangleCallback *larg1) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleCallback_processTriangle (btTriangleCallback *larg1, btVector3 *larg2, int larg3, int larg4) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->processTriangle(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btInternalTriangleIndexCallback (btInternalTriangleIndexCallback *larg1) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btInternalTriangleIndexCallback_internalProcessTriangleIndex (btInternalTriangleIndexCallback *larg1, btVector3 *larg2, int larg3, int larg4) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->internalProcessTriangleIndex(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConcaveShape (btConcaveShape *larg1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConcaveShape_processAllTriangles (btConcaveShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConcaveShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConcaveShape_getMargin (btConcaveShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConcaveShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConcaveShape_setMargin (btConcaveShape *larg1, btScalar larg2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btStaticPlaneShape *_wrap_new_btStaticPlaneShape (btVector3 *larg1, btScalar larg2) {
  btStaticPlaneShape * lresult = (btStaticPlaneShape *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btStaticPlaneShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btStaticPlaneShape *)new btStaticPlaneShape((btVector3 const &)*arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStaticPlaneShape *)0;
  }
}


EXPORT void _wrap_delete_btStaticPlaneShape (btStaticPlaneShape *larg1) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_getAabb (btStaticPlaneShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_processAllTriangles (btStaticPlaneShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_calculateLocalInertia (btStaticPlaneShape *larg1, btScalar larg2, btVector3 *larg3) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btStaticPlaneShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_setLocalScaling (btStaticPlaneShape *larg1, btVector3 *larg2) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getLocalScaling (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getPlaneNormal (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getPlaneNormal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btStaticPlaneShape_getPlaneConstant (btStaticPlaneShape *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btStaticPlaneShape const *)arg1)->getPlaneConstant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_getName (btStaticPlaneShape *larg1) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btStaticPlaneShape_calculateSerializeBufferSize (btStaticPlaneShape *larg1) {
  int lresult = (int)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btStaticPlaneShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_serialize (btStaticPlaneShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_0 (btScalar *larg1, int larg2, int larg3) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  int arg3 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_1 (btScalar *larg1, int larg2) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_2 (btScalar *larg1) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_3 () {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btConvexHullShape *result = 0 ;
  
  try {
    result = (btConvexHullShape *)new btConvexHullShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_0 (btConvexHullShape *larg1, btVector3 *larg2, int larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_1 (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_0 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)(arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_1 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getPoints (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getScaledPoint (btConvexHullShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->getScaledPoint(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPoints (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertex (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_project (btConvexHullShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5, btVector3 *larg6, btVector3 *larg7) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btConvexHullShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btConvexHullShape_getName (btConvexHullShape *larg1) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumVertices (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumEdges (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getEdge (btConvexHullShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_getVertex (btConvexHullShape *larg1, int larg2, btVector3 *larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexHullShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPlanes (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getPlane (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_isInside (btConvexHullShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btConvexHullShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_setLocalScaling (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_calculateSerializeBufferSize (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexHullShape_serialize (btConvexHullShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConvexHullShape (btConvexHullShape *larg1) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btStridingMeshInterface (btStridingMeshInterface *larg1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_InternalProcessAllTriangles (btStridingMeshInterface *larg1, btInternalTriangleIndexCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btInternalTriangleIndexCallback *arg2 = (btInternalTriangleIndexCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStridingMeshInterface const *)arg1)->InternalProcessAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_calculateAabbBruteForce (btStridingMeshInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateAabbBruteForce(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_getLockedVertexIndexBase__SWIG_0 (btStridingMeshInterface *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9, int larg10) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9,arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_getLockedVertexIndexBase__SWIG_1 (btStridingMeshInterface *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_getLockedReadOnlyVertexIndexBase__SWIG_0 (btStridingMeshInterface *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9, int larg10) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    ((btStridingMeshInterface const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9,arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_getLockedReadOnlyVertexIndexBase__SWIG_1 (btStridingMeshInterface *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    ((btStridingMeshInterface const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_unLockVertexBase (btStridingMeshInterface *larg1, int larg2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->unLockVertexBase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_unLockReadOnlyVertexBase (btStridingMeshInterface *larg1, int larg2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btStridingMeshInterface const *)arg1)->unLockReadOnlyVertexBase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btStridingMeshInterface_getNumSubParts (btStridingMeshInterface *larg1) {
  int lresult = (int)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btStridingMeshInterface const *)arg1)->getNumSubParts();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btStridingMeshInterface_preallocateVertices (btStridingMeshInterface *larg1, int larg2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateVertices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_preallocateIndices (btStridingMeshInterface *larg1, int larg2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateIndices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btStridingMeshInterface_hasPremadeAabb (btStridingMeshInterface *larg1) {
  int lresult = (int)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btStridingMeshInterface const *)arg1)->hasPremadeAabb();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btStridingMeshInterface_setPremadeAabb (btStridingMeshInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btStridingMeshInterface const *)arg1)->setPremadeAabb((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStridingMeshInterface_getPremadeAabb (btStridingMeshInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btStridingMeshInterface const *)arg1)->getPremadeAabb(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btStridingMeshInterface_getScaling (btStridingMeshInterface *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStridingMeshInterface const *)arg1)->getScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btStridingMeshInterface_setScaling (btStridingMeshInterface *larg1, btVector3 *larg2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btStridingMeshInterface_calculateSerializeBufferSize (btStridingMeshInterface *larg1) {
  int lresult = (int)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btStridingMeshInterface const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btStridingMeshInterface_serialize (btStridingMeshInterface *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btStridingMeshInterface const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btTriangleIndexVertexArray *_wrap_new_btTriangleIndexVertexArray__SWIG_0 () {
  btTriangleIndexVertexArray * lresult = (btTriangleIndexVertexArray *)0 ;
  btTriangleIndexVertexArray *result = 0 ;
  
  try {
    result = (btTriangleIndexVertexArray *)new btTriangleIndexVertexArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleIndexVertexArray *)0;
  }
}


EXPORT void _wrap_delete_btTriangleIndexVertexArray (btTriangleIndexVertexArray *larg1) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btTriangleIndexVertexArray *_wrap_new_btTriangleIndexVertexArray__SWIG_1 (int larg1, int *larg2, int larg3, int larg4, btScalar *larg5, int larg6) {
  btTriangleIndexVertexArray * lresult = (btTriangleIndexVertexArray *)0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar *arg5 = (btScalar *) 0 ;
  int arg6 ;
  btTriangleIndexVertexArray *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btTriangleIndexVertexArray *)new btTriangleIndexVertexArray(arg1,arg2,arg3,arg4,arg5,arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleIndexVertexArray *)0;
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_addIndexedMesh__SWIG_0 (btTriangleIndexVertexArray *larg1, btIndexedMesh *larg2, PHY_ScalarType larg3) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  btIndexedMesh *arg2 = 0 ;
  PHY_ScalarType arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addIndexedMesh((btIndexedMesh const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_addIndexedMesh__SWIG_1 (btTriangleIndexVertexArray *larg1, btIndexedMesh *larg2) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  btIndexedMesh *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addIndexedMesh((btIndexedMesh const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_getLockedVertexIndexBase__SWIG_0 (btTriangleIndexVertexArray *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9, int larg10) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9,arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_getLockedVertexIndexBase__SWIG_1 (btTriangleIndexVertexArray *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_getLockedReadOnlyVertexIndexBase__SWIG_0 (btTriangleIndexVertexArray *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9, int larg10) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    ((btTriangleIndexVertexArray const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9,arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_getLockedReadOnlyVertexIndexBase__SWIG_1 (btTriangleIndexVertexArray *larg1, unsigned char **larg2, int *larg3, PHY_ScalarType *larg4, int *larg5, unsigned char **larg6, int *larg7, int *larg8, PHY_ScalarType *larg9) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    ((btTriangleIndexVertexArray const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_unLockVertexBase (btTriangleIndexVertexArray *larg1, int larg2) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->unLockVertexBase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_unLockReadOnlyVertexBase (btTriangleIndexVertexArray *larg1, int larg2) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTriangleIndexVertexArray const *)arg1)->unLockReadOnlyVertexBase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTriangleIndexVertexArray_getNumSubParts (btTriangleIndexVertexArray *larg1) {
  int lresult = (int)0 ;
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTriangleIndexVertexArray const *)arg1)->getNumSubParts();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT IndexedMeshArray *_wrap_btTriangleIndexVertexArray_getIndexedMeshArray__SWIG_0 (btTriangleIndexVertexArray *larg1) {
  IndexedMeshArray * lresult = (IndexedMeshArray *)0 ;
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  IndexedMeshArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (IndexedMeshArray *) &(arg1)->getIndexedMeshArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (IndexedMeshArray *)0;
  }
}


EXPORT IndexedMeshArray *_wrap_btTriangleIndexVertexArray_getIndexedMeshArray__SWIG_1 (btTriangleIndexVertexArray *larg1) {
  IndexedMeshArray * lresult = (IndexedMeshArray *)0 ;
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  IndexedMeshArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (IndexedMeshArray *) &((btTriangleIndexVertexArray const *)arg1)->getIndexedMeshArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (IndexedMeshArray *)0;
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_preallocateVertices (btTriangleIndexVertexArray *larg1, int larg2) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateVertices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_preallocateIndices (btTriangleIndexVertexArray *larg1, int larg2) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateIndices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTriangleIndexVertexArray_hasPremadeAabb (btTriangleIndexVertexArray *larg1) {
  int lresult = (int)0 ;
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTriangleIndexVertexArray const *)arg1)->hasPremadeAabb();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_setPremadeAabb (btTriangleIndexVertexArray *larg1, btVector3 *larg2, btVector3 *larg3) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btTriangleIndexVertexArray const *)arg1)->setPremadeAabb((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleIndexVertexArray_getPremadeAabb (btTriangleIndexVertexArray *larg1, btVector3 *larg2, btVector3 *larg3) {
  btTriangleIndexVertexArray *arg1 = (btTriangleIndexVertexArray *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btTriangleIndexVertexArray const *)arg1)->getPremadeAabb(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMesh_m_weldingThreshold_set (btTriangleMesh *larg1, btScalar larg2) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_weldingThreshold = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTriangleMesh_m_weldingThreshold_get (btTriangleMesh *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_weldingThreshold);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btTriangleMesh *_wrap_new_btTriangleMesh__SWIG_0 (int larg1, int larg2) {
  btTriangleMesh * lresult = (btTriangleMesh *)0 ;
  bool arg1 ;
  bool arg2 ;
  btTriangleMesh *result = 0 ;
  
  arg1 = (bool)larg1;
  arg2 = (bool)larg2;
  try {
    result = (btTriangleMesh *)new btTriangleMesh(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleMesh *)0;
  }
}


EXPORT btTriangleMesh *_wrap_new_btTriangleMesh__SWIG_1 (int larg1) {
  btTriangleMesh * lresult = (btTriangleMesh *)0 ;
  bool arg1 ;
  btTriangleMesh *result = 0 ;
  
  arg1 = (bool)larg1;
  try {
    result = (btTriangleMesh *)new btTriangleMesh(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleMesh *)0;
  }
}


EXPORT btTriangleMesh *_wrap_new_btTriangleMesh__SWIG_2 () {
  btTriangleMesh * lresult = (btTriangleMesh *)0 ;
  btTriangleMesh *result = 0 ;
  
  try {
    result = (btTriangleMesh *)new btTriangleMesh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleMesh *)0;
  }
}


EXPORT int _wrap_btTriangleMesh_getUse32bitIndices (btTriangleMesh *larg1) {
  int lresult = (int)0 ;
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTriangleMesh const *)arg1)->getUse32bitIndices();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTriangleMesh_getUse4componentVertices (btTriangleMesh *larg1) {
  int lresult = (int)0 ;
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTriangleMesh const *)arg1)->getUse4componentVertices();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTriangleMesh_addTriangle__SWIG_0 (btTriangleMesh *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, int larg5) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    (arg1)->addTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMesh_addTriangle__SWIG_1 (btTriangleMesh *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTriangleMesh_getNumTriangles (btTriangleMesh *larg1) {
  int lresult = (int)0 ;
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTriangleMesh const *)arg1)->getNumTriangles();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTriangleMesh_preallocateVertices (btTriangleMesh *larg1, int larg2) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateVertices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMesh_preallocateIndices (btTriangleMesh *larg1, int larg2) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->preallocateIndices(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTriangleMesh_findOrAddVertex (btTriangleMesh *larg1, btVector3 *larg2, int larg3) {
  int lresult = (int)0 ;
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  btVector3 *arg2 = 0 ;
  bool arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (int)(arg1)->findOrAddVertex((btVector3 const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTriangleMesh_addIndex (btTriangleMesh *larg1, int larg2) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTriangleMesh (btTriangleMesh *larg1) {
  btTriangleMesh *arg1 = (btTriangleMesh *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConvexTriangleMeshShape *_wrap_new_btConvexTriangleMeshShape__SWIG_0 (btStridingMeshInterface *larg1, int larg2) {
  btConvexTriangleMeshShape * lresult = (btConvexTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btConvexTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    result = (btConvexTriangleMeshShape *)new btConvexTriangleMeshShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexTriangleMeshShape *)0;
  }
}


EXPORT btConvexTriangleMeshShape *_wrap_new_btConvexTriangleMeshShape__SWIG_1 (btStridingMeshInterface *larg1) {
  btConvexTriangleMeshShape * lresult = (btConvexTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btConvexTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexTriangleMeshShape *)new btConvexTriangleMeshShape(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexTriangleMeshShape *)0;
  }
}


EXPORT btStridingMeshInterface *_wrap_btConvexTriangleMeshShape_getMeshInterface__SWIG_0 (btConvexTriangleMeshShape *larg1) {
  btStridingMeshInterface * lresult = (btStridingMeshInterface *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btStridingMeshInterface *)(arg1)->getMeshInterface();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStridingMeshInterface *)0;
  }
}


EXPORT btStridingMeshInterface *_wrap_btConvexTriangleMeshShape_getMeshInterface__SWIG_1 (btConvexTriangleMeshShape *larg1) {
  btStridingMeshInterface * lresult = (btStridingMeshInterface *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btStridingMeshInterface *)((btConvexTriangleMeshShape const *)arg1)->getMeshInterface();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStridingMeshInterface *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexTriangleMeshShape_localGetSupportingVertex (btConvexTriangleMeshShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexTriangleMeshShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin (btConvexTriangleMeshShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexTriangleMeshShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexTriangleMeshShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexTriangleMeshShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btConvexTriangleMeshShape_getName (btConvexTriangleMeshShape *larg1) {
  char * lresult = (char *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConvexTriangleMeshShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btConvexTriangleMeshShape_getNumVertices (btConvexTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexTriangleMeshShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConvexTriangleMeshShape_getNumEdges (btConvexTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexTriangleMeshShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_getEdge (btConvexTriangleMeshShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexTriangleMeshShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_getVertex (btConvexTriangleMeshShape *larg1, int larg2, btVector3 *larg3) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexTriangleMeshShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexTriangleMeshShape_getNumPlanes (btConvexTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexTriangleMeshShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_getPlane (btConvexTriangleMeshShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexTriangleMeshShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexTriangleMeshShape_isInside (btConvexTriangleMeshShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btConvexTriangleMeshShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_setLocalScaling (btConvexTriangleMeshShape *larg1, btVector3 *larg2) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexTriangleMeshShape_getLocalScaling (btConvexTriangleMeshShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexTriangleMeshShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexTriangleMeshShape_calculatePrincipalAxisTransform (btConvexTriangleMeshShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexTriangleMeshShape const *)arg1)->calculatePrincipalAxisTransform(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexTriangleMeshShape (btConvexTriangleMeshShape *larg1) {
  btConvexTriangleMeshShape *arg1 = (btConvexTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTriangleMeshShape (btTriangleMeshShape *larg1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTriangleMeshShape_localGetSupportingVertex (btTriangleMeshShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTriangleMeshShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTriangleMeshShape_localGetSupportingVertexWithoutMargin (btTriangleMeshShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTriangleMeshShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTriangleMeshShape_recalcLocalAabb (btTriangleMeshShape *larg1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMeshShape_getAabb (btTriangleMeshShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btTriangleMeshShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMeshShape_processAllTriangles (btTriangleMeshShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btTriangleMeshShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMeshShape_calculateLocalInertia (btTriangleMeshShape *larg1, btScalar larg2, btVector3 *larg3) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btTriangleMeshShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTriangleMeshShape_setLocalScaling (btTriangleMeshShape *larg1, btVector3 *larg2) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTriangleMeshShape_getLocalScaling (btTriangleMeshShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btStridingMeshInterface *_wrap_btTriangleMeshShape_getMeshInterface__SWIG_0 (btTriangleMeshShape *larg1) {
  btStridingMeshInterface * lresult = (btStridingMeshInterface *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btStridingMeshInterface *)(arg1)->getMeshInterface();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStridingMeshInterface *)0;
  }
}


EXPORT btStridingMeshInterface *_wrap_btTriangleMeshShape_getMeshInterface__SWIG_1 (btTriangleMeshShape *larg1) {
  btStridingMeshInterface * lresult = (btStridingMeshInterface *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btStridingMeshInterface *)((btTriangleMeshShape const *)arg1)->getMeshInterface();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStridingMeshInterface *)0;
  }
}


EXPORT btVector3 *_wrap_btTriangleMeshShape_getLocalAabbMin (btTriangleMeshShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalAabbMin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTriangleMeshShape_getLocalAabbMax (btTriangleMeshShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalAabbMax();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT char *_wrap_btTriangleMeshShape_getName (btTriangleMeshShape *larg1) {
  char * lresult = (char *)0 ;
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btTriangleMeshShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_m_quantizedAabbMin_set (btBvhSubtreeInfo *larg1, unsigned short *larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT unsigned short *_wrap_btBvhSubtreeInfo_m_quantizedAabbMin_get (btBvhSubtreeInfo *larg1) {
  unsigned short * lresult = (unsigned short *)0 ;
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short *)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_m_quantizedAabbMax_set (btBvhSubtreeInfo *larg1, unsigned short *larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT unsigned short *_wrap_btBvhSubtreeInfo_m_quantizedAabbMax_get (btBvhSubtreeInfo *larg1) {
  unsigned short * lresult = (unsigned short *)0 ;
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short *)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_m_rootNodeIndex_set (btBvhSubtreeInfo *larg1, int larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_rootNodeIndex = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBvhSubtreeInfo_m_rootNodeIndex_get (btBvhSubtreeInfo *larg1) {
  int lresult = (int)0 ;
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_rootNodeIndex);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_m_subtreeSize_set (btBvhSubtreeInfo *larg1, int larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_subtreeSize = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBvhSubtreeInfo_m_subtreeSize_get (btBvhSubtreeInfo *larg1) {
  int lresult = (int)0 ;
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_subtreeSize);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_m_padding_set (btBvhSubtreeInfo *larg1, int *larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      int *b = (int *) arg1->m_padding;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT int *_wrap_btBvhSubtreeInfo_m_padding_get (btBvhSubtreeInfo *larg1) {
  int * lresult = (int *)0 ;
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (int *)(int *) ((arg1)->m_padding);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int *)0;
  }
}


EXPORT btBvhSubtreeInfo *_wrap_new_btBvhSubtreeInfo () {
  btBvhSubtreeInfo * lresult = (btBvhSubtreeInfo *)0 ;
  btBvhSubtreeInfo *result = 0 ;
  
  try {
    result = (btBvhSubtreeInfo *)new btBvhSubtreeInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhSubtreeInfo *)0;
  }
}


EXPORT void _wrap_btBvhSubtreeInfo_setAabbFromQuantizeNode (btBvhSubtreeInfo *larg1, btQuantizedBvhNode *larg2) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  btQuantizedBvhNode *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAabbFromQuantizeNode((btQuantizedBvhNode const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBvhSubtreeInfo (btBvhSubtreeInfo *larg1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btNodeOverlapCallback (btNodeOverlapCallback *larg1) {
  btNodeOverlapCallback *arg1 = (btNodeOverlapCallback *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btNodeOverlapCallback_processNode (btNodeOverlapCallback *larg1, int larg2, int larg3) {
  btNodeOverlapCallback *arg1 = (btNodeOverlapCallback *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processNode(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btQuantizedBvh *_wrap_new_btQuantizedBvh () {
  btQuantizedBvh * lresult = (btQuantizedBvh *)0 ;
  btQuantizedBvh *result = 0 ;
  
  try {
    result = (btQuantizedBvh *)new btQuantizedBvh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuantizedBvh *)0;
  }
}


EXPORT void _wrap_delete_btQuantizedBvh (btQuantizedBvh *larg1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_setQuantizationValues__SWIG_0 (btQuantizedBvh *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_setQuantizationValues__SWIG_1 (btQuantizedBvh *larg1, btVector3 *larg2, btVector3 *larg3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT QuantizedNodeArray *_wrap_btQuantizedBvh_getLeafNodeArray (btQuantizedBvh *larg1) {
  QuantizedNodeArray * lresult = (QuantizedNodeArray *)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (QuantizedNodeArray *) &(arg1)->getLeafNodeArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (QuantizedNodeArray *)0;
  }
}


EXPORT void _wrap_btQuantizedBvh_buildInternal (btQuantizedBvh *larg1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildInternal();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_reportAabbOverlappingNodex (btQuantizedBvh *larg1, btNodeOverlapCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btQuantizedBvh const *)arg1)->reportAabbOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_reportRayOverlappingNodex (btQuantizedBvh *larg1, btNodeOverlapCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btQuantizedBvh const *)arg1)->reportRayOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_reportBoxCastOverlappingNodex (btQuantizedBvh *larg1, btNodeOverlapCallback *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    ((btQuantizedBvh const *)arg1)->reportBoxCastOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_quantize (btQuantizedBvh *larg1, unsigned short *larg2, btVector3 *larg3, int larg4) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btQuantizedBvh const *)arg1)->quantize(arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_quantizeWithClamp (btQuantizedBvh *larg1, unsigned short *larg2, btVector3 *larg3, int larg4) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btQuantizedBvh const *)arg1)->quantizeWithClamp(arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btQuantizedBvh_unQuantize (btQuantizedBvh *larg1, unsigned short *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuantizedBvh const *)arg1)->unQuantize((unsigned short const *)arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btQuantizedBvh_setTraversalMode (btQuantizedBvh *larg1, btQuantizedBvh::btTraversalMode larg2) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvh::btTraversalMode arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTraversalMode(arg2);
    
  } catch (...) {
    
  }
}


EXPORT QuantizedNodeArray *_wrap_btQuantizedBvh_getQuantizedNodeArray (btQuantizedBvh *larg1) {
  QuantizedNodeArray * lresult = (QuantizedNodeArray *)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (QuantizedNodeArray *) &(arg1)->getQuantizedNodeArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (QuantizedNodeArray *)0;
  }
}


EXPORT BvhSubtreeInfoArray *_wrap_btQuantizedBvh_getSubtreeInfoArray (btQuantizedBvh *larg1) {
  BvhSubtreeInfoArray * lresult = (BvhSubtreeInfoArray *)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  BvhSubtreeInfoArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (BvhSubtreeInfoArray *) &(arg1)->getSubtreeInfoArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (BvhSubtreeInfoArray *)0;
  }
}


EXPORT unsigned int _wrap_btQuantizedBvh_calculateSerializeBufferSize (btQuantizedBvh *larg1) {
  unsigned int lresult = (unsigned int)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)((btQuantizedBvh const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT int _wrap_btQuantizedBvh_serialize__SWIG_0 (btQuantizedBvh *larg1, void *larg2, unsigned int larg3, int larg4) {
  int lresult = (int)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  unsigned int arg3 ;
  bool arg4 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (bool)((btQuantizedBvh const *)arg1)->serialize(arg2,arg3,arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btQuantizedBvh *_wrap_btQuantizedBvh_deSerializeInPlace (void *larg1, unsigned int larg2, int larg3) {
  btQuantizedBvh * lresult = (btQuantizedBvh *)0 ;
  void *arg1 = (void *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  btQuantizedBvh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btQuantizedBvh *)btQuantizedBvh::deSerializeInPlace(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuantizedBvh *)0;
  }
}


EXPORT unsigned int _wrap_btQuantizedBvh_getAlignmentSerializationPadding () {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int result;
  
  try {
    result = (unsigned int)btQuantizedBvh::getAlignmentSerializationPadding();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT int _wrap_btQuantizedBvh_calculateSerializeBufferSizeNew (btQuantizedBvh *larg1) {
  int lresult = (int)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btQuantizedBvh const *)arg1)->calculateSerializeBufferSizeNew();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btQuantizedBvh_serialize__SWIG_1 (btQuantizedBvh *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btQuantizedBvh const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btQuantizedBvh_deSerializeFloat (btQuantizedBvh *larg1, btQuantizedBvhFloatData *larg2) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvhFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuantizedBvh_deSerializeDouble (btQuantizedBvh *larg1, btQuantizedBvhDoubleData *larg2) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvhDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btQuantizedBvh_isQuantized (btQuantizedBvh *larg1) {
  int lresult = (int)0 ;
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isQuantized();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btOptimizedBvh *_wrap_new_btOptimizedBvh () {
  btOptimizedBvh * lresult = (btOptimizedBvh *)0 ;
  btOptimizedBvh *result = 0 ;
  
  try {
    result = (btOptimizedBvh *)new btOptimizedBvh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOptimizedBvh *)0;
  }
}


EXPORT void _wrap_delete_btOptimizedBvh (btOptimizedBvh *larg1) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOptimizedBvh_build (btOptimizedBvh *larg1, btStridingMeshInterface *larg2, int larg3, btVector3 *larg4, btVector3 *larg5) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  bool arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->build(arg2,arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOptimizedBvh_refit (btOptimizedBvh *larg1, btStridingMeshInterface *larg2, btVector3 *larg3, btVector3 *larg4) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->refit(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOptimizedBvh_refitPartial (btOptimizedBvh *larg1, btStridingMeshInterface *larg2, btVector3 *larg3, btVector3 *larg4) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->refitPartial(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btOptimizedBvh_updateBvhNodes (btOptimizedBvh *larg1, btStridingMeshInterface *larg2, int larg3, int larg4, int larg5) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->updateBvhNodes(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btOptimizedBvh_serializeInPlace (btOptimizedBvh *larg1, void *larg2, unsigned int larg3, int larg4) {
  int lresult = (int)0 ;
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  unsigned int arg3 ;
  bool arg4 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (bool)((btOptimizedBvh const *)arg1)->serializeInPlace(arg2,arg3,arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btOptimizedBvh *_wrap_btOptimizedBvh_deSerializeInPlace (void *larg1, unsigned int larg2, int larg3) {
  btOptimizedBvh * lresult = (btOptimizedBvh *)0 ;
  void *arg1 = (void *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  btOptimizedBvh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btOptimizedBvh *)btOptimizedBvh::deSerializeInPlace(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOptimizedBvh *)0;
  }
}


EXPORT btHashInt *_wrap_new_btHashInt (int larg1) {
  btHashInt * lresult = (btHashInt *)0 ;
  int arg1 ;
  btHashInt *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btHashInt *)new btHashInt(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHashInt *)0;
  }
}


EXPORT int _wrap_btHashInt_getUid1 (btHashInt *larg1) {
  int lresult = (int)0 ;
  btHashInt *arg1 = (btHashInt *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHashInt const *)arg1)->getUid1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btHashInt_setUid1 (btHashInt *larg1, int larg2) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUid1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btHashInt_equals (btHashInt *larg1, btHashInt *larg2) {
  int lresult = (int)0 ;
  btHashInt *arg1 = (btHashInt *) 0 ;
  btHashInt *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btHashInt const *)arg1)->equals((btHashInt const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT unsigned int _wrap_btHashInt_getHash (btHashInt *larg1) {
  unsigned int lresult = (unsigned int)0 ;
  btHashInt *arg1 = (btHashInt *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)((btHashInt const *)arg1)->getHash();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT void _wrap_delete_btHashInt (btHashInt *larg1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHashPtr *_wrap_new_btHashPtr (void *larg1) {
  btHashPtr * lresult = (btHashPtr *)0 ;
  void *arg1 = (void *) 0 ;
  btHashPtr *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btHashPtr *)new btHashPtr((void const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHashPtr *)0;
  }
}


EXPORT void *_wrap_btHashPtr_getPointer (btHashPtr *larg1) {
  void * lresult = (void *)0 ;
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btHashPtr const *)arg1)->getPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btHashPtr_equals (btHashPtr *larg1, btHashPtr *larg2) {
  int lresult = (int)0 ;
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  btHashPtr *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btHashPtr const *)arg1)->equals((btHashPtr const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT unsigned int _wrap_btHashPtr_getHash (btHashPtr *larg1) {
  unsigned int lresult = (unsigned int)0 ;
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)((btHashPtr const *)arg1)->getHash();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT void _wrap_delete_btHashPtr (btHashPtr *larg1) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btStrLen (char *larg1) {
  int lresult = (int)0 ;
  char *arg1 = (char *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)btStrLen((char const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btChunk_m_chunkCode_set (btChunk *larg1, int larg2) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_chunkCode = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btChunk_m_chunkCode_get (btChunk *larg1) {
  int lresult = (int)0 ;
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_chunkCode);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btChunk_m_length_set (btChunk *larg1, int larg2) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_length = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btChunk_m_length_get (btChunk *larg1) {
  int lresult = (int)0 ;
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_length);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btChunk_m_oldPtr_set (btChunk *larg1, void *larg2) {
  btChunk *arg1 = (btChunk *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_oldPtr = arg2;
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btChunk_m_oldPtr_get (btChunk *larg1) {
  void * lresult = (void *)0 ;
  btChunk *arg1 = (btChunk *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *) ((arg1)->m_oldPtr);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btChunk_m_dna_nr_set (btChunk *larg1, int larg2) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_dna_nr = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btChunk_m_dna_nr_get (btChunk *larg1) {
  int lresult = (int)0 ;
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_dna_nr);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btChunk_m_number_set (btChunk *larg1, int larg2) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_number = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btChunk_m_number_get (btChunk *larg1) {
  int lresult = (int)0 ;
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_number);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btChunk *_wrap_new_btChunk () {
  btChunk * lresult = (btChunk *)0 ;
  btChunk *result = 0 ;
  
  try {
    result = (btChunk *)new btChunk();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btChunk *)0;
  }
}


EXPORT void _wrap_delete_btChunk (btChunk *larg1) {
  btChunk *arg1 = (btChunk *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btSerializer (btSerializer *larg1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT unsigned char *_wrap_btSerializer_getBufferPointer (btSerializer *larg1) {
  unsigned char * lresult = (unsigned char *)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  unsigned char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (unsigned char *)((btSerializer const *)arg1)->getBufferPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned char *)0;
  }
}


EXPORT int _wrap_btSerializer_getCurrentBufferSize (btSerializer *larg1) {
  int lresult = (int)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSerializer const *)arg1)->getCurrentBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btChunk *_wrap_btSerializer_allocate (btSerializer *larg1, size_t *larg2, int larg3) {
  btChunk * lresult = (btChunk *)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  arg3 = larg3;
  try {
    result = (btChunk *)(arg1)->allocate(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btChunk *)0;
  }
}


EXPORT void _wrap_btSerializer_finalizeChunk (btSerializer *larg1, btChunk *larg2, char *larg3, int larg4, void *larg5) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btSerializer_findPointer (btSerializer *larg1, void *larg2) {
  void * lresult = (void *)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->findPointer(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void *_wrap_btSerializer_getUniquePointer (btSerializer *larg1, void *larg2) {
  void * lresult = (void *)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->getUniquePointer(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btSerializer_startSerialization (btSerializer *larg1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->startSerialization();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSerializer_finishSerialization (btSerializer *larg1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->finishSerialization();
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btSerializer_findNameForPointer (btSerializer *larg1, void *larg2) {
  char * lresult = (char *)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (char *)((btSerializer const *)arg1)->findNameForPointer((void const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btSerializer_registerNameForPointer (btSerializer *larg1, void *larg2, char *larg3) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSerializer_serializeName (btSerializer *larg1, char *larg2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serializeName((char const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSerializer_getSerializationFlags (btSerializer *larg1) {
  int lresult = (int)0 ;
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSerializer const *)arg1)->getSerializationFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSerializer_setSerializationFlags (btSerializer *larg1, int larg2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSerializationFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_0 (int larg1) {
  btDefaultSerializer * lresult = (btDefaultSerializer *)0 ;
  int arg1 ;
  btDefaultSerializer *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultSerializer *)new btDefaultSerializer(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultSerializer *)0;
  }
}


EXPORT btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_1 () {
  btDefaultSerializer * lresult = (btDefaultSerializer *)0 ;
  btDefaultSerializer *result = 0 ;
  
  try {
    result = (btDefaultSerializer *)new btDefaultSerializer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultSerializer *)0;
  }
}


EXPORT void _wrap_delete_btDefaultSerializer (btDefaultSerializer *larg1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSerializer_writeHeader (btDefaultSerializer *larg1, unsigned char *larg2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btDefaultSerializer const *)arg1)->writeHeader(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSerializer_startSerialization (btDefaultSerializer *larg1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->startSerialization();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSerializer_finishSerialization (btDefaultSerializer *larg1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->finishSerialization();
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btDefaultSerializer_getUniquePointer (btDefaultSerializer *larg1, void *larg2) {
  void * lresult = (void *)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->getUniquePointer(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT unsigned char *_wrap_btDefaultSerializer_getBufferPointer (btDefaultSerializer *larg1) {
  unsigned char * lresult = (unsigned char *)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (unsigned char *)((btDefaultSerializer const *)arg1)->getBufferPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned char *)0;
  }
}


EXPORT int _wrap_btDefaultSerializer_getCurrentBufferSize (btDefaultSerializer *larg1) {
  int lresult = (int)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDefaultSerializer const *)arg1)->getCurrentBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDefaultSerializer_finalizeChunk (btDefaultSerializer *larg1, btChunk *larg2, char *larg3, int larg4, void *larg5) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT unsigned char *_wrap_btDefaultSerializer_internalAlloc (btDefaultSerializer *larg1, size_t *larg2) {
  unsigned char * lresult = (unsigned char *)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  unsigned char *result = 0 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    result = (unsigned char *)(arg1)->internalAlloc(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned char *)0;
  }
}


EXPORT btChunk *_wrap_btDefaultSerializer_allocate (btDefaultSerializer *larg1, size_t *larg2, int larg3) {
  btChunk * lresult = (btChunk *)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  arg3 = larg3;
  try {
    result = (btChunk *)(arg1)->allocate(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btChunk *)0;
  }
}


EXPORT char *_wrap_btDefaultSerializer_findNameForPointer (btDefaultSerializer *larg1, void *larg2) {
  char * lresult = (char *)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (char *)((btDefaultSerializer const *)arg1)->findNameForPointer((void const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btDefaultSerializer_registerNameForPointer (btDefaultSerializer *larg1, void *larg2, char *larg3) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSerializer_serializeName (btDefaultSerializer *larg1, char *larg2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serializeName((char const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDefaultSerializer_getSerializationFlags (btDefaultSerializer *larg1) {
  int lresult = (int)0 ;
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDefaultSerializer const *)arg1)->getSerializationFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDefaultSerializer_setSerializationFlags (btDefaultSerializer *larg1, int larg2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSerializationFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_0 (btStridingMeshInterface *larg1, int larg2, int larg3) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  bool arg3 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_1 (btStridingMeshInterface *larg1, int larg2) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_2 (btStridingMeshInterface *larg1, int larg2, btVector3 *larg3, btVector3 *larg4, int larg5) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool arg5 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_3 (btStridingMeshInterface *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT void _wrap_delete_btBvhTriangleMeshShape (btBvhTriangleMeshShape *larg1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBvhTriangleMeshShape_getOwnsBvh (btBvhTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btBvhTriangleMeshShape const *)arg1)->getOwnsBvh();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_performRaycast (btBvhTriangleMeshShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->performRaycast(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_performConvexcast (btBvhTriangleMeshShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->performConvexcast(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_processAllTriangles (btBvhTriangleMeshShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBvhTriangleMeshShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_refitTree (btBvhTriangleMeshShape *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->refitTree((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_partialRefitTree (btBvhTriangleMeshShape *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->partialRefitTree((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btBvhTriangleMeshShape_getName (btBvhTriangleMeshShape *larg1) {
  char * lresult = (char *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btBvhTriangleMeshShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_setLocalScaling (btBvhTriangleMeshShape *larg1, btVector3 *larg2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btOptimizedBvh *_wrap_btBvhTriangleMeshShape_getOptimizedBvh (btBvhTriangleMeshShape *larg1) {
  btOptimizedBvh * lresult = (btOptimizedBvh *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOptimizedBvh *)(arg1)->getOptimizedBvh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOptimizedBvh *)0;
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_setOptimizedBvh__SWIG_0 (btBvhTriangleMeshShape *larg1, btOptimizedBvh *larg2, btVector3 *larg3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *arg2 = (btOptimizedBvh *) 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setOptimizedBvh(arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_setOptimizedBvh__SWIG_1 (btBvhTriangleMeshShape *larg1, btOptimizedBvh *larg2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *arg2 = (btOptimizedBvh *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOptimizedBvh(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_buildOptimizedBvh (btBvhTriangleMeshShape *larg1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildOptimizedBvh();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBvhTriangleMeshShape_usesQuantizedAabbCompression (btBvhTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btBvhTriangleMeshShape const *)arg1)->usesQuantizedAabbCompression();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_setTriangleInfoMap (btBvhTriangleMeshShape *larg1, btTriangleInfoMap *larg2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *arg2 = (btTriangleInfoMap *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTriangleInfoMap(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTriangleInfoMap *_wrap_btBvhTriangleMeshShape_getTriangleInfoMap__SWIG_0 (btBvhTriangleMeshShape *larg1) {
  btTriangleInfoMap * lresult = (btTriangleInfoMap *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTriangleInfoMap *)((btBvhTriangleMeshShape const *)arg1)->getTriangleInfoMap();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleInfoMap *)0;
  }
}


EXPORT btTriangleInfoMap *_wrap_btBvhTriangleMeshShape_getTriangleInfoMap__SWIG_1 (btBvhTriangleMeshShape *larg1) {
  btTriangleInfoMap * lresult = (btTriangleInfoMap *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTriangleInfoMap *)(arg1)->getTriangleInfoMap();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTriangleInfoMap *)0;
  }
}


EXPORT int _wrap_btBvhTriangleMeshShape_calculateSerializeBufferSize (btBvhTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBvhTriangleMeshShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btBvhTriangleMeshShape_serialize (btBvhTriangleMeshShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btBvhTriangleMeshShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_serializeSingleBvh (btBvhTriangleMeshShape *larg1, btSerializer *larg2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btBvhTriangleMeshShape const *)arg1)->serializeSingleBvh(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBvhTriangleMeshShape_serializeSingleTriangleInfoMap (btBvhTriangleMeshShape *larg1, btSerializer *larg2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btBvhTriangleMeshShape const *)arg1)->serializeSingleTriangleInfoMap(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScaledBvhTriangleMeshShape *_wrap_new_btScaledBvhTriangleMeshShape (btBvhTriangleMeshShape *larg1, btVector3 *larg2) {
  btScaledBvhTriangleMeshShape * lresult = (btScaledBvhTriangleMeshShape *)0 ;
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScaledBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScaledBvhTriangleMeshShape *)new btScaledBvhTriangleMeshShape(arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScaledBvhTriangleMeshShape *)0;
  }
}


EXPORT void _wrap_delete_btScaledBvhTriangleMeshShape (btScaledBvhTriangleMeshShape *larg1) {
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btScaledBvhTriangleMeshShape_getAabb (btScaledBvhTriangleMeshShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btScaledBvhTriangleMeshShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btScaledBvhTriangleMeshShape_setLocalScaling (btScaledBvhTriangleMeshShape *larg1, btVector3 *larg2) {
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btScaledBvhTriangleMeshShape_getLocalScaling (btScaledBvhTriangleMeshShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btScaledBvhTriangleMeshShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btScaledBvhTriangleMeshShape_calculateLocalInertia (btScaledBvhTriangleMeshShape *larg1, btScalar larg2, btVector3 *larg3) {
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btScaledBvhTriangleMeshShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btScaledBvhTriangleMeshShape_processAllTriangles (btScaledBvhTriangleMeshShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btScaledBvhTriangleMeshShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_btScaledBvhTriangleMeshShape_getChildShape__SWIG_0 (btScaledBvhTriangleMeshShape *larg1) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBvhTriangleMeshShape *)(arg1)->getChildShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT btBvhTriangleMeshShape *_wrap_btScaledBvhTriangleMeshShape_getChildShape__SWIG_1 (btScaledBvhTriangleMeshShape *larg1) {
  btBvhTriangleMeshShape * lresult = (btBvhTriangleMeshShape *)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  btBvhTriangleMeshShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBvhTriangleMeshShape *)((btScaledBvhTriangleMeshShape const *)arg1)->getChildShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBvhTriangleMeshShape *)0;
  }
}


EXPORT char *_wrap_btScaledBvhTriangleMeshShape_getName (btScaledBvhTriangleMeshShape *larg1) {
  char * lresult = (char *)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btScaledBvhTriangleMeshShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btScaledBvhTriangleMeshShape_calculateSerializeBufferSize (btScaledBvhTriangleMeshShape *larg1) {
  int lresult = (int)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btScaledBvhTriangleMeshShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btScaledBvhTriangleMeshShape_serialize (btScaledBvhTriangleMeshShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btScaledBvhTriangleMeshShape *arg1 = (btScaledBvhTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btScaledBvhTriangleMeshShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btCompoundShape *_wrap_new_btCompoundShape__SWIG_0 (int larg1) {
  btCompoundShape * lresult = (btCompoundShape *)0 ;
  bool arg1 ;
  btCompoundShape *result = 0 ;
  
  arg1 = (bool)larg1;
  try {
    result = (btCompoundShape *)new btCompoundShape(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCompoundShape *)0;
  }
}


EXPORT btCompoundShape *_wrap_new_btCompoundShape__SWIG_1 () {
  btCompoundShape * lresult = (btCompoundShape *)0 ;
  btCompoundShape *result = 0 ;
  
  try {
    result = (btCompoundShape *)new btCompoundShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCompoundShape *)0;
  }
}


EXPORT void _wrap_delete_btCompoundShape (btCompoundShape *larg1) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_addChildShape (btCompoundShape *larg1, btTransform *larg2, btCollisionShape *larg3) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addChildShape((btTransform const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_removeChildShape (btCompoundShape *larg1, btCollisionShape *larg2) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeChildShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_removeChildShapeByIndex (btCompoundShape *larg1, int larg2) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeChildShapeByIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCompoundShape_getNumChildShapes (btCompoundShape *larg1) {
  int lresult = (int)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCompoundShape const *)arg1)->getNumChildShapes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btCollisionShape *_wrap_btCompoundShape_getChildShape__SWIG_0 (btCompoundShape *larg1, int larg2) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCollisionShape *)(arg1)->getChildShape(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btCompoundShape_getChildShape__SWIG_1 (btCompoundShape *larg1, int larg2) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCollisionShape *)((btCompoundShape const *)arg1)->getChildShape(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btTransform *_wrap_btCompoundShape_getChildTransform__SWIG_0 (btCompoundShape *larg1, int larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->getChildTransform(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCompoundShape_getChildTransform__SWIG_1 (btCompoundShape *larg1, int larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &((btCompoundShape const *)arg1)->getChildTransform(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCompoundShape_updateChildTransform__SWIG_0 (btCompoundShape *larg1, int larg2, btTransform *larg3, int larg4) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btTransform *arg3 = 0 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->updateChildTransform(arg2,(btTransform const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_updateChildTransform__SWIG_1 (btCompoundShape *larg1, int larg2, btTransform *larg3) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->updateChildTransform(arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btCompoundShapeChild *_wrap_btCompoundShape_getChildList (btCompoundShape *larg1) {
  btCompoundShapeChild * lresult = (btCompoundShapeChild *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btCompoundShapeChild *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCompoundShapeChild *)(arg1)->getChildList();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCompoundShapeChild *)0;
  }
}


EXPORT void _wrap_btCompoundShape_getAabb (btCompoundShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCompoundShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_recalculateLocalAabb (btCompoundShape *larg1) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalculateLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_setLocalScaling (btCompoundShape *larg1, btVector3 *larg2) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCompoundShape_getLocalScaling (btCompoundShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCompoundShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCompoundShape_calculateLocalInertia (btCompoundShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCompoundShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_setMargin (btCompoundShape *larg1, btScalar larg2) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCompoundShape_getMargin (btCompoundShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCompoundShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT char *_wrap_btCompoundShape_getName (btCompoundShape *larg1) {
  char * lresult = (char *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCompoundShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btDbvt *_wrap_btCompoundShape_getDynamicAabbTree__SWIG_0 (btCompoundShape *larg1) {
  btDbvt * lresult = (btDbvt *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btDbvt *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDbvt *)((btCompoundShape const *)arg1)->getDynamicAabbTree();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvt *)0;
  }
}


EXPORT btDbvt *_wrap_btCompoundShape_getDynamicAabbTree__SWIG_1 (btCompoundShape *larg1) {
  btDbvt * lresult = (btDbvt *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btDbvt *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDbvt *)(arg1)->getDynamicAabbTree();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvt *)0;
  }
}


EXPORT void _wrap_btCompoundShape_createAabbTreeFromChildren (btCompoundShape *larg1) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->createAabbTreeFromChildren();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCompoundShape_calculatePrincipalAxisTransform (btCompoundShape *larg1, btScalar *larg2, btTransform *larg3, btVector3 *larg4) {
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCompoundShape const *)arg1)->calculatePrincipalAxisTransform(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCompoundShape_getUpdateRevision (btCompoundShape *larg1) {
  int lresult = (int)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCompoundShape const *)arg1)->getUpdateRevision();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCompoundShape_calculateSerializeBufferSize (btCompoundShape *larg1) {
  int lresult = (int)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCompoundShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCompoundShape_serialize (btCompoundShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCompoundShape *arg1 = (btCompoundShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCompoundShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btBU_Simplex1to4 *_wrap_new_btBU_Simplex1to4__SWIG_0 () {
  btBU_Simplex1to4 * lresult = (btBU_Simplex1to4 *)0 ;
  btBU_Simplex1to4 *result = 0 ;
  
  try {
    result = (btBU_Simplex1to4 *)new btBU_Simplex1to4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBU_Simplex1to4 *)0;
  }
}


EXPORT btBU_Simplex1to4 *_wrap_new_btBU_Simplex1to4__SWIG_1 (btVector3 *larg1) {
  btBU_Simplex1to4 * lresult = (btBU_Simplex1to4 *)0 ;
  btVector3 *arg1 = 0 ;
  btBU_Simplex1to4 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBU_Simplex1to4 *)new btBU_Simplex1to4((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBU_Simplex1to4 *)0;
  }
}


EXPORT btBU_Simplex1to4 *_wrap_new_btBU_Simplex1to4__SWIG_2 (btVector3 *larg1, btVector3 *larg2) {
  btBU_Simplex1to4 * lresult = (btBU_Simplex1to4 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btBU_Simplex1to4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btBU_Simplex1to4 *)new btBU_Simplex1to4((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBU_Simplex1to4 *)0;
  }
}


EXPORT btBU_Simplex1to4 *_wrap_new_btBU_Simplex1to4__SWIG_3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBU_Simplex1to4 * lresult = (btBU_Simplex1to4 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBU_Simplex1to4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBU_Simplex1to4 *)new btBU_Simplex1to4((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBU_Simplex1to4 *)0;
  }
}


EXPORT btBU_Simplex1to4 *_wrap_new_btBU_Simplex1to4__SWIG_4 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBU_Simplex1to4 * lresult = (btBU_Simplex1to4 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btBU_Simplex1to4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btBU_Simplex1to4 *)new btBU_Simplex1to4((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBU_Simplex1to4 *)0;
  }
}


EXPORT void _wrap_btBU_Simplex1to4_reset (btBU_Simplex1to4 *larg1) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBU_Simplex1to4_getAabb (btBU_Simplex1to4 *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBU_Simplex1to4 const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBU_Simplex1to4_addVertex (btBU_Simplex1to4 *larg1, btVector3 *larg2) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVertex((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBU_Simplex1to4_getNumVertices (btBU_Simplex1to4 *larg1) {
  int lresult = (int)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBU_Simplex1to4 const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBU_Simplex1to4_getNumEdges (btBU_Simplex1to4 *larg1) {
  int lresult = (int)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBU_Simplex1to4 const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBU_Simplex1to4_getEdge (btBU_Simplex1to4 *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBU_Simplex1to4 const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBU_Simplex1to4_getVertex (btBU_Simplex1to4 *larg1, int larg2, btVector3 *larg3) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBU_Simplex1to4 const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBU_Simplex1to4_getNumPlanes (btBU_Simplex1to4 *larg1) {
  int lresult = (int)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBU_Simplex1to4 const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBU_Simplex1to4_getPlane (btBU_Simplex1to4 *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBU_Simplex1to4 const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBU_Simplex1to4_getIndex (btBU_Simplex1to4 *larg1, int larg2) {
  int lresult = (int)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)((btBU_Simplex1to4 const *)arg1)->getIndex(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBU_Simplex1to4_isInside (btBU_Simplex1to4 *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBU_Simplex1to4 const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btBU_Simplex1to4_getName (btBU_Simplex1to4 *larg1) {
  char * lresult = (char *)0 ;
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btBU_Simplex1to4 const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btBU_Simplex1to4 (btBU_Simplex1to4 *larg1) {
  btBU_Simplex1to4 *arg1 = (btBU_Simplex1to4 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btEmptyShape *_wrap_new_btEmptyShape () {
  btEmptyShape * lresult = (btEmptyShape *)0 ;
  btEmptyShape *result = 0 ;
  
  try {
    result = (btEmptyShape *)new btEmptyShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btEmptyShape *)0;
  }
}


EXPORT void _wrap_delete_btEmptyShape (btEmptyShape *larg1) {
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btEmptyShape_getAabb (btEmptyShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btEmptyShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btEmptyShape_setLocalScaling (btEmptyShape *larg1, btVector3 *larg2) {
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btEmptyShape_getLocalScaling (btEmptyShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btEmptyShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btEmptyShape_calculateLocalInertia (btEmptyShape *larg1, btScalar larg2, btVector3 *larg3) {
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btEmptyShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btEmptyShape_getName (btEmptyShape *larg1) {
  char * lresult = (char *)0 ;
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btEmptyShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btEmptyShape_processAllTriangles (btEmptyShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btEmptyShape *arg1 = (btEmptyShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btEmptyShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btMultiSphereShape *_wrap_new_btMultiSphereShape (btVector3 *larg1, btScalar *larg2, int larg3) {
  btMultiSphereShape * lresult = (btMultiSphereShape *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btMultiSphereShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btMultiSphereShape *)new btMultiSphereShape((btVector3 const *)arg1,(btScalar const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMultiSphereShape *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_calculateLocalInertia (btMultiSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btMultiSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_localGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMultiSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMultiSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btMultiSphereShape_getSphereCount (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->getSphereCount();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_getSpherePosition (btMultiSphereShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMultiSphereShape const *)arg1)->getSpherePosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btMultiSphereShape_getSphereRadius (btMultiSphereShape *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMultiSphereShape const *)arg1)->getSphereRadius(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_getName (btMultiSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btMultiSphereShape_calculateSerializeBufferSize (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_serialize (btMultiSphereShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btMultiSphereShape (btMultiSphereShape *larg1) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btUniformScalingShape *_wrap_new_btUniformScalingShape (btConvexShape *larg1, btScalar larg2) {
  btUniformScalingShape * lresult = (btUniformScalingShape *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btUniformScalingShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btUniformScalingShape *)new btUniformScalingShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btUniformScalingShape *)0;
  }
}


EXPORT void _wrap_delete_btUniformScalingShape (btUniformScalingShape *larg1) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btUniformScalingShape_localGetSupportingVertexWithoutMargin (btUniformScalingShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btUniformScalingShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniformScalingShape_localGetSupportingVertex (btUniformScalingShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btUniformScalingShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btUniformScalingShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btUniformScalingShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btUniformScalingShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniformScalingShape_calculateLocalInertia (btUniformScalingShape *larg1, btScalar larg2, btVector3 *larg3) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btUniformScalingShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btUniformScalingShape_getUniformScalingFactor (btUniformScalingShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btUniformScalingShape const *)arg1)->getUniformScalingFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btConvexShape *_wrap_btUniformScalingShape_getChildShape__SWIG_0 (btUniformScalingShape *larg1) {
  btConvexShape * lresult = (btConvexShape *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btConvexShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexShape *)(arg1)->getChildShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexShape *)0;
  }
}


EXPORT btConvexShape *_wrap_btUniformScalingShape_getChildShape__SWIG_1 (btUniformScalingShape *larg1) {
  btConvexShape * lresult = (btConvexShape *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btConvexShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexShape *)((btUniformScalingShape const *)arg1)->getChildShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexShape *)0;
  }
}


EXPORT char *_wrap_btUniformScalingShape_getName (btUniformScalingShape *larg1) {
  char * lresult = (char *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btUniformScalingShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btUniformScalingShape_getAabb (btUniformScalingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btUniformScalingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniformScalingShape_getAabbSlow (btUniformScalingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btUniformScalingShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniformScalingShape_setLocalScaling (btUniformScalingShape *larg1, btVector3 *larg2) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btUniformScalingShape_getLocalScaling (btUniformScalingShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btUniformScalingShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btUniformScalingShape_setMargin (btUniformScalingShape *larg1, btScalar larg2) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btUniformScalingShape_getMargin (btUniformScalingShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btUniformScalingShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btUniformScalingShape_getNumPreferredPenetrationDirections (btUniformScalingShape *larg1) {
  int lresult = (int)0 ;
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btUniformScalingShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btUniformScalingShape_getPreferredPenetrationDirection (btUniformScalingShape *larg1, int larg2, btVector3 *larg3) {
  btUniformScalingShape *arg1 = (btUniformScalingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btUniformScalingShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionAlgorithm (btCollisionAlgorithm *larg1) {
  btCollisionAlgorithm *arg1 = (btCollisionAlgorithm *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionAlgorithm_processCollision (btCollisionAlgorithm *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btDispatcherInfo *larg4, btManifoldResult *larg5) {
  btCollisionAlgorithm *arg1 = (btCollisionAlgorithm *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  btManifoldResult *arg5 = (btManifoldResult *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->processCollision((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btDispatcherInfo const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionAlgorithm_calculateTimeOfImpact (btCollisionAlgorithm *larg1, btCollisionObject *larg2, btCollisionObject *larg3, btDispatcherInfo *larg4, btManifoldResult *larg5) {
  btScalar lresult = (btScalar)0 ;
  btCollisionAlgorithm *arg1 = (btCollisionAlgorithm *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  btManifoldResult *arg5 = (btManifoldResult *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)(arg1)->calculateTimeOfImpact(arg2,arg3,(btDispatcherInfo const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionAlgorithm_getAllContactManifolds (btCollisionAlgorithm *larg1, btManifoldArray *larg2) {
  btCollisionAlgorithm *arg1 = (btCollisionAlgorithm *) 0 ;
  btManifoldArray *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAllContactManifolds(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btActivatingCollisionAlgorithm (btActivatingCollisionAlgorithm *larg1) {
  btActivatingCollisionAlgorithm *arg1 = (btActivatingCollisionAlgorithm *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSphereSphereCollisionAlgorithm *_wrap_new_btSphereSphereCollisionAlgorithm__SWIG_0 (btPersistentManifold *larg1, btCollisionAlgorithmConstructionInfo *larg2, btCollisionObjectWrapper *larg3, btCollisionObjectWrapper *larg4) {
  btSphereSphereCollisionAlgorithm * lresult = (btSphereSphereCollisionAlgorithm *)0 ;
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithmConstructionInfo *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btSphereSphereCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSphereSphereCollisionAlgorithm *)new btSphereSphereCollisionAlgorithm(arg1,(btCollisionAlgorithmConstructionInfo const &)*arg2,(btCollisionObjectWrapper const *)arg3,(btCollisionObjectWrapper const *)arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSphereSphereCollisionAlgorithm *)0;
  }
}


EXPORT btSphereSphereCollisionAlgorithm *_wrap_new_btSphereSphereCollisionAlgorithm__SWIG_1 (btCollisionAlgorithmConstructionInfo *larg1) {
  btSphereSphereCollisionAlgorithm * lresult = (btSphereSphereCollisionAlgorithm *)0 ;
  btCollisionAlgorithmConstructionInfo *arg1 = 0 ;
  btSphereSphereCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSphereSphereCollisionAlgorithm *)new btSphereSphereCollisionAlgorithm((btCollisionAlgorithmConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSphereSphereCollisionAlgorithm *)0;
  }
}


EXPORT void _wrap_btSphereSphereCollisionAlgorithm_processCollision (btSphereSphereCollisionAlgorithm *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btDispatcherInfo *larg4, btManifoldResult *larg5) {
  btSphereSphereCollisionAlgorithm *arg1 = (btSphereSphereCollisionAlgorithm *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  btManifoldResult *arg5 = (btManifoldResult *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->processCollision((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btDispatcherInfo const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereSphereCollisionAlgorithm_calculateTimeOfImpact (btSphereSphereCollisionAlgorithm *larg1, btCollisionObject *larg2, btCollisionObject *larg3, btDispatcherInfo *larg4, btManifoldResult *larg5) {
  btScalar lresult = (btScalar)0 ;
  btSphereSphereCollisionAlgorithm *arg1 = (btSphereSphereCollisionAlgorithm *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  btManifoldResult *arg5 = (btManifoldResult *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)(arg1)->calculateTimeOfImpact(arg2,arg3,(btDispatcherInfo const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSphereSphereCollisionAlgorithm_getAllContactManifolds (btSphereSphereCollisionAlgorithm *larg1, btManifoldArray *larg2) {
  btSphereSphereCollisionAlgorithm *arg1 = (btSphereSphereCollisionAlgorithm *) 0 ;
  btManifoldArray *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAllContactManifolds(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btSphereSphereCollisionAlgorithm (btSphereSphereCollisionAlgorithm *larg1) {
  btSphereSphereCollisionAlgorithm *arg1 = (btSphereSphereCollisionAlgorithm *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionConfiguration (btCollisionConfiguration *larg1) {
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getPersistentManifoldPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getCollisionAlgorithmPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btCollisionConfiguration_getCollisionAlgorithmCreateFunc (btCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration__SWIG_0 (btDefaultCollisionConstructionInfo *larg1) {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConstructionInfo *arg1 = 0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration((btDefaultCollisionConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration__SWIG_1 () {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_delete_btDefaultCollisionConfiguration (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getPersistentManifoldPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btVoronoiSimplexSolver *_wrap_btDefaultCollisionConfiguration_getSimplexSolver (btDefaultCollisionConfiguration *larg1) {
  btVoronoiSimplexSolver * lresult = (btVoronoiSimplexSolver *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btVoronoiSimplexSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVoronoiSimplexSolver *)(arg1)->getSimplexSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVoronoiSimplexSolver *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setConvexConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setPlaneConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT btSimpleBroadphase *_wrap_new_btSimpleBroadphase__SWIG_0 (int larg1, btOverlappingPairCache *larg2) {
  btSimpleBroadphase * lresult = (btSimpleBroadphase *)0 ;
  int arg1 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btSimpleBroadphase *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btSimpleBroadphase *)new btSimpleBroadphase(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleBroadphase *)0;
  }
}


EXPORT btSimpleBroadphase *_wrap_new_btSimpleBroadphase__SWIG_1 (int larg1) {
  btSimpleBroadphase * lresult = (btSimpleBroadphase *)0 ;
  int arg1 ;
  btSimpleBroadphase *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimpleBroadphase *)new btSimpleBroadphase(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleBroadphase *)0;
  }
}


EXPORT btSimpleBroadphase *_wrap_new_btSimpleBroadphase__SWIG_2 () {
  btSimpleBroadphase * lresult = (btSimpleBroadphase *)0 ;
  btSimpleBroadphase *result = 0 ;
  
  try {
    result = (btSimpleBroadphase *)new btSimpleBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleBroadphase *)0;
  }
}


EXPORT void _wrap_delete_btSimpleBroadphase (btSimpleBroadphase *larg1) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSimpleBroadphase_aabbOverlap (btSimpleBroadphaseProxy *larg1, btSimpleBroadphaseProxy *larg2) {
  int lresult = (int)0 ;
  btSimpleBroadphaseProxy *arg1 = (btSimpleBroadphaseProxy *) 0 ;
  btSimpleBroadphaseProxy *arg2 = (btSimpleBroadphaseProxy *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btSimpleBroadphase::aabbOverlap(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btSimpleBroadphase_createProxy (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btSimpleBroadphase_calculateOverlappingPairs (btSimpleBroadphase *larg1, btDispatcher *larg2) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_destroyProxy (btSimpleBroadphase *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_setAabb (btSimpleBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_getAabb (btSimpleBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSimpleBroadphase const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_rayTest__SWIG_0 (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_rayTest__SWIG_1 (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_rayTest__SWIG_2 (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_aabbTest (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseAabbCallback *larg4) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btSimpleBroadphase_getOverlappingPairCache__SWIG_0 (btSimpleBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btSimpleBroadphase_getOverlappingPairCache__SWIG_1 (btSimpleBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btSimpleBroadphase const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT int _wrap_btSimpleBroadphase_testAabbOverlap (btSimpleBroadphase *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  int lresult = (int)0 ;
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->testAabbOverlap(arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSimpleBroadphase_getBroadphaseAabb (btSimpleBroadphase *larg1, btVector3 *larg2, btVector3 *larg3) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btSimpleBroadphase const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleBroadphase_printStats (btSimpleBroadphase *larg1) {
  btSimpleBroadphase *arg1 = (btSimpleBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT btAxisSweep3 *_wrap_new_btAxisSweep3__SWIG_0 (btVector3 *larg1, btVector3 *larg2, unsigned short larg3, btOverlappingPairCache *larg4, int larg5) {
  btAxisSweep3 * lresult = (btAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned short arg3 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  bool arg5 ;
  btAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btAxisSweep3 *)new btAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAxisSweep3 *)0;
  }
}


EXPORT btAxisSweep3 *_wrap_new_btAxisSweep3__SWIG_1 (btVector3 *larg1, btVector3 *larg2, unsigned short larg3, btOverlappingPairCache *larg4) {
  btAxisSweep3 * lresult = (btAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned short arg3 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  btAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btAxisSweep3 *)new btAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAxisSweep3 *)0;
  }
}


EXPORT btAxisSweep3 *_wrap_new_btAxisSweep3__SWIG_2 (btVector3 *larg1, btVector3 *larg2, unsigned short larg3) {
  btAxisSweep3 * lresult = (btAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned short arg3 ;
  btAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btAxisSweep3 *)new btAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAxisSweep3 *)0;
  }
}


EXPORT btAxisSweep3 *_wrap_new_btAxisSweep3__SWIG_3 (btVector3 *larg1, btVector3 *larg2) {
  btAxisSweep3 * lresult = (btAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btAxisSweep3 *)new btAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAxisSweep3 *)0;
  }
}


EXPORT void _wrap_delete_btAxisSweep3 (btAxisSweep3 *larg1) {
  btAxisSweep3 *arg1 = (btAxisSweep3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT bt32BitAxisSweep3 *_wrap_new_bt32BitAxisSweep3__SWIG_0 (btVector3 *larg1, btVector3 *larg2, unsigned int larg3, btOverlappingPairCache *larg4, int larg5) {
  bt32BitAxisSweep3 * lresult = (bt32BitAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int arg3 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  bool arg5 ;
  bt32BitAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (bt32BitAxisSweep3 *)new bt32BitAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bt32BitAxisSweep3 *)0;
  }
}


EXPORT bt32BitAxisSweep3 *_wrap_new_bt32BitAxisSweep3__SWIG_1 (btVector3 *larg1, btVector3 *larg2, unsigned int larg3, btOverlappingPairCache *larg4) {
  bt32BitAxisSweep3 * lresult = (bt32BitAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int arg3 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  bt32BitAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bt32BitAxisSweep3 *)new bt32BitAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bt32BitAxisSweep3 *)0;
  }
}


EXPORT bt32BitAxisSweep3 *_wrap_new_bt32BitAxisSweep3__SWIG_2 (btVector3 *larg1, btVector3 *larg2, unsigned int larg3) {
  bt32BitAxisSweep3 * lresult = (bt32BitAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int arg3 ;
  bt32BitAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bt32BitAxisSweep3 *)new bt32BitAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bt32BitAxisSweep3 *)0;
  }
}


EXPORT bt32BitAxisSweep3 *_wrap_new_bt32BitAxisSweep3__SWIG_3 (btVector3 *larg1, btVector3 *larg2) {
  bt32BitAxisSweep3 * lresult = (bt32BitAxisSweep3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  bt32BitAxisSweep3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bt32BitAxisSweep3 *)new bt32BitAxisSweep3((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bt32BitAxisSweep3 *)0;
  }
}


EXPORT void _wrap_delete_bt32BitAxisSweep3 (bt32BitAxisSweep3 *larg1) {
  bt32BitAxisSweep3 *arg1 = (bt32BitAxisSweep3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSapBroadphaseArray *_wrap_btMultiSapBroadphase_getBroadphaseArray__SWIG_0 (btMultiSapBroadphase *larg1) {
  btSapBroadphaseArray * lresult = (btSapBroadphaseArray *)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btSapBroadphaseArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSapBroadphaseArray *) &(arg1)->getBroadphaseArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSapBroadphaseArray *)0;
  }
}


EXPORT btSapBroadphaseArray *_wrap_btMultiSapBroadphase_getBroadphaseArray__SWIG_1 (btMultiSapBroadphase *larg1) {
  btSapBroadphaseArray * lresult = (btSapBroadphaseArray *)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btSapBroadphaseArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSapBroadphaseArray *) &((btMultiSapBroadphase const *)arg1)->getBroadphaseArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSapBroadphaseArray *)0;
  }
}


EXPORT void _wrap_delete_btMultiSapBroadphase (btMultiSapBroadphase *larg1) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btMultiSapBroadphase_createProxy (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btMultiSapBroadphase_destroyProxy (btMultiSapBroadphase *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_setAabb (btMultiSapBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_getAabb (btMultiSapBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMultiSapBroadphase const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_rayTest__SWIG_0 (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_rayTest__SWIG_1 (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_rayTest__SWIG_2 (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_addToChildBroadphase (btMultiSapBroadphase *larg1, btMultiSapBroadphase::btMultiSapProxy *larg2, btBroadphaseProxy *larg3, btBroadphaseInterface *larg4) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btMultiSapBroadphase::btMultiSapProxy *arg2 = (btMultiSapBroadphase::btMultiSapProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphaseInterface *arg4 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addToChildBroadphase(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_calculateOverlappingPairs (btMultiSapBroadphase *larg1, btDispatcher *larg2) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btMultiSapBroadphase_testAabbOverlap (btMultiSapBroadphase *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  int lresult = (int)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->testAabbOverlap(arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btMultiSapBroadphase_getOverlappingPairCache__SWIG_0 (btMultiSapBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btMultiSapBroadphase_getOverlappingPairCache__SWIG_1 (btMultiSapBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btMultiSapBroadphase const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btMultiSapBroadphase_getBroadphaseAabb (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btMultiSapBroadphase const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_buildTree (btMultiSapBroadphase *larg1, btVector3 *larg2, btVector3 *larg3) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->buildTree((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_printStats (btMultiSapBroadphase *larg1) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMultiSapBroadphase_resetPool (btMultiSapBroadphase *larg1, btDispatcher *larg2) {
  btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->resetPool(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btClock *_wrap_new_btClock__SWIG_0 () {
  btClock * lresult = (btClock *)0 ;
  btClock *result = 0 ;
  
  try {
    result = (btClock *)new btClock();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btClock *)0;
  }
}


EXPORT btClock *_wrap_new_btClock__SWIG_1 (btClock *larg1) {
  btClock * lresult = (btClock *)0 ;
  btClock *arg1 = 0 ;
  btClock *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btClock *)new btClock((btClock const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btClock *)0;
  }
}


EXPORT btClock *_wrap_btClock___assign__ (btClock *larg1, btClock *larg2) {
  btClock * lresult = (btClock *)0 ;
  btClock *arg1 = (btClock *) 0 ;
  btClock *arg2 = 0 ;
  btClock *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btClock *) &(arg1)->operator =((btClock const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btClock *)0;
  }
}


EXPORT void _wrap_delete_btClock (btClock *larg1) {
  btClock *arg1 = (btClock *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btClock_reset (btClock *larg1) {
  btClock *arg1 = (btClock *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT unsigned long _wrap_btClock_getTimeMilliseconds (btClock *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btClock *arg1 = (btClock *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)(arg1)->getTimeMilliseconds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT unsigned long _wrap_btClock_getTimeMicroseconds (btClock *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btClock *arg1 = (btClock *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)(arg1)->getTimeMicroseconds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT CProfileNode *_wrap_new_CProfileNode (char *larg1, CProfileNode *larg2) {
  CProfileNode * lresult = (CProfileNode *)0 ;
  char *arg1 = (char *) 0 ;
  CProfileNode *arg2 = (CProfileNode *) 0 ;
  CProfileNode *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (CProfileNode *)new CProfileNode((char const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileNode *)0;
  }
}


EXPORT void _wrap_delete_CProfileNode (CProfileNode *larg1) {
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT CProfileNode *_wrap_CProfileNode_Get_Sub_Node (CProfileNode *larg1, char *larg2) {
  CProfileNode * lresult = (CProfileNode *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  char *arg2 = (char *) 0 ;
  CProfileNode *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (CProfileNode *)(arg1)->Get_Sub_Node((char const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileNode *)0;
  }
}


EXPORT CProfileNode *_wrap_CProfileNode_Get_Parent (CProfileNode *larg1) {
  CProfileNode * lresult = (CProfileNode *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  CProfileNode *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (CProfileNode *)(arg1)->Get_Parent();
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileNode *)0;
  }
}


EXPORT CProfileNode *_wrap_CProfileNode_Get_Sibling (CProfileNode *larg1) {
  CProfileNode * lresult = (CProfileNode *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  CProfileNode *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (CProfileNode *)(arg1)->Get_Sibling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileNode *)0;
  }
}


EXPORT CProfileNode *_wrap_CProfileNode_Get_Child (CProfileNode *larg1) {
  CProfileNode * lresult = (CProfileNode *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  CProfileNode *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (CProfileNode *)(arg1)->Get_Child();
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileNode *)0;
  }
}


EXPORT void _wrap_CProfileNode_CleanupMemory (CProfileNode *larg1) {
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->CleanupMemory();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileNode_Reset (CProfileNode *larg1) {
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Reset();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileNode_Call (CProfileNode *larg1) {
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Call();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_CProfileNode_Return (CProfileNode *larg1) {
  int lresult = (int)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->Return();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_CProfileNode_Get_Name (CProfileNode *larg1) {
  char * lresult = (char *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)(arg1)->Get_Name();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_CProfileNode_Get_Total_Calls (CProfileNode *larg1) {
  int lresult = (int)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->Get_Total_Calls();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_CProfileNode_Get_Total_Time (CProfileNode *larg1) {
  float lresult = (float)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)(arg1)->Get_Total_Time();
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void *_wrap_CProfileNode_GetUserPointer (CProfileNode *larg1) {
  void * lresult = (void *)0 ;
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((CProfileNode const *)arg1)->GetUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_CProfileNode_SetUserPointer (CProfileNode *larg1, void *larg2) {
  CProfileNode *arg1 = (CProfileNode *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->SetUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileIterator_First (CProfileIterator *larg1) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->First();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileIterator_Next (CProfileIterator *larg1) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Next();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_CProfileIterator_Is_Done (CProfileIterator *larg1) {
  int lresult = (int)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->Is_Done();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_CProfileIterator_Is_Root (CProfileIterator *larg1) {
  int lresult = (int)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->Is_Root();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_CProfileIterator_Enter_Child (CProfileIterator *larg1, int larg2) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->Enter_Child(arg2);
    
  } catch (...) {
    
  }
}

EXPORT void _wrap_CProfileIterator_Enter_Parent (CProfileIterator *larg1) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Enter_Parent();
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_CProfileIterator_Get_Current_Name (CProfileIterator *larg1) {
  char * lresult = (char *)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)(arg1)->Get_Current_Name();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_CProfileIterator_Get_Current_Total_Calls (CProfileIterator *larg1) {
  int lresult = (int)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->Get_Current_Total_Calls();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_CProfileIterator_Get_Current_Total_Time (CProfileIterator *larg1) {
  float lresult = (float)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)(arg1)->Get_Current_Total_Time();
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void *_wrap_CProfileIterator_Get_Current_UserPointer (CProfileIterator *larg1) {
  void * lresult = (void *)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)(arg1)->Get_Current_UserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_CProfileIterator_Set_Current_UserPointer (CProfileIterator *larg1, void *larg2) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->Set_Current_UserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_CProfileIterator_Get_Current_Parent_Name (CProfileIterator *larg1) {
  char * lresult = (char *)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)(arg1)->Get_Current_Parent_Name();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_CProfileIterator_Get_Current_Parent_Total_Calls (CProfileIterator *larg1) {
  int lresult = (int)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->Get_Current_Parent_Total_Calls();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_CProfileIterator_Get_Current_Parent_Total_Time (CProfileIterator *larg1) {
  float lresult = (float)0 ;
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)(arg1)->Get_Current_Parent_Total_Time();
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void _wrap_delete_CProfileIterator (CProfileIterator *larg1) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_Start_Profile (char *larg1) {
  char *arg1 = (char *) 0 ;
  
  arg1 = larg1;
  try {
    CProfileManager::Start_Profile((char const *)arg1);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_Stop_Profile () {
  try {
    CProfileManager::Stop_Profile();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_CleanupMemory () {
  try {
    CProfileManager::CleanupMemory();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_Reset () {
  try {
    CProfileManager::Reset();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_Increment_Frame_Counter () {
  try {
    CProfileManager::Increment_Frame_Counter();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_CProfileManager_Get_Frame_Count_Since_Reset () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)CProfileManager::Get_Frame_Count_Since_Reset();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_CProfileManager_Get_Time_Since_Reset () {
  float lresult = (float)0 ;
  float result;
  
  try {
    result = (float)CProfileManager::Get_Time_Since_Reset();
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT CProfileIterator *_wrap_CProfileManager_Get_Iterator () {
  CProfileIterator * lresult = (CProfileIterator *)0 ;
  CProfileIterator *result = 0 ;
  
  try {
    result = (CProfileIterator *)CProfileManager::Get_Iterator();
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileIterator *)0;
  }
}


EXPORT void _wrap_CProfileManager_Release_Iterator (CProfileIterator *larg1) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  
  arg1 = larg1;
  try {
    CProfileManager::Release_Iterator(arg1);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_dumpRecursive (CProfileIterator *larg1, int larg2) {
  CProfileIterator *arg1 = (CProfileIterator *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    CProfileManager::dumpRecursive(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CProfileManager_dumpAll () {
  try {
    CProfileManager::dumpAll();
    
  } catch (...) {
    
  }
}


EXPORT CProfileManager *_wrap_new_CProfileManager () {
  CProfileManager * lresult = (CProfileManager *)0 ;
  CProfileManager *result = 0 ;
  
  try {
    result = (CProfileManager *)new CProfileManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileManager *)0;
  }
}


EXPORT void _wrap_delete_CProfileManager (CProfileManager *larg1) {
  CProfileManager *arg1 = (CProfileManager *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT CProfileSample *_wrap_new_CProfileSample (char *larg1) {
  CProfileSample * lresult = (CProfileSample *)0 ;
  char *arg1 = (char *) 0 ;
  CProfileSample *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (CProfileSample *)new CProfileSample((char const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (CProfileSample *)0;
  }
}


EXPORT void _wrap_delete_CProfileSample (CProfileSample *larg1) {
  CProfileSample *arg1 = (CProfileSample *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btIDebugDraw (btIDebugDraw *larg1) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawLine__SWIG_0 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->drawLine((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawLine__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->drawLine((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawSphere__SWIG_0 (btIDebugDraw *larg1, btScalar larg2, btTransform *larg3, btVector3 *larg4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->drawSphere(arg2,(btTransform const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawSphere__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btScalar larg3, btVector3 *larg4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->drawSphere((btVector3 const &)*arg2,arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawTriangle__SWIG_0 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btScalar larg9) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btScalar arg9 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    (arg1)->drawTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawTriangle__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btScalar larg6) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->drawTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawContactPoint (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4, int larg5, btVector3 *larg6) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  int arg5 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->drawContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_reportErrorWarning (btIDebugDraw *larg1, char *larg2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->reportErrorWarning((char const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_draw3dText (btIDebugDraw *larg1, btVector3 *larg2, char *larg3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->draw3dText((btVector3 const &)*arg2,(char const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_setDebugMode (btIDebugDraw *larg1, int larg2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDebugMode(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btIDebugDraw_getDebugMode (btIDebugDraw *larg1) {
  int lresult = (int)0 ;
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btIDebugDraw const *)arg1)->getDebugMode();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btIDebugDraw_drawAabb (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->drawAabb((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawTransform (btIDebugDraw *larg1, btTransform *larg2, btScalar larg3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btTransform *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->drawTransform((btTransform const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawArc__SWIG_0 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btScalar larg7, btScalar larg8, btVector3 *larg9, int larg10, btScalar larg11) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btVector3 *arg9 = 0 ;
  bool arg10 ;
  btScalar arg11 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = (bool)larg10;
  arg11 = larg11;
  try {
    (arg1)->drawArc((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,(btVector3 const &)*arg9,arg10,arg11);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawArc__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btScalar larg7, btScalar larg8, btVector3 *larg9, int larg10) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btVector3 *arg9 = 0 ;
  bool arg10 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = (bool)larg10;
  try {
    (arg1)->drawArc((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,(btVector3 const &)*arg9,arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawSpherePatch__SWIG_0 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btScalar larg7, btScalar larg8, btScalar larg9, btVector3 *larg10, btScalar larg11, int larg12) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  btScalar arg11 ;
  bool arg12 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = (bool)larg12;
  try {
    (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10,arg11,arg12);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawSpherePatch__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btScalar larg7, btScalar larg8, btScalar larg9, btVector3 *larg10, btScalar larg11) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  btScalar arg11 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10,arg11);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawSpherePatch__SWIG_2 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btScalar larg7, btScalar larg8, btScalar larg9, btVector3 *larg10) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawBox__SWIG_0 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->drawBox((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawBox__SWIG_1 (btIDebugDraw *larg1, btVector3 *larg2, btVector3 *larg3, btTransform *larg4, btVector3 *larg5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->drawBox((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawCapsule (btIDebugDraw *larg1, btScalar larg2, btScalar larg3, int larg4, btTransform *larg5, btVector3 *larg6) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->drawCapsule(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawCylinder (btIDebugDraw *larg1, btScalar larg2, btScalar larg3, int larg4, btTransform *larg5, btVector3 *larg6) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->drawCylinder(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawCone (btIDebugDraw *larg1, btScalar larg2, btScalar larg3, int larg4, btTransform *larg5, btVector3 *larg6) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->drawCone(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btIDebugDraw_drawPlane (btIDebugDraw *larg1, btVector3 *larg2, btScalar larg3, btTransform *larg4, btVector3 *larg5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->drawPlane((btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDynamicsWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_0 (btDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_1 (btDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_2 (btDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_debugDrawWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_0 (btDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_1 (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeConstraint (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setGravity (btDynamicsWorld *larg1, btVector3 *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDynamicsWorld_getGravity (btDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_synchronizeMotionStates (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_0 (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_1 (btDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeRigidBody (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setConstraintSolver (btDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDynamicsWorld_getConstraintSolver (btDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_getNumConstraints (btDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_0 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_1 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDynamicsWorld_getWorldType (btDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_clearForces (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_0 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3, int larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_1 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_2 (btDynamicsWorld *larg1, btInternalTickCallback larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalTickCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setWorldUserInfo (btDynamicsWorld *larg1, void *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldUserInfo(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btDynamicsWorld_getWorldUserInfo (btDynamicsWorld *larg1) {
  void * lresult = (void *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btDynamicsWorld const *)arg1)->getWorldUserInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT btContactSolverInfo *_wrap_btDynamicsWorld_getSolverInfo (btDynamicsWorld *larg1) {
  btContactSolverInfo * lresult = (btContactSolverInfo *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btContactSolverInfo *) &(arg1)->getSolverInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btContactSolverInfo *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_addVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btDiscreteDynamicsWorld *_wrap_new_btDiscreteDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btDiscreteDynamicsWorld * lresult = (btDiscreteDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btDiscreteDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btDiscreteDynamicsWorld *)new btDiscreteDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDiscreteDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btDiscreteDynamicsWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_0 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_1 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_2 (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeMotionStates (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeSingleMotionState (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->synchronizeSingleMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_0 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)(arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_1 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)((btDiscreteDynamicsWorld const *)arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btCollisionWorld *_wrap_btDiscreteDynamicsWorld_getCollisionWorld (btDiscreteDynamicsWorld *larg1) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionWorld *)(arg1)->getCollisionWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setGravity (btDiscreteDynamicsWorld *larg1, btVector3 *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDiscreteDynamicsWorld_getGravity (btDiscreteDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDiscreteDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_0 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_1 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_2 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_0 (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_1 (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeRigidBody (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCollisionObject (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->debugDrawConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setConstraintSolver (btDiscreteDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDiscreteDynamicsWorld_getConstraintSolver (btDiscreteDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getNumConstraints (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDiscreteDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDiscreteDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDiscreteDynamicsWorld_getWorldType (btDiscreteDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDiscreteDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_clearForces (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_applyGravity (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setNumTasks (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumTasks(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_updateVehicles (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateVehicles(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setSynchronizeAllMotionStates(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getSynchronizeAllMotionStates();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setApplySpeculativeContactRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getApplySpeculativeContactRestitution();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_serialize (btDiscreteDynamicsWorld *larg1, btSerializer *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setLatencyMotionStateInterpolation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getLatencyMotionStateInterpolation();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btSimpleDynamicsWorld *_wrap_new_btSimpleDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btSimpleDynamicsWorld * lresult = (btSimpleDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSimpleDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSimpleDynamicsWorld *)new btSimpleDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btSimpleDynamicsWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_0 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_1 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_2 (btSimpleDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setGravity (btSimpleDynamicsWorld *larg1, btVector3 *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSimpleDynamicsWorld_getGravity (btSimpleDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btSimpleDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_0 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_1 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeRigidBody (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_debugDrawWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeCollisionObject (btSimpleDynamicsWorld *larg1, btCollisionObject *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_updateAabbs (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_synchronizeMotionStates (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setConstraintSolver (btSimpleDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btSimpleDynamicsWorld_getConstraintSolver (btSimpleDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btSimpleDynamicsWorld_getWorldType (btSimpleDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btSimpleDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_clearForces (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_0 (btRigidBody::btRigidBodyConstructionInfo *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_1 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_2 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_delete_btRigidBody (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_proceedToTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->proceedToTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_0 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_1 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btRigidBody_predictIntegratedTransform (btRigidBody *larg1, btScalar larg2, btTransform *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->predictIntegratedTransform(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_saveKinematicState (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->saveKinematicState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyGravity (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setGravity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getGravity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setDamping (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_applyDamping (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMassProps (btRigidBody *larg1, btScalar larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearFactor (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getInvMass (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld (btRigidBody *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_integrateVelocities (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->integrateVelocities(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setCenterOfMassTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralForce (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralForce((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalForce (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalTorque (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setInvInertiaDiagLocal (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setSleepingThresholds (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSleepingThresholds(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorque (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorque((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyForce (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorqueImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyImpulse (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_clearForces (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_updateInertiaTensor (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateInertiaTensor();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getCenterOfMassPosition (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btRigidBody_getOrientation (btRigidBody *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btRigidBody const *)arg1)->getOrientation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btTransform *_wrap_btRigidBody_getCenterOfMassTransform (btRigidBody *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint (btRigidBody *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_translate (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->translate((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_getAabb (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_computeImpulseDenominator (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_computeAngularImpulseDenominator (btRigidBody *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_updateDeactivation (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateDeactivation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_wantsSleeping (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->wantsSleeping();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btRigidBody_setNewBroadphaseProxy (btRigidBody *larg1, btBroadphaseProxy *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNewBroadphaseProxy(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)(arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMotionState (btRigidBody *larg1, btMotionState *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_m_contactSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_contactSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_contactSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_m_frictionSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_frictionSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_frictionSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_frictionSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_0 (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_1 (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_isInWorld (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btRigidBody const *)arg1)->isInWorld();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRigidBody_checkCollideWithOverride (btRigidBody *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btRigidBody const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_addConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_removeConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTypedConstraint *_wrap_btRigidBody_getConstraintRef (btRigidBody *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT int _wrap_btRigidBody_getNumConstraintRefs (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setFlags (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_getFlags (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_computeGyroscopicForce (btRigidBody *larg1, btScalar larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->computeGyroscopicForce(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_calculateSerializeBufferSize (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btRigidBody_serialize (btRigidBody *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btRigidBody_serializeSingleObject (btRigidBody *larg1, btSerializer *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_0 () {
  btJacobianEntry * lresult = (btJacobianEntry *)0 ;
  btJacobianEntry *result = 0 ;
  
  try {
    result = (btJacobianEntry *)new btJacobianEntry();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJacobianEntry *)0;
  }
}


EXPORT btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_1 (btMatrix3x3 *larg1, btMatrix3x3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, btScalar larg7, btVector3 *larg8, btScalar larg9) {
  btJacobianEntry * lresult = (btJacobianEntry *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btVector3 *arg8 = 0 ;
  btScalar arg9 ;
  btJacobianEntry *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,(btVector3 const &)*arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJacobianEntry *)0;
  }
}


EXPORT btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_2 (btVector3 *larg1, btMatrix3x3 *larg2, btMatrix3x3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btJacobianEntry * lresult = (btJacobianEntry *)0 ;
  btVector3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btJacobianEntry *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btMatrix3x3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJacobianEntry *)0;
  }
}


EXPORT btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btJacobianEntry * lresult = (btJacobianEntry *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btJacobianEntry *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJacobianEntry *)0;
  }
}


EXPORT btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_4 (btMatrix3x3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btScalar larg6) {
  btJacobianEntry * lresult = (btJacobianEntry *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar arg6 ;
  btJacobianEntry *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJacobianEntry *)0;
  }
}


EXPORT btScalar _wrap_btJacobianEntry_getDiagonal (btJacobianEntry *larg1) {
  btScalar lresult = (btScalar)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btJacobianEntry const *)arg1)->getDiagonal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btJacobianEntry_getNonDiagonal__SWIG_0 (btJacobianEntry *larg1, btJacobianEntry *larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btJacobianEntry_getNonDiagonal__SWIG_1 (btJacobianEntry *larg1, btJacobianEntry *larg2, btScalar larg3, btScalar larg4) {
  btScalar lresult = (btScalar)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btJacobianEntry_getRelativeVelocity (btJacobianEntry *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btScalar lresult = (btScalar)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)(arg1)->getRelativeVelocity((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_linearJointAxis_set (btJacobianEntry *larg1, btVector3 *larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_linearJointAxis = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btJacobianEntry_m_linearJointAxis_get (btJacobianEntry *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_linearJointAxis);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_aJ_set (btJacobianEntry *larg1, btVector3 *larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_aJ = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btJacobianEntry_m_aJ_get (btJacobianEntry *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_aJ);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_bJ_set (btJacobianEntry *larg1, btVector3 *larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_bJ = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btJacobianEntry_m_bJ_get (btJacobianEntry *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_bJ);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_0MinvJt_set (btJacobianEntry *larg1, btVector3 *larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_0MinvJt = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btJacobianEntry_m_0MinvJt_get (btJacobianEntry *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_0MinvJt);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_1MinvJt_set (btJacobianEntry *larg1, btVector3 *larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_1MinvJt = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btJacobianEntry_m_1MinvJt_get (btJacobianEntry *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_1MinvJt);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btJacobianEntry_m_Adiag_set (btJacobianEntry *larg1, btScalar larg2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_Adiag = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btJacobianEntry_m_Adiag_get (btJacobianEntry *larg1) {
  btScalar lresult = (btScalar)0 ;
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_Adiag);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btJacobianEntry (btJacobianEntry *larg1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTypedConstraint (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getFixedBody () {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody *result = 0 ;
  
  try {
    result = (btRigidBody *) &btTypedConstraint::getFixedBody();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getOverrideNumSolverIterations (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setOverrideNumSolverIterations (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverrideNumSolverIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_buildJacobian (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setupSolverConstraint (btTypedConstraint *larg1, btConstraintArray *larg2, int larg3, int larg4, btScalar larg5) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo1 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo2 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_internalSetAppliedImpulse (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetAppliedImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_internalGetAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->internalGetAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getBreakingImpulseThreshold (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setBreakingImpulseThreshold (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBreakingImpulseThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_isEnabled (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setEnabled (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setEnabled(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_solveConstraintObsolete (btTypedConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintType (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintType (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintType(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintId (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintId (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintPtr (btTypedConstraint *larg1, void *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintPtr(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btTypedConstraint_getUserConstraintPtr (btTypedConstraint *larg1) {
  void * lresult = (void *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)(arg1)->getUserConstraintPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setJointFeedback (btTypedConstraint *larg1, btJointFeedback *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setJointFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)(arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUid (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUid();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTypedConstraint_needsFeedback (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_enableFeedback (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btTypedConstraintType _wrap_btTypedConstraint_getConstraintType (btTypedConstraint *larg1) {
  btTypedConstraintType lresult = (btTypedConstraintType)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  
  arg1 = larg1;
  try {
    result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraintType)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setDbgDrawSize (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDbgDrawSize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getDbgDrawSize (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDbgDrawSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_0 (btTypedConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_1 (btTypedConstraint *larg1, int larg2, btScalar larg3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_0 (btTypedConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_1 (btTypedConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btTypedConstraint_calculateSerializeBufferSize (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btTypedConstraint_serialize (btTypedConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btScalar _wrap_btAdjustAngleToLimits (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btAngularLimit *_wrap_new_btAngularLimit () {
  btAngularLimit * lresult = (btAngularLimit *)0 ;
  btAngularLimit *result = 0 ;
  
  try {
    result = (btAngularLimit *)new btAngularLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAngularLimit *)0;
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_0 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_1 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_2 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->set(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_3 (btAngularLimit *larg1, btScalar larg2, btScalar larg3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->set(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_test (btAngularLimit *larg1, btScalar larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->test(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSoftness (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getBiasFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getRelaxationFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getCorrection (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSign (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHalfRange (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btAngularLimit_isLimit (btAngularLimit *larg1) {
  int lresult = (int)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btAngularLimit const *)arg1)->isLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btAngularLimit_fit (btAngularLimit *larg1, btScalar *larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btAngularLimit const *)arg1)->fit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getError (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getError();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getLow (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getLow();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHigh (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btAngularLimit (btAngularLimit *larg1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_set (btPoint2PointConstraint *larg1, int larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_get (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_setting_set (btPoint2PointConstraint *larg1, btConstraintSetting *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *arg2 = (btConstraintSetting *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_setting = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSetting *_wrap_btPoint2PointConstraint_m_setting_get (btPoint2PointConstraint *larg1) {
  btConstraintSetting * lresult = (btConstraintSetting *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSetting *)& ((arg1)->m_setting);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSetting *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_1 (btRigidBody *larg1, btVector3 *larg2) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_buildJacobian (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_updateRHS (btPoint2PointConstraint *larg1, btScalar larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotA (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotA((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotB (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotB((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInA (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInB (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btPoint2PointConstraint_calculateSerializeBufferSize (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPoint2PointConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btPoint2PointConstraint_serialize (btPoint2PointConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btPoint2PointConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btPoint2PointConstraint (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, int larg7) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool arg7 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_1 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_2 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool arg4 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_3 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_4 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_5 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_6 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_7 (btRigidBody *larg1, btTransform *larg2) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_buildJacobian (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2Internal (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2Internal(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2InternalUsingFrameOffset (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2InternalUsingFrameOffset(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_updateRHS (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetA (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetB (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setFrames (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAngularOnly (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableAngularMotor (btHingeConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->enableAngularMotor(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableMotor (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMaxMotorImpulse (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_0 (btHingeConstraint *larg1, btQuaternion *larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_0 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_2 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_3 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAxis (btHingeConstraint *larg1, btVector3 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAxis(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLowerLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getLowerLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getUpperLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getUpperLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_0 (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getHingeAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_1 (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)(arg1)->getHingeAngle((btTransform const &)*arg2,(btTransform const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHingeConstraint_testLimit (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->testLimit((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getSolveLimit (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLimitSign (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getAngularOnly (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getAngularOnly();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getEnableAngularMotor (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getEnableAngularMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMotorTargetVelosity (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMotorTargetVelosity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMaxMotorImpulse (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxMotorImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getUseFrameOffset (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setUseFrameOffset (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_0 (btHingeConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_1 (btHingeConstraint *larg1, int larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_0 (btHingeConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_1 (btHingeConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_calculateSerializeBufferSize (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHingeConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btHingeConstraint_serialize (btHingeConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btHingeConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btHingeConstraint (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_buildJacobian (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btMatrix3x3 *larg5, btMatrix3x3 *larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  btMatrix3x3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btMatrix3x3 const &)*arg5,(btMatrix3x3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_solveConstraintObsolete (btConeTwistConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_updateRHS (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyA (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyB (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setAngularOnly (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_1 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6, btScalar larg7) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6,arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_2 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_3 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_4 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getAFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getBFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveTwistLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveTwistLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveSwingLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistLimitSign (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAngleInfo();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo2 (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3, btMatrix3x3 *larg4, btMatrix3x3 *larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->calcAngleInfo2((btTransform const &)*arg2,(btTransform const &)*arg3,(btMatrix3x3 const &)*arg4,(btMatrix3x3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan1 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan2 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistSpan (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistSpan();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistAngle (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_isPastSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isPastSwingLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setDamping (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_enableMotor (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulse (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulseNormalized (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulseNormalized(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getFixThresh (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getFixThresh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFixThresh (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFixThresh(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTarget (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTargetInConstraintSpace (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTargetInConstraintSpace((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConeTwistConstraint_GetPointForAngle (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btConeTwistConstraint const *)arg1)->GetPointForAngle(arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFrames (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetA (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetB (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_calculateSerializeBufferSize (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConeTwistConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConeTwistConstraint_serialize (btConeTwistConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConeTwistConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeTwistConstraint (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_loLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_loLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_loLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_loLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_hiLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_hiLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_hiLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_hiLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_targetVelocity_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_targetVelocity_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxMotorForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxMotorForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxLimitForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxLimitForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxLimitForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxLimitForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_damping_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_damping_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_limitSoftness_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_limitSoftness_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_normalCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_normalCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopERP_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopERP_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_bounce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_bounce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_bounce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_bounce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_enableMotor_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_enableMotor = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_enableMotor_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_enableMotor);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimitError_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentLimitError_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentPosition_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentPosition = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentPosition_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentPosition);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimit_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_currentLimit_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_accumulatedImpulse_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_accumulatedImpulse_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_0 () {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *result = 0 ;
  
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_1 (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *arg1 = 0 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor((btRotationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_isLimited (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isLimited();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_needApplyTorques (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->needApplyTorques();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_testLimitValue (btRotationalLimitMotor *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->testLimitValue(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_solveAngularLimits (btRotationalLimitMotor *larg1, btScalar larg2, btVector3 *larg3, btScalar larg4, btRigidBody *larg5, btRigidBody *larg6) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btRigidBody *arg5 = (btRigidBody *) 0 ;
  btRigidBody *arg6 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btScalar)(arg1)->solveAngularLimits(arg2,*arg3,arg4,arg5,arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btRotationalLimitMotor (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_lowerLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lowerLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_lowerLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_lowerLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_upperLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_upperLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_upperLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_upperLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_accumulatedImpulse_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_accumulatedImpulse_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_limitSoftness_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_limitSoftness_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_damping_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_damping_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_restitution_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_restitution = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_restitution_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_restitution);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_normalCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_normalCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopERP_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopERP_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_enableMotor_set (btTranslationalLimitMotor *larg1, bool *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      bool *b = (bool *) arg1->m_enableMotor;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((bool *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT bool *_wrap_btTranslationalLimitMotor_m_enableMotor_get (btTranslationalLimitMotor *larg1) {
  bool * lresult = (bool *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (bool *)(bool *) ((arg1)->m_enableMotor);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bool *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_targetVelocity_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_targetVelocity_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_maxMotorForce_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_maxMotorForce_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimitError_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLimitError_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLinearDiff_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLinearDiff = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLinearDiff_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLinearDiff);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimit_set (btTranslationalLimitMotor *larg1, int *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      int *b = (int *) arg1->m_currentLimit;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT int *_wrap_btTranslationalLimitMotor_m_currentLimit_get (btTranslationalLimitMotor *larg1) {
  int * lresult = (int *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (int *)(int *) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_0 () {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_1 (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *arg1 = 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor((btTranslationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_isLimited (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_needApplyForce (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->needApplyForce(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_testLimitValue (btTranslationalLimitMotor *larg1, int larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->testLimitValue(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_solveLinearAxis (btTranslationalLimitMotor *larg1, btScalar larg2, btScalar larg3, btRigidBody *larg4, btVector3 *larg5, btRigidBody *larg6, btVector3 *larg7, int larg8, btVector3 *larg9, btVector3 *larg10) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btRigidBody *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btRigidBody *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  int arg8 ;
  btVector3 *arg9 = 0 ;
  btVector3 *arg10 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveLinearAxis(arg2,arg3,*arg4,(btVector3 const &)*arg5,*arg6,(btVector3 const &)*arg7,arg8,(btVector3 const &)*arg9,(btVector3 const &)*arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btTranslationalLimitMotor (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_set (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_get (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_0 (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calculateTransforms();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformA (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformB (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_buildJacobian (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_updateRHS (btGeneric6DofConstraint *larg1, btScalar larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btGeneric6DofConstraint_getAxis (btGeneric6DofConstraint *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btGeneric6DofConstraint const *)arg1)->getAxis(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getAngle (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getAngle(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getRelativePivotPosition (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getRelativePivotPosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setFrames (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_testAngularLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->testAngularLimitMotor(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRotationalLimitMotor *_wrap_btGeneric6DofConstraint_getRotationalLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btRotationalLimitMotor *)(arg1)->getRotationalLimitMotor(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_btGeneric6DofConstraint_getTranslationalLimitMotor (btGeneric6DofConstraint *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)(arg1)->getTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLimit (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_isLimited (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calcAnchorPos (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAnchorPos();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_0 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12, int larg13) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int arg13 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12,arg13);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_1 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_getUseFrameOffset (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setUseFrameOffset (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAxis (btGeneric6DofConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_calculateSerializeBufferSize (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofConstraint_serialize (btGeneric6DofConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofConstraint (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btScalar larg7, btScalar larg8) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyA (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyB (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformA (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformB (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getUseLinearReferenceFrameA (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseLinearReferenceFrameA();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredLinMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredLinMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredLinMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredLinMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetLinMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetLinMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetLinMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetLinMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxLinMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxLinMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxLinMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxLinMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredAngMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredAngMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredAngMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredAngMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetAngMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetAngMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetAngMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetAngMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxAngMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxAngMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxAngMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxAngMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinearPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getLinearPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngularPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getAngularPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveLinLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveLinLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLinDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveAngLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveAngLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_calculateTransforms (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testLinLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testLinLimits();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testAngLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testAngLimits();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInA (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInA();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInB (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInB();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getUseFrameOffset (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUseFrameOffset (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setFrames (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_0 (btSliderConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_1 (btSliderConstraint *larg1, int larg2, btScalar larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_0 (btSliderConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_1 (btSliderConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_calculateSerializeBufferSize (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSliderConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btSliderConstraint_serialize (btSliderConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btSliderConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btSliderConstraint (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_enableSpring (btGeneric6DofSpringConstraint *larg1, int larg2, int larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->enableSpring(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setStiffness (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setStiffness(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setDamping (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_0 (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setEquilibriumPoint();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_1 (btGeneric6DofSpringConstraint *larg1, int larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setEquilibriumPoint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_2 (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setEquilibriumPoint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setAxis (btGeneric6DofSpringConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_getInfo2 (btGeneric6DofSpringConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofSpringConstraint_calculateSerializeBufferSize (btGeneric6DofSpringConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofSpringConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofSpringConstraint_serialize (btGeneric6DofSpringConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofSpringConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofSpringConstraint (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btUniversalConstraint *_wrap_new_btUniversalConstraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btUniversalConstraint * lresult = (btUniversalConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btUniversalConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btUniversalConstraint *)new btUniversalConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btUniversalConstraint *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis1 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle1 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle2 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btUniversalConstraint_setUpperLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setUpperLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setLowerLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLowerLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setAxis (btUniversalConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btUniversalConstraint (btUniversalConstraint *larg1) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHinge2Constraint *_wrap_new_btHinge2Constraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btHinge2Constraint * lresult = (btHinge2Constraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btHinge2Constraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btHinge2Constraint *)new btHinge2Constraint(*arg1,*arg2,*arg3,*arg4,*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHinge2Constraint *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis1 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle1 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle2 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHinge2Constraint_setUpperLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHinge2Constraint_setLowerLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btHinge2Constraint (btHinge2Constraint *larg1) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btGearConstraint *_wrap_new_btGearConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5) {
  btGearConstraint * lresult = (btGearConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btGearConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btGearConstraint *)new btGearConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGearConstraint *)0;
  }
}


EXPORT btGearConstraint *_wrap_new_btGearConstraint__SWIG_1 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4) {
  btGearConstraint * lresult = (btGearConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btGearConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btGearConstraint *)new btGearConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGearConstraint *)0;
  }
}


EXPORT void _wrap_delete_btGearConstraint (btGearConstraint *larg1) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_getInfo1 (btGearConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_getInfo2 (btGearConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_setAxisA (btGearConstraint *larg1, btVector3 *larg2) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAxisA(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_setAxisB (btGearConstraint *larg1, btVector3 *larg2) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAxisB(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_setRatio (btGearConstraint *larg1, btScalar larg2) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRatio(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btGearConstraint_getAxisA (btGearConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btGearConstraint const *)arg1)->getAxisA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btGearConstraint_getAxisB (btGearConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btGearConstraint const *)arg1)->getAxisB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btGearConstraint_getRatio (btGearConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btGearConstraint const *)arg1)->getRatio();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGearConstraint_setParam__SWIG_0 (btGearConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGearConstraint_setParam__SWIG_1 (btGearConstraint *larg1, int larg2, btScalar larg3) {
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btGearConstraint_getParam__SWIG_0 (btGearConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btGearConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGearConstraint_getParam__SWIG_1 (btGearConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGearConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btGearConstraint_calculateSerializeBufferSize (btGearConstraint *larg1) {
  int lresult = (int)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGearConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGearConstraint_serialize (btGearConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGearConstraint *arg1 = (btGearConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGearConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btFixedConstraint *_wrap_new_btFixedConstraint (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btFixedConstraint * lresult = (btFixedConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btFixedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btFixedConstraint *)new btFixedConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btFixedConstraint *)0;
  }
}


EXPORT void _wrap_delete_btFixedConstraint (btFixedConstraint *larg1) {
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btFixedConstraint_getInfo1 (btFixedConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btFixedConstraint_getInfo2 (btFixedConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btFixedConstraint_setParam__SWIG_0 (btFixedConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btFixedConstraint_setParam__SWIG_1 (btFixedConstraint *larg1, int larg2, btScalar larg3) {
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btFixedConstraint_getParam__SWIG_0 (btFixedConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btFixedConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFixedConstraint_getParam__SWIG_1 (btFixedConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btFixedConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btConstraintSolver (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_prepareSolve (btConstraintSolver *larg1, int larg2, int larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->prepareSolve(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConstraintSolver_solveGroup (btConstraintSolver *larg1, btCollisionObject **larg2, int larg3, btPersistentManifold **larg4, int larg5, btTypedConstraint **larg6, int larg7, btContactSolverInfo *larg8, btIDebugDraw *larg9, btDispatcher *larg10) {
  btScalar lresult = (btScalar)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConstraintSolver_allSolved (btConstraintSolver *larg1, btContactSolverInfo *larg2, btIDebugDraw *larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  btIDebugDraw *arg3 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->allSolved((btContactSolverInfo const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_reset (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolverType _wrap_btConstraintSolver_getSolverType (btConstraintSolver *larg1) {
  btConstraintSolverType lresult = (btConstraintSolverType)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btConstraintSolverType result;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolverType)((btConstraintSolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolverType)0;
  }
}


EXPORT btSequentialImpulseConstraintSolver *_wrap_new_btSequentialImpulseConstraintSolver () {
  btSequentialImpulseConstraintSolver * lresult = (btSequentialImpulseConstraintSolver *)0 ;
  btSequentialImpulseConstraintSolver *result = 0 ;
  
  try {
    result = (btSequentialImpulseConstraintSolver *)new btSequentialImpulseConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSequentialImpulseConstraintSolver *)0;
  }
}


EXPORT void _wrap_delete_btSequentialImpulseConstraintSolver (btSequentialImpulseConstraintSolver *larg1) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSequentialImpulseConstraintSolver_solveGroup (btSequentialImpulseConstraintSolver *larg1, btCollisionObject **larg2, int larg3, btPersistentManifold **larg4, int larg5, btTypedConstraint **larg6, int larg7, btContactSolverInfo *larg8, btIDebugDraw *larg9, btDispatcher *larg10) {
  btScalar lresult = (btScalar)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSequentialImpulseConstraintSolver_reset (btSequentialImpulseConstraintSolver *larg1) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT unsigned long _wrap_btSequentialImpulseConstraintSolver_btRand2 (btSequentialImpulseConstraintSolver *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)(arg1)->btRand2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT int _wrap_btSequentialImpulseConstraintSolver_btRandInt2 (btSequentialImpulseConstraintSolver *larg1, int larg2) {
  int lresult = (int)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->btRandInt2(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSequentialImpulseConstraintSolver_setRandSeed (btSequentialImpulseConstraintSolver *larg1, unsigned long larg2) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRandSeed(arg2);
    
  } catch (...) {
    
  }
}


EXPORT unsigned long _wrap_btSequentialImpulseConstraintSolver_getRandSeed (btSequentialImpulseConstraintSolver *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)((btSequentialImpulseConstraintSolver const *)arg1)->getRandSeed();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT btConstraintSolverType _wrap_btSequentialImpulseConstraintSolver_getSolverType (btSequentialImpulseConstraintSolver *larg1) {
  btConstraintSolverType lresult = (btConstraintSolverType)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  btConstraintSolverType result;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolverType)((btSequentialImpulseConstraintSolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolverType)0;
  }
}


EXPORT void _wrap_delete_btActionInterface (btActionInterface *larg1) {
  btActionInterface *arg1 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btActionInterface_updateAction (btActionInterface *larg1, btCollisionWorld *larg2, btScalar larg3) {
  btActionInterface *arg1 = (btActionInterface *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->updateAction(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btActionInterface_debugDraw (btActionInterface *larg1, btIDebugDraw *larg2) {
  btActionInterface *arg1 = (btActionInterface *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->debugDraw(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRaycastVehicle *_wrap_new_btRaycastVehicle (btRaycastVehicle::btVehicleTuning *larg1, btRigidBody *larg2, btVehicleRaycaster *larg3) {
  btRaycastVehicle * lresult = (btRaycastVehicle *)0 ;
  btRaycastVehicle::btVehicleTuning *arg1 = 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  btVehicleRaycaster *arg3 = (btVehicleRaycaster *) 0 ;
  btRaycastVehicle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btRaycastVehicle *)new btRaycastVehicle((btRaycastVehicle::btVehicleTuning const &)*arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRaycastVehicle *)0;
  }
}


EXPORT void _wrap_delete_btRaycastVehicle (btRaycastVehicle *larg1) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_updateAction (btRaycastVehicle *larg1, btCollisionWorld *larg2, btScalar larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->updateAction(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_debugDraw (btRaycastVehicle *larg1, btIDebugDraw *larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->debugDraw(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btRaycastVehicle_getChassisWorldTransform (btRaycastVehicle *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btRaycastVehicle const *)arg1)->getChassisWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btRaycastVehicle_rayCast (btRaycastVehicle *larg1, btWheelInfo *larg2) {
  btScalar lresult = (btScalar)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btWheelInfo *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)(arg1)->rayCast(*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_updateVehicle (btRaycastVehicle *larg1, btScalar larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_resetSuspension (btRaycastVehicle *larg1) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->resetSuspension();
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRaycastVehicle_getSteeringValue (btRaycastVehicle *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btRaycastVehicle const *)arg1)->getSteeringValue(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_setSteeringValue (btRaycastVehicle *larg1, btScalar larg2, int larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSteeringValue(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_applyEngineForce (btRaycastVehicle *larg1, btScalar larg2, int larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyEngineForce(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btRaycastVehicle_getWheelTransformWS (btRaycastVehicle *larg1, int larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &((btRaycastVehicle const *)arg1)->getWheelTransformWS(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_updateWheelTransform__SWIG_0 (btRaycastVehicle *larg1, int larg2, int larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->updateWheelTransform(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_updateWheelTransform__SWIG_1 (btRaycastVehicle *larg1, int larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateWheelTransform(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btWheelInfo *_wrap_btRaycastVehicle_addWheel (btRaycastVehicle *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btScalar larg6, btRaycastVehicle::btVehicleTuning *larg7, int larg8) {
  btWheelInfo * lresult = (btWheelInfo *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btRaycastVehicle::btVehicleTuning *arg7 = 0 ;
  bool arg8 ;
  btWheelInfo *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = (bool)larg8;
  try {
    result = (btWheelInfo *) &(arg1)->addWheel((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,(btRaycastVehicle::btVehicleTuning const &)*arg7,arg8);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btWheelInfo *)0;
  }
}


EXPORT int _wrap_btRaycastVehicle_getNumWheels (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getNumWheels();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btWheelInfo *_wrap_btRaycastVehicle_getWheelInfo__SWIG_0 (btRaycastVehicle *larg1, int larg2) {
  btWheelInfo * lresult = (btWheelInfo *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  btWheelInfo *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btWheelInfo *) &((btRaycastVehicle const *)arg1)->getWheelInfo(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btWheelInfo *)0;
  }
}


EXPORT btWheelInfo *_wrap_btRaycastVehicle_getWheelInfo__SWIG_1 (btRaycastVehicle *larg1, int larg2) {
  btWheelInfo * lresult = (btWheelInfo *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  btWheelInfo *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btWheelInfo *) &(arg1)->getWheelInfo(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btWheelInfo *)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_updateWheelTransformsWS__SWIG_0 (btRaycastVehicle *larg1, btWheelInfo *larg2, int larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btWheelInfo *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->updateWheelTransformsWS(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_updateWheelTransformsWS__SWIG_1 (btRaycastVehicle *larg1, btWheelInfo *larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btWheelInfo *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateWheelTransformsWS(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_setBrake (btRaycastVehicle *larg1, btScalar larg2, int larg3) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setBrake(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_setPitchControl (btRaycastVehicle *larg1, btScalar larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPitchControl(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_updateSuspension (btRaycastVehicle *larg1, btScalar larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateSuspension(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_updateFriction (btRaycastVehicle *larg1, btScalar larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btRaycastVehicle_getRigidBody__SWIG_0 (btRaycastVehicle *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)(arg1)->getRigidBody();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btRaycastVehicle_getRigidBody__SWIG_1 (btRaycastVehicle *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)((btRaycastVehicle const *)arg1)->getRigidBody();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btRaycastVehicle_getRightAxis (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getRightAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRaycastVehicle_getUpAxis (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getUpAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRaycastVehicle_getForwardAxis (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getForwardAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btRaycastVehicle_getForwardVector (btRaycastVehicle *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btRaycastVehicle const *)arg1)->getForwardVector();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btRaycastVehicle_getCurrentSpeedKmHour (btRaycastVehicle *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRaycastVehicle const *)arg1)->getCurrentSpeedKmHour();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_setCoordinateSystem (btRaycastVehicle *larg1, int larg2, int larg3, int larg4) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setCoordinateSystem(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRaycastVehicle_getUserConstraintType (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getUserConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRaycastVehicle_setUserConstraintType (btRaycastVehicle *larg1, int larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintType(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRaycastVehicle_setUserConstraintId (btRaycastVehicle *larg1, int larg2) {
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRaycastVehicle_getUserConstraintId (btRaycastVehicle *larg1) {
  int lresult = (int)0 ;
  btRaycastVehicle *arg1 = (btRaycastVehicle *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRaycastVehicle const *)arg1)->getUserConstraintId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btDefaultVehicleRaycaster *_wrap_new_btDefaultVehicleRaycaster (btDynamicsWorld *larg1) {
  btDefaultVehicleRaycaster * lresult = (btDefaultVehicleRaycaster *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDefaultVehicleRaycaster *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultVehicleRaycaster *)new btDefaultVehicleRaycaster(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultVehicleRaycaster *)0;
  }
}


EXPORT void *_wrap_btDefaultVehicleRaycaster_castRay (btDefaultVehicleRaycaster *larg1, btVector3 *larg2, btVector3 *larg3, btVehicleRaycaster::btVehicleRaycasterResult *larg4) {
  void * lresult = (void *)0 ;
  btDefaultVehicleRaycaster *arg1 = (btDefaultVehicleRaycaster *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVehicleRaycaster::btVehicleRaycasterResult *arg4 = 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->castRay((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_delete_btDefaultVehicleRaycaster (btDefaultVehicleRaycaster *larg1) {
  btDefaultVehicleRaycaster *arg1 = (btDefaultVehicleRaycaster *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


